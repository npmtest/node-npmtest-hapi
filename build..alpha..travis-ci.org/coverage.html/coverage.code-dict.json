{"/home/travis/build/npmtest/node-npmtest-hapi/test.js":"/* istanbul instrument in package npmtest_hapi */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-hapi/lib.npmtest_hapi.js":"/* istanbul instrument in package npmtest_hapi */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_hapi = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_hapi = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-hapi/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-hapi && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_hapi */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_hapi\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_hapi.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_hapi.rollup.js'] =\n            local.assetsDict['/assets.npmtest_hapi.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_hapi.__dirname + '/lib.npmtest_hapi.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Server = require('./server');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.Server = Server;\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/server.js":"'use strict';\n\n// Load modules\n\nconst Catbox = require('catbox');\nconst CatboxMemory = require('catbox-memory');\nconst Heavy = require('heavy');\nconst Hoek = require('hoek');\nconst Items = require('items');\nconst Mimos = require('mimos');\nconst Connection = require('./connection');\nconst Defaults = require('./defaults');\nconst Ext = require('./ext');\nconst Methods = require('./methods');\nconst Plugin = require('./plugin');\nconst Podium = require('podium');\nconst Promises = require('./promises');\nconst Reply = require('./reply');\nconst Request = require('./request');\nconst Schema = require('./schema');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Server = function (options) {\n\n    Hoek.assert(this instanceof internals.Server, 'Server must be instantiated using new');\n\n    options = Schema.apply('server', options || {});\n\n    this._settings = Hoek.applyToDefaultsWithShallow(Defaults.server, options, ['connections.routes.bind']);\n    this._settings.connections = Hoek.applyToDefaultsWithShallow(Defaults.connection, this._settings.connections || {}, ['routes.bind']);\n    this._settings.connections.routes.cors = Hoek.applyToDefaults(Defaults.cors, this._settings.connections.routes.cors);\n    this._settings.connections.routes.security = Hoek.applyToDefaults(Defaults.security, this._settings.connections.routes.security);\n\n    this._caches = {};                                                              // Cache clients\n    this._handlers = {};                                                            // Registered handlers\n    this._methods = new Methods(this);                                              // Server methods\n\n    this._events = new Podium([{ name: 'log', tags: true }, 'start', 'stop']);      // Server-only events\n    this._dependencies = [];                                                        // Plugin dependencies\n    this._registrations = {};                                                       // Tracks plugins registered before connection added\n    this._heavy = new Heavy(this._settings.load);\n    this._mime = new Mimos(this._settings.mime);\n    this._replier = new Reply();\n    this._requestor = new Request();\n    this._decorations = {};\n    this._plugins = {};                                                             // Exposed plugin properties by name\n    this._app = {};\n    this._registring = false;                                                       // true while register() is waiting for plugin callbacks\n    this._state = 'stopped';                                                        // 'stopped', 'initializing', 'initialized', 'starting', 'started', 'stopping', 'invalid'\n\n    this._extensionsSeq = 0;                                                        // Used to keep absolute order of extensions based on the order added across locations\n    this._extensions = {\n        onPreStart: new Ext('onPreStart', this),\n        onPostStart: new Ext('onPostStart', this),\n        onPreStop: new Ext('onPreStop', this),\n        onPostStop: new Ext('onPostStop', this)\n    };\n\n    if (options.cache) {\n        this._createCache(options.cache);\n    }\n\n    if (!this._caches._default) {\n        this._createCache([{ engine: CatboxMemory }]);                              // Defaults to memory-based\n    }\n\n    Plugin.call(this, this, [], '', null);\n\n    // Subscribe to server log events\n\n    if (this._settings.debug) {\n        const debug = (request, event) => {\n\n            const data = event.data;\n            console.error('Debug:', event.tags.join(', '), (data ? '\\n    ' + (data.stack || (typeof data === 'object' ? Hoek.stringify(data) : data)) : ''));\n        };\n\n        if (this._settings.debug.log) {\n            this._events.on({ name: 'log', filter: this._settings.debug.log }, (event) => debug(null, event));\n        }\n\n        if (this._settings.debug.request) {\n            this.on({ name: 'request', filter: this._settings.debug.request }, debug);\n            this.on({ name: 'request-internal', filter: this._settings.debug.request }, debug);\n        }\n    }\n};\n\nHoek.inherits(internals.Server, Plugin);\n\n\ninternals.Server.prototype._createCache = function (options, _callback) {\n\n    Hoek.assert(this._state !== 'initializing', 'Cannot provision server cache while server is initializing');\n\n    options = Schema.apply('cache', options);\n\n    const added = [];\n    for (let i = 0; i < options.length; ++i) {\n        let config = options[i];\n        if (typeof config === 'function') {\n            config = { engine: config };\n        }\n\n        const name = config.name || '_default';\n        Hoek.assert(!this._caches[name], 'Cannot configure the same cache more than once: ', name === '_default' ? 'default cache' : name);\n\n        let client = null;\n        if (typeof config.engine === 'object') {\n            client = new Catbox.Client(config.engine);\n        }\n        else {\n            const settings = Hoek.clone(config);\n            settings.partition = settings.partition || 'hapi-cache';\n            delete settings.name;\n            delete settings.engine;\n            delete settings.shared;\n\n            client = new Catbox.Client(config.engine, settings);\n        }\n\n        this._caches[name] = {\n            client,\n            segments: {},\n            shared: config.shared || false\n        };\n\n        added.push(client);\n    }\n\n    if (!_callback) {\n        return;\n    }\n\n    // Start cache\n\n    if (['initialized', 'starting', 'started'].indexOf(this._state) !== -1) {\n        const each = (client, next) => client.start(next);\n        return Items.parallel(added, each, _callback);\n    }\n\n    return Hoek.nextTick(_callback)();\n};\n\n\ninternals.Server.prototype.connection = function (options) {\n\n    const root = this.root;                                     // Explicitly use the root reference (for plugin invocation)\n\n    const connections = [];\n    [].concat(options).forEach((item) => {\n\n        let settings = Hoek.applyToDefaultsWithShallow(root._settings.connections, item || {}, ['listener', 'routes.bind']);\n        settings.routes.cors = Hoek.applyToDefaults(root._settings.connections.routes.cors || Defaults.cors, settings.routes.cors) || false;\n        settings.routes.security = Hoek.applyToDefaults(root._settings.connections.routes.security || Defaults.security, settings.routes.security);\n\n        settings = Schema.apply('connection', settings);        // Applies validation changes (type cast)\n\n        const connection = new Connection(root, settings);\n        root.connections.push(connection);\n        root.registerPodium(connection);\n        root._single();\n\n        const registrations = Object.keys(root._registrations);\n        for (let i = 0; i < registrations.length; ++i) {\n            const name = registrations[i];\n            connection.registrations[name] = root._registrations[name];\n        }\n\n        connections.push(connection);\n    });\n\n    return this._clone(connections);                            // Use this for active realm\n};\n\n\ninternals.Server.prototype.start = function (callback) {\n\n    if (!callback) {\n        return Promises.wrap(this, this.start);\n    }\n\n    Hoek.assert(typeof callback === 'function', 'Missing required start callback function');\n    const nextTickCallback = Hoek.nextTick(callback);\n\n    if (!this.connections.length) {\n        return nextTickCallback(new Error('No connections to start'));\n    }\n\n    if (this._state === 'initialized' ||\n        this._state === 'started') {\n\n        const error = this._validateDeps();\n        if (error) {\n            return nextTickCallback(error);\n        }\n    }\n\n    if (this._state === 'initialized') {\n        return this._start(callback);\n    }\n\n    if (this._state === 'started') {\n        const each = (connection, next) => connection._start(next);\n        return Items.parallel(this.connections, each, nextTickCallback);\n    }\n\n    if (this._state !== 'stopped') {\n        return nextTickCallback(new Error('Cannot start server while it is in ' + this._state + ' state'));\n    }\n\n    this.initialize((err) => {\n\n        if (err) {\n            return callback(err);\n        }\n\n        this._start(callback);\n    });\n};\n\n\ninternals.Server.prototype.initialize = function (callback) {\n\n    if (!callback) {\n        return Promises.wrap(this, this.initialize);\n    }\n\n    Hoek.assert(typeof callback === 'function', 'Missing required start callback function');\n    const nextTickCallback = Hoek.nextTick(callback);\n\n    if (this._registring) {\n        return nextTickCallback(new Error('Cannot start server before plugins finished registration'));\n    }\n\n    if (this._state === 'initialized') {\n        return nextTickCallback();\n    }\n\n    if (this._state !== 'stopped') {\n        return nextTickCallback(new Error('Cannot initialize server while it is in ' + this._state + ' state'));\n    }\n\n    const error = this._validateDeps();\n    if (error) {\n        return nextTickCallback(error);\n    }\n\n    this._state = 'initializing';\n\n    // Start cache\n\n    const caches = Object.keys(this._caches);\n    const each = (cache, next) => this._caches[cache].client.start(next);\n    Items.parallel(caches, each, (err) => {\n\n        if (err) {\n            this._state = 'invalid';\n            return callback(err);\n        }\n\n        // After hooks\n\n        this._invoke('onPreStart', (err) => {\n\n            if (err) {\n                this._state = 'invalid';\n                return callback(err);\n            }\n\n            // Load measurements\n\n            this._heavy.start();\n\n            // Listen to connections\n\n            this._state = 'initialized';\n            return callback();\n        });\n    });\n};\n\n\ninternals.Server.prototype._validateDeps = function () {\n\n    for (let i = 0; i < this._dependencies.length; ++i) {\n        const dependency = this._dependencies[i];\n        if (dependency.connections) {\n            for (let j = 0; j < dependency.connections.length; ++j) {\n                const connection = dependency.connections[j];\n                for (let k = 0; k < dependency.deps.length; ++k) {\n                    const dep = dependency.deps[k];\n                    if (!connection.registrations[dep]) {\n                        return new Error('Plugin ' + dependency.plugin + ' missing dependency ' + dep + ' in connection: ' + connection.info.uri);\n                    }\n                }\n            }\n        }\n        else {\n            for (let j = 0; j < dependency.deps.length; ++j) {\n                const dep = dependency.deps[j];\n                if (!this._registrations[dep]) {\n                    return new Error('Plugin ' + dependency.plugin + ' missing dependency ' + dep);\n                }\n            }\n        }\n    }\n\n    return null;\n};\n\n\ninternals.Server.prototype._start = function (callback) {\n\n    this._state = 'starting';\n\n    const each = (connection, next) => connection._start(next);\n    Items.parallel(this.connections, each, (err) => {\n\n        if (err) {\n            this._state = 'invalid';\n            return Hoek.nextTick(callback)(err);\n        }\n\n        this._events.emit('start', null, () => {\n\n            this._invoke('onPostStart', (err) => {\n\n                if (err) {\n                    this._state = 'invalid';\n                    return callback(err);\n                }\n\n                this._state = 'started';\n                return callback();\n            });\n        });\n    });\n};\n\n\ninternals.Server.prototype.stop = function (/* [options], callback */) {\n\n    const args = arguments.length;\n    const lastArg = arguments[args - 1];\n    const callback = (!args ? null : (typeof lastArg === 'function' ? lastArg : null));\n    const options = (!args ? {} : (args === 1 ? (callback ? {} : arguments[0]) : arguments[0]));\n\n    if (!callback) {\n        return Promises.wrap(this, this.stop, [options]);\n    }\n\n    options.timeout = options.timeout || 5000;                                              // Default timeout to 5 seconds\n\n    if (['stopped', 'initialized', 'started', 'invalid'].indexOf(this._state) === -1) {\n        return Hoek.nextTick(callback)(new Error('Cannot stop server while in ' + this._state + ' state'));\n    }\n\n    this._state = 'stopping';\n\n    this._invoke('onPreStop', (err) => {\n\n        if (err) {\n            this._state = 'invalid';\n            return callback(err);\n        }\n\n        const each = (connection, next) => connection._stop(options, next);\n        Items.parallel(this.connections, each, (err) => {\n\n            if (err) {\n                this._state = 'invalid';\n                return callback(err);\n            }\n\n            const caches = Object.keys(this._caches);\n            for (let i = 0; i < caches.length; ++i) {\n                this._caches[caches[i]].client.stop();\n            }\n\n            this._events.emit('stop', null, () => {\n\n                this._heavy.stop();\n                this._invoke('onPostStop', (err) => {\n\n                    if (err) {\n                        this._state = 'invalid';\n                        return callback(err);\n                    }\n\n                    this._state = 'stopped';\n                    return callback();\n                });\n            });\n        });\n    });\n};\n\n\ninternals.Server.prototype._invoke = function (type, next) {\n\n    const exts = this._extensions[type];\n    if (!exts.nodes) {\n        return next();\n    }\n\n    Items.serial(exts.nodes, (ext, nextExt) => {\n\n        const bind = (ext.bind || ext.plugin.realm.settings.bind);\n        ext.func.call(bind, ext.plugin._select(), nextExt);\n    }, next);\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/catbox/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Client = require('./client');\nconst Policy = require('./policy');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.Client = Client;\nexports.Policy = exports.policy = Policy;\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/catbox/lib/client.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Boom = require('boom');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.defaults = {\n    partition: 'catbox'\n};\n\n\nmodule.exports = internals.Client = function (engine, options) {\n\n    Hoek.assert(this instanceof internals.Client, 'Cache client must be instantiated using new');\n    Hoek.assert(engine, 'Missing catbox client engine');\n    Hoek.assert(typeof engine === 'object' || typeof engine === 'function', 'engine must be an engine object or engine prototype (function)');\n    Hoek.assert(typeof engine === 'function' || !options, 'Can only specify options with function engine config');\n\n    const settings = Hoek.applyToDefaults(internals.defaults, options || {});\n    Hoek.assert(settings.partition.match(/^[\\w\\-]+$/), 'Invalid partition name:' + settings.partition);\n\n    this.connection = (typeof engine === 'object' ? engine : new engine(settings));\n};\n\n\ninternals.Client.prototype.stop = function () {\n\n    this.connection.stop();\n};\n\n\ninternals.Client.prototype.start = function (callback) {\n\n    this.connection.start(callback);\n};\n\n\ninternals.Client.prototype.isReady = function () {\n\n    return this.connection.isReady();\n};\n\n\ninternals.Client.prototype.validateSegmentName = function (name) {\n\n    return this.connection.validateSegmentName(name);\n};\n\n\ninternals.Client.prototype.get = function (key, callback) {\n\n    if (!this.connection.isReady()) {\n        // Disconnected\n        return callback(Boom.internal('Disconnected'));\n    }\n\n    if (!key) {\n        // Not found on null\n        return callback(null, null);\n    }\n\n    if (!internals.validateKey(key)) {\n        return callback(Boom.internal('Invalid key'));\n    }\n\n    this.connection.get(key, (err, result) => {\n\n        if (err) {\n            // Connection error\n            return callback(err);\n        }\n\n        if (!result ||\n            result.item === undefined ||\n            result.item === null) {\n\n            // Not found\n            return callback(null, null);\n        }\n\n        const now = Date.now();\n        const expires = result.stored + result.ttl;\n        const ttl = expires - now;\n        if (ttl <= 0) {\n            // Expired\n            return callback(null, null);\n        }\n\n        // Valid\n\n        const cached = {\n            item: result.item,\n            stored: result.stored,\n            ttl\n        };\n\n        return callback(null, cached);\n    });\n};\n\n\ninternals.Client.prototype.set = function (key, value, ttl, callback) {\n\n    if (!this.connection.isReady()) {\n        // Disconnected\n        return callback(Boom.internal('Disconnected'));\n    }\n\n    if (!internals.validateKey(key)) {\n        return callback(Boom.internal('Invalid key'));\n    }\n\n    if (ttl <= 0) {\n        // Not cachable (or bad rules)\n        return callback();\n    }\n\n    this.connection.set(key, value, ttl, callback);\n};\n\n\ninternals.Client.prototype.drop = function (key, callback) {\n\n    if (!this.connection.isReady()) {\n        // Disconnected\n        return callback(Boom.internal('Disconnected'));\n    }\n\n    if (!internals.validateKey(key)) {\n        return callback(Boom.internal('Invalid key'));\n    }\n\n    this.connection.drop(key, callback);           // Always drop, regardless of caching rules\n};\n\n\ninternals.validateKey = function (key) {\n\n    return (key && typeof key.id === 'string' && key.segment && typeof key.segment === 'string');\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/hoek/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Crypto = require('crypto');\nconst Path = require('path');\nconst Util = require('util');\nconst Escape = require('./escape');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Clone object or array\n\nexports.clone = function (obj, seen) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    seen = seen || new Map();\n\n    const lookup = seen.get(obj);\n    if (lookup) {\n        return lookup;\n    }\n\n    let newObj;\n    let cloneDeep = false;\n\n    if (!Array.isArray(obj)) {\n        if (Buffer.isBuffer(obj)) {\n            newObj = new Buffer(obj);\n        }\n        else if (obj instanceof Date) {\n            newObj = new Date(obj.getTime());\n        }\n        else if (obj instanceof RegExp) {\n            newObj = new RegExp(obj);\n        }\n        else {\n            const proto = Object.getPrototypeOf(obj);\n            if (proto &&\n                proto.isImmutable) {\n\n                newObj = obj;\n            }\n            else {\n                newObj = Object.create(proto);\n                cloneDeep = true;\n            }\n        }\n    }\n    else {\n        newObj = [];\n        cloneDeep = true;\n    }\n\n    seen.set(obj, newObj);\n\n    if (cloneDeep) {\n        const keys = Object.getOwnPropertyNames(obj);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n            if (descriptor &&\n                (descriptor.get ||\n                 descriptor.set)) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else {\n                newObj[key] = exports.clone(obj[key], seen);\n            }\n        }\n    }\n\n    return newObj;\n};\n\n\n// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n/*eslint-disable */\nexports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {\n/*eslint-enable */\n\n    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n    if (!source) {\n        return target;\n    }\n\n    if (Array.isArray(source)) {\n        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true\n            target.length = 0;                                                          // Must not change target assignment\n        }\n\n        for (let i = 0; i < source.length; ++i) {\n            target.push(exports.clone(source[i]));\n        }\n\n        return target;\n    }\n\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = source[key];\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key] ||\n                typeof target[key] !== 'object' ||\n                (Array.isArray(target[key]) !== Array.isArray(value)) ||\n                value instanceof Date ||\n                Buffer.isBuffer(value) ||\n                value instanceof RegExp) {\n\n                target[key] = exports.clone(value);\n            }\n            else {\n                exports.merge(target[key], value, isNullOverride, isMergeArrays);\n            }\n        }\n        else {\n            if (value !== null &&\n                value !== undefined) {                              // Explicit to preserve empty strings\n\n                target[key] = value;\n            }\n            else if (isNullOverride !== false) {                    // Defaults to true\n                target[key] = value;\n            }\n        }\n    }\n\n    return target;\n};\n\n\n// Apply options to a copy of the defaults\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.clone(defaults);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    return exports.merge(copy, options, isNullOverride === true, false);\n};\n\n\n// Clone an object except for the listed keys which are shallow copied\n\nexports.cloneWithShallow = function (source, keys) {\n\n    if (!source ||\n        typeof source !== 'object') {\n\n        return source;\n    }\n\n    const storage = internals.store(source, keys);    // Move shallow copy items to storage\n    const copy = exports.clone(source);               // Deep copy the rest\n    internals.restore(copy, source, storage);       // Shallow copy the stored items and restore\n    return copy;\n};\n\n\ninternals.store = function (source, keys) {\n\n    const storage = {};\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = exports.reach(source, key);\n        if (value !== undefined) {\n            storage[key] = value;\n            internals.reachSet(source, key, undefined);\n        }\n    }\n\n    return storage;\n};\n\n\ninternals.restore = function (copy, source, storage) {\n\n    const keys = Object.keys(storage);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        internals.reachSet(copy, key, storage[key]);\n        internals.reachSet(source, key, storage[key]);\n    }\n};\n\n\ninternals.reachSet = function (obj, key, value) {\n\n    const path = key.split('.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        const segment = path[i];\n        if (i + 1 === path.length) {\n            ref[segment] = value;\n        }\n\n        ref = ref[segment];\n    }\n};\n\n\n// Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n    exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.cloneWithShallow(defaults, keys);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    const storage = internals.store(options, keys);   // Move shallow copy items to storage\n    exports.merge(copy, options, false, false);     // Deep copy the rest\n    internals.restore(copy, options, storage);      // Shallow copy the stored items and restore\n    return copy;\n};\n\n\n// Deep object or array comparison\n\nexports.deepEqual = function (obj, ref, options, seen) {\n\n    options = options || { prototype: true };\n\n    const type = typeof obj;\n\n    if (type !== typeof ref) {\n        return false;\n    }\n\n    if (type !== 'object' ||\n        obj === null ||\n        ref === null) {\n\n        if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n            return obj !== 0 || 1 / obj === 1 / ref;        // -0 / +0\n        }\n\n        return obj !== obj && ref !== ref;                  // NaN\n    }\n\n    seen = seen || [];\n    if (seen.indexOf(obj) !== -1) {\n        return true;                            // If previous comparison failed, it would have stopped execution\n    }\n\n    seen.push(obj);\n\n    if (Array.isArray(obj)) {\n        if (!Array.isArray(ref)) {\n            return false;\n        }\n\n        if (!options.part && obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (options.part) {\n                let found = false;\n                for (let j = 0; j < ref.length; ++j) {\n                    if (exports.deepEqual(obj[i], ref[j], options)) {\n                        found = true;\n                        break;\n                    }\n                }\n\n                return found;\n            }\n\n            if (!exports.deepEqual(obj[i], ref[i], options)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (Buffer.isBuffer(obj)) {\n        if (!Buffer.isBuffer(ref)) {\n            return false;\n        }\n\n        if (obj.length !== ref.length) {\n            return false;\n        }\n\n        for (let i = 0; i < obj.length; ++i) {\n            if (obj[i] !== ref[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    if (obj instanceof Date) {\n        return (ref instanceof Date && obj.getTime() === ref.getTime());\n    }\n\n    if (obj instanceof RegExp) {\n        return (ref instanceof RegExp && obj.toString() === ref.toString());\n    }\n\n    if (options.prototype) {\n        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n            return false;\n        }\n    }\n\n    const keys = Object.getOwnPropertyNames(obj);\n\n    if (!options.part && keys.length !== Object.getOwnPropertyNames(ref).length) {\n        return false;\n    }\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor.get) {\n            if (!exports.deepEqual(descriptor, Object.getOwnPropertyDescriptor(ref, key), options, seen)) {\n                return false;\n            }\n        }\n        else if (!exports.deepEqual(obj[key], ref[key], options, seen)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\n// Remove duplicate items from array\n\nexports.unique = (array, key) => {\n\n    let result;\n    if (key) {\n        result = [];\n        const index = new Set();\n        array.forEach((item) => {\n\n            const identifier = item[key];\n            if (!index.has(identifier)) {\n                index.add(identifier);\n                result.push(item);\n            }\n        });\n    }\n    else {\n        result = Array.from(new Set(array));\n    }\n\n    return result;\n};\n\n\n// Convert array into object\n\nexports.mapToObject = function (array, key) {\n\n    if (!array) {\n        return null;\n    }\n\n    const obj = {};\n    for (let i = 0; i < array.length; ++i) {\n        if (key) {\n            if (array[i][key]) {\n                obj[array[i][key]] = true;\n            }\n        }\n        else {\n            obj[array[i]] = true;\n        }\n    }\n\n    return obj;\n};\n\n\n// Find the common unique items in two arrays\n\nexports.intersect = function (array1, array2, justFirst) {\n\n    if (!array1 || !array2) {\n        return [];\n    }\n\n    const common = [];\n    const hash = (Array.isArray(array1) ? exports.mapToObject(array1) : array1);\n    const found = {};\n    for (let i = 0; i < array2.length; ++i) {\n        if (hash[array2[i]] && !found[array2[i]]) {\n            if (justFirst) {\n                return array2[i];\n            }\n\n            common.push(array2[i]);\n            found[array2[i]] = true;\n        }\n    }\n\n    return (justFirst ? null : common);\n};\n\n\n// Test if the reference contains the values\n\nexports.contain = function (ref, values, options) {\n\n    /*\n        string -> string(s)\n        array -> item(s)\n        object -> key(s)\n        object -> object (key:value)\n    */\n\n    let valuePairs = null;\n    if (typeof ref === 'object' &&\n        typeof values === 'object' &&\n        !Array.isArray(ref) &&\n        !Array.isArray(values)) {\n\n        valuePairs = values;\n        values = Object.keys(values);\n    }\n    else {\n        values = [].concat(values);\n    }\n\n    options = options || {};            // deep, once, only, part\n\n    exports.assert(arguments.length >= 2, 'Insufficient arguments');\n    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n    exports.assert(values.length, 'Values array cannot be empty');\n\n    let compare;\n    let compareFlags;\n    if (options.deep) {\n        compare = exports.deepEqual;\n\n        const hasOnly = options.hasOwnProperty('only');\n        const hasPart = options.hasOwnProperty('part');\n\n        compareFlags = {\n            prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n            part: hasOnly ? !options.only : hasPart ? options.part : true\n        };\n    }\n    else {\n        compare = (a, b) => a === b;\n    }\n\n    let misses = false;\n    const matches = new Array(values.length);\n    for (let i = 0; i < matches.length; ++i) {\n        matches[i] = 0;\n    }\n\n    if (typeof ref === 'string') {\n        let pattern = '(';\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n            pattern += (i ? '|' : '') + exports.escapeRegex(value);\n        }\n\n        const regex = new RegExp(pattern + ')', 'g');\n        const leftovers = ref.replace(regex, ($0, $1) => {\n\n            const index = values.indexOf($1);\n            ++matches[index];\n            return '';          // Remove from string\n        });\n\n        misses = !!leftovers;\n    }\n    else if (Array.isArray(ref)) {\n        for (let i = 0; i < ref.length; ++i) {\n            let matched = false;\n            for (let j = 0; j < values.length && matched === false; ++j) {\n                matched = compare(values[j], ref[i], compareFlags) && j;\n            }\n\n            if (matched !== false) {\n                ++matches[matched];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n    else {\n        const keys = Object.getOwnPropertyNames(ref);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const pos = values.indexOf(key);\n            if (pos !== -1) {\n                if (valuePairs &&\n                    !compare(valuePairs[key], ref[key], compareFlags)) {\n\n                    return false;\n                }\n\n                ++matches[pos];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n\n    let result = false;\n    for (let i = 0; i < matches.length; ++i) {\n        result = result || !!matches[i];\n        if ((options.once && matches[i] > 1) ||\n            (!options.part && !matches[i])) {\n\n            return false;\n        }\n    }\n\n    if (options.only &&\n        misses) {\n\n        return false;\n    }\n\n    return result;\n};\n\n\n// Flatten array\n\nexports.flatten = function (array, target) {\n\n    const result = target || [];\n\n    for (let i = 0; i < array.length; ++i) {\n        if (Array.isArray(array[i])) {\n            exports.flatten(array[i], result);\n        }\n        else {\n            result.push(array[i]);\n        }\n    }\n\n    return result;\n};\n\n\n// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\nexports.reach = function (obj, chain, options) {\n\n    if (chain === false ||\n        chain === null ||\n        typeof chain === 'undefined') {\n\n        return obj;\n    }\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { separator: options };\n    }\n\n    const path = chain.split(options.separator || '.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        let key = path[i];\n        if (key[0] === '-' && Array.isArray(ref)) {\n            key = key.slice(1, key.length);\n            key = ref.length - key;\n        }\n\n        if (!ref ||\n            !((typeof ref === 'object' || typeof ref === 'function') && key in ref) ||\n            (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties\n\n            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n            ref = options.default;\n            break;\n        }\n\n        ref = ref[key];\n    }\n\n    return ref;\n};\n\n\nexports.reachTemplate = function (obj, template, options) {\n\n    return template.replace(/{([^}]+)}/g, ($0, chain) => {\n\n        const value = exports.reach(obj, chain, options);\n        return (value === undefined || value === null ? '' : value);\n    });\n};\n\n\nexports.formatStack = function (stack) {\n\n    const trace = [];\n    for (let i = 0; i < stack.length; ++i) {\n        const item = stack[i];\n        trace.push([item.getFileName(), item.getLineNumber(), item.getColumnNumber(), item.getFunctionName(), item.isConstructor()]);\n    }\n\n    return trace;\n};\n\n\nexports.formatTrace = function (trace) {\n\n    const display = [];\n\n    for (let i = 0; i < trace.length; ++i) {\n        const row = trace[i];\n        display.push((row[4] ? 'new ' : '') + row[3] + ' (' + row[0] + ':' + row[1] + ':' + row[2] + ')');\n    }\n\n    return display;\n};\n\n\nexports.callStack = function (slice) {\n\n    // http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n\n    const v8 = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) {\n\n        return stack;\n    };\n\n    const capture = {};\n    Error.captureStackTrace(capture, this);     // arguments.callee is not supported in strict mode so we use this and slice the trace of this off the result\n    const stack = capture.stack;\n\n    Error.prepareStackTrace = v8;\n\n    const trace = exports.formatStack(stack);\n\n    return trace.slice(1 + slice);\n};\n\n\nexports.displayStack = function (slice) {\n\n    const trace = exports.callStack(slice === undefined ? 1 : slice + 1);\n\n    return exports.formatTrace(trace);\n};\n\n\nexports.abortThrow = false;\n\n\nexports.abort = function (message, hideStack) {\n\n    if (process.env.NODE_ENV === 'test' || exports.abortThrow === true) {\n        throw new Error(message || 'Unknown error');\n    }\n\n    let stack = '';\n    if (!hideStack) {\n        stack = exports.displayStack(1).join('\\n\\t');\n    }\n    console.log('ABORT: ' + message + '\\n\\t' + stack);\n    process.exit(1);\n};\n\n\nexports.assert = function (condition /*, msg1, msg2, msg3 */) {\n\n    if (condition) {\n        return;\n    }\n\n    if (arguments.length === 2 && arguments[1] instanceof Error) {\n        throw arguments[1];\n    }\n\n    let msgs = [];\n    for (let i = 1; i < arguments.length; ++i) {\n        if (arguments[i] !== '') {\n            msgs.push(arguments[i]);            // Avoids Array.slice arguments leak, allowing for V8 optimizations\n        }\n    }\n\n    msgs = msgs.map((msg) => {\n\n        return typeof msg === 'string' ? msg : msg instanceof Error ? msg.message : exports.stringify(msg);\n    });\n\n    throw new Error(msgs.join(' ') || 'Unknown error');\n};\n\n\nexports.Timer = function () {\n\n    this.ts = 0;\n    this.reset();\n};\n\n\nexports.Timer.prototype.reset = function () {\n\n    this.ts = Date.now();\n};\n\n\nexports.Timer.prototype.elapsed = function () {\n\n    return Date.now() - this.ts;\n};\n\n\nexports.Bench = function () {\n\n    this.ts = 0;\n    this.reset();\n};\n\n\nexports.Bench.prototype.reset = function () {\n\n    this.ts = exports.Bench.now();\n};\n\n\nexports.Bench.prototype.elapsed = function () {\n\n    return exports.Bench.now() - this.ts;\n};\n\n\nexports.Bench.now = function () {\n\n    const ts = process.hrtime();\n    return (ts[0] * 1e3) + (ts[1] / 1e6);\n};\n\n\n// Escape string for Regex construction\n\nexports.escapeRegex = function (string) {\n\n    // Escape ^$.*+-?=!:|\\/()[]{},\n    return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n};\n\n\n// Base64url (RFC 4648) encode\n\nexports.base64urlEncode = function (value, encoding) {\n\n    exports.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');\n    const buf = (Buffer.isBuffer(value) ? value : new Buffer(value, encoding || 'binary'));\n    return buf.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n};\n\n\n// Base64url (RFC 4648) decode\n\nexports.base64urlDecode = function (value, encoding) {\n\n    if (typeof value !== 'string') {\n\n        return new Error('Value not a string');\n    }\n\n    if (!/^[\\w\\-]*$/.test(value)) {\n\n        return new Error('Invalid character');\n    }\n\n    const buf = new Buffer(value, 'base64');\n    return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));\n};\n\n\n// Escape attribute value for use in HTTP header\n\nexports.escapeHeaderAttribute = function (attribute) {\n\n    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n\n    exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n\n    return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"');                             // Escape quotes and slash\n};\n\n\nexports.escapeHtml = function (string) {\n\n    return Escape.escapeHtml(string);\n};\n\n\nexports.escapeJavaScript = function (string) {\n\n    return Escape.escapeJavaScript(string);\n};\n\n\nexports.nextTick = function (callback) {\n\n    return function () {\n\n        const args = arguments;\n        process.nextTick(() => {\n\n            callback.apply(null, args);\n        });\n    };\n};\n\n\nexports.once = function (method) {\n\n    if (method._hoekOnce) {\n        return method;\n    }\n\n    let once = false;\n    const wrapped = function () {\n\n        if (!once) {\n            once = true;\n            method.apply(null, arguments);\n        }\n    };\n\n    wrapped._hoekOnce = true;\n\n    return wrapped;\n};\n\n\nexports.isInteger = function (value) {\n\n    return (typeof value === 'number' &&\n            parseFloat(value) === parseInt(value, 10) &&\n            !isNaN(value));\n};\n\n\nexports.ignore = function () { };\n\n\nexports.inherits = Util.inherits;\n\n\nexports.format = Util.format;\n\n\nexports.transform = function (source, transform, options) {\n\n    exports.assert(source === null || source === undefined || typeof source === 'object' || Array.isArray(source), 'Invalid source object: must be null, undefined, an object, or an array');\n    const separator = (typeof options === 'object' && options !== null) ? (options.separator || '.') : '.';\n\n    if (Array.isArray(source)) {\n        const results = [];\n        for (let i = 0; i < source.length; ++i) {\n            results.push(exports.transform(source[i], transform, options));\n        }\n        return results;\n    }\n\n    const result = {};\n    const keys = Object.keys(transform);\n\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const path = key.split(separator);\n        const sourcePath = transform[key];\n\n        exports.assert(typeof sourcePath === 'string', 'All mappings must be \".\" delineated strings');\n\n        let segment;\n        let res = result;\n\n        while (path.length > 1) {\n            segment = path.shift();\n            if (!res[segment]) {\n                res[segment] = {};\n            }\n            res = res[segment];\n        }\n        segment = path.shift();\n        res[segment] = exports.reach(source, sourcePath, options);\n    }\n\n    return result;\n};\n\n\nexports.uniqueFilename = function (path, extension) {\n\n    if (extension) {\n        extension = extension[0] !== '.' ? '.' + extension : extension;\n    }\n    else {\n        extension = '';\n    }\n\n    path = Path.resolve(path);\n    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n    return Path.join(path, name);\n};\n\n\nexports.stringify = function () {\n\n    try {\n        return JSON.stringify.apply(null, arguments);\n    }\n    catch (err) {\n        return '[Cannot display object: ' + err.message + ']';\n    }\n};\n\n\nexports.shallow = function (source) {\n\n    const target = {};\n    const keys = Object.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        target[key] = source[key];\n    }\n\n    return target;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/hoek/lib/escape.js":"'use strict';\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.escapeJavaScript = function (input) {\n\n    if (!input) {\n        return '';\n    }\n\n    let escaped = '';\n\n    for (let i = 0; i < input.length; ++i) {\n\n        const charCode = input.charCodeAt(i);\n\n        if (internals.isSafe(charCode)) {\n            escaped += input[i];\n        }\n        else {\n            escaped += internals.escapeJavaScriptChar(charCode);\n        }\n    }\n\n    return escaped;\n};\n\n\nexports.escapeHtml = function (input) {\n\n    if (!input) {\n        return '';\n    }\n\n    let escaped = '';\n\n    for (let i = 0; i < input.length; ++i) {\n\n        const charCode = input.charCodeAt(i);\n\n        if (internals.isSafe(charCode)) {\n            escaped += input[i];\n        }\n        else {\n            escaped += internals.escapeHtmlChar(charCode);\n        }\n    }\n\n    return escaped;\n};\n\n\ninternals.escapeJavaScriptChar = function (charCode) {\n\n    if (charCode >= 256) {\n        return '\\\\u' + internals.padLeft('' + charCode, 4);\n    }\n\n    const hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');\n    return '\\\\x' + internals.padLeft(hexValue, 2);\n};\n\n\ninternals.escapeHtmlChar = function (charCode) {\n\n    const namedEscape = internals.namedHtml[charCode];\n    if (typeof namedEscape !== 'undefined') {\n        return namedEscape;\n    }\n\n    if (charCode >= 256) {\n        return '&#' + charCode + ';';\n    }\n\n    const hexValue = new Buffer(String.fromCharCode(charCode), 'ascii').toString('hex');\n    return '&#x' + internals.padLeft(hexValue, 2) + ';';\n};\n\n\ninternals.padLeft = function (str, len) {\n\n    while (str.length < len) {\n        str = '0' + str;\n    }\n\n    return str;\n};\n\n\ninternals.isSafe = function (charCode) {\n\n    return (typeof internals.safeCharCodes[charCode] !== 'undefined');\n};\n\n\ninternals.namedHtml = {\n    '38': '&amp;',\n    '60': '&lt;',\n    '62': '&gt;',\n    '34': '&quot;',\n    '160': '&nbsp;',\n    '162': '&cent;',\n    '163': '&pound;',\n    '164': '&curren;',\n    '169': '&copy;',\n    '174': '&reg;'\n};\n\n\ninternals.safeCharCodes = (function () {\n\n    const safe = {};\n\n    for (let i = 32; i < 123; ++i) {\n\n        if ((i >= 97) ||                    // a-z\n            (i >= 65 && i <= 90) ||         // A-Z\n            (i >= 48 && i <= 57) ||         // 0-9\n            i === 32 ||                     // space\n            i === 46 ||                     // .\n            i === 44 ||                     // ,\n            i === 45 ||                     // -\n            i === 58 ||                     // :\n            i === 95) {                     // _\n\n            safe[i] = null;\n        }\n    }\n\n    return safe;\n}());\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/boom/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {\n    STATUS_CODES: Object.setPrototypeOf({\n        '100': 'Continue',\n        '101': 'Switching Protocols',\n        '102': 'Processing',\n        '200': 'OK',\n        '201': 'Created',\n        '202': 'Accepted',\n        '203': 'Non-Authoritative Information',\n        '204': 'No Content',\n        '205': 'Reset Content',\n        '206': 'Partial Content',\n        '207': 'Multi-Status',\n        '300': 'Multiple Choices',\n        '301': 'Moved Permanently',\n        '302': 'Moved Temporarily',\n        '303': 'See Other',\n        '304': 'Not Modified',\n        '305': 'Use Proxy',\n        '307': 'Temporary Redirect',\n        '400': 'Bad Request',\n        '401': 'Unauthorized',\n        '402': 'Payment Required',\n        '403': 'Forbidden',\n        '404': 'Not Found',\n        '405': 'Method Not Allowed',\n        '406': 'Not Acceptable',\n        '407': 'Proxy Authentication Required',\n        '408': 'Request Time-out',\n        '409': 'Conflict',\n        '410': 'Gone',\n        '411': 'Length Required',\n        '412': 'Precondition Failed',\n        '413': 'Request Entity Too Large',\n        '414': 'Request-URI Too Large',\n        '415': 'Unsupported Media Type',\n        '416': 'Requested Range Not Satisfiable',\n        '417': 'Expectation Failed',\n        '418': 'I\\'m a teapot',\n        '422': 'Unprocessable Entity',\n        '423': 'Locked',\n        '424': 'Failed Dependency',\n        '425': 'Unordered Collection',\n        '426': 'Upgrade Required',\n        '428': 'Precondition Required',\n        '429': 'Too Many Requests',\n        '431': 'Request Header Fields Too Large',\n        '451': 'Unavailable For Legal Reasons',\n        '500': 'Internal Server Error',\n        '501': 'Not Implemented',\n        '502': 'Bad Gateway',\n        '503': 'Service Unavailable',\n        '504': 'Gateway Time-out',\n        '505': 'HTTP Version Not Supported',\n        '506': 'Variant Also Negotiates',\n        '507': 'Insufficient Storage',\n        '509': 'Bandwidth Limit Exceeded',\n        '510': 'Not Extended',\n        '511': 'Network Authentication Required'\n    }, null)\n};\n\n\nexports.wrap = function (error, statusCode, message) {\n\n    Hoek.assert(error instanceof Error, 'Cannot wrap non-Error object');\n    return (error.isBoom ? error : internals.initialize(error, statusCode || 500, message));\n};\n\n\nexports.create = function (statusCode, message, data) {\n\n    return internals.create(statusCode, message, data, exports.create);\n};\n\n\ninternals.create = function (statusCode, message, data, ctor) {\n\n    const error = new Error(message ? message : undefined);       // Avoids settings null message\n    Error.captureStackTrace(error, ctor);                       // Filter the stack to our external API\n    error.data = data || null;\n    internals.initialize(error, statusCode);\n    return error;\n};\n\n\ninternals.initialize = function (error, statusCode, message) {\n\n    const numberCode = parseInt(statusCode, 10);\n    Hoek.assert(!isNaN(numberCode) && numberCode >= 400, 'First argument must be a number (400+):', statusCode);\n\n    error.isBoom = true;\n    error.isServer = numberCode >= 500;\n\n    if (!error.hasOwnProperty('data')) {\n        error.data = null;\n    }\n\n    error.output = {\n        statusCode: numberCode,\n        payload: {},\n        headers: {}\n    };\n\n    error.reformat = internals.reformat;\n    error.reformat();\n\n    if (!message &&\n        !error.message) {\n\n        message = error.output.payload.error;\n    }\n\n    if (message) {\n        error.message = (message + (error.message ? ': ' + error.message : ''));\n    }\n\n    return error;\n};\n\n\ninternals.reformat = function () {\n\n    this.output.payload.statusCode = this.output.statusCode;\n    this.output.payload.error = internals.STATUS_CODES[this.output.statusCode] || 'Unknown';\n\n    if (this.output.statusCode === 500) {\n        this.output.payload.message = 'An internal server error occurred';              // Hide actual error from user\n    }\n    else if (this.message) {\n        this.output.payload.message = this.message;\n    }\n};\n\n\n// 4xx Client Errors\n\nexports.badRequest = function (message, data) {\n\n    return internals.create(400, message, data, exports.badRequest);\n};\n\n\nexports.unauthorized = function (message, scheme, attributes) {          // Or function (message, wwwAuthenticate[])\n\n    const err = internals.create(401, message, undefined, exports.unauthorized);\n\n    if (!scheme) {\n        return err;\n    }\n\n    let wwwAuthenticate = '';\n\n    if (typeof scheme === 'string') {\n\n        // function (message, scheme, attributes)\n\n        wwwAuthenticate = scheme;\n\n        if (attributes || message) {\n            err.output.payload.attributes = {};\n        }\n\n        if (attributes) {\n            const names = Object.keys(attributes);\n            for (let i = 0; i < names.length; ++i) {\n                const name = names[i];\n                if (i) {\n                    wwwAuthenticate = wwwAuthenticate + ',';\n                }\n\n                let value = attributes[name];\n                if (value === null ||\n                    value === undefined) {              // Value can be zero\n\n                    value = '';\n                }\n                wwwAuthenticate = wwwAuthenticate + ' ' + name + '=\"' + Hoek.escapeHeaderAttribute(value.toString()) + '\"';\n                err.output.payload.attributes[name] = value;\n            }\n        }\n\n        if (message) {\n            if (attributes) {\n                wwwAuthenticate = wwwAuthenticate + ',';\n            }\n            wwwAuthenticate = wwwAuthenticate + ' error=\"' + Hoek.escapeHeaderAttribute(message) + '\"';\n            err.output.payload.attributes.error = message;\n        }\n        else {\n            err.isMissing = true;\n        }\n    }\n    else {\n\n        // function (message, wwwAuthenticate[])\n\n        const wwwArray = scheme;\n        for (let i = 0; i < wwwArray.length; ++i) {\n            if (i) {\n                wwwAuthenticate = wwwAuthenticate + ', ';\n            }\n\n            wwwAuthenticate = wwwAuthenticate + wwwArray[i];\n        }\n    }\n\n    err.output.headers['WWW-Authenticate'] = wwwAuthenticate;\n\n    return err;\n};\n\n\nexports.paymentRequired = function (message, data) {\n\n    return internals.create(402, message, data, exports.paymentRequired);\n};\n\n\nexports.forbidden = function (message, data) {\n\n    return internals.create(403, message, data, exports.forbidden);\n};\n\n\nexports.notFound = function (message, data) {\n\n    return internals.create(404, message, data, exports.notFound);\n};\n\n\nexports.methodNotAllowed = function (message, data, allow) {\n\n    const err = internals.create(405, message, data, exports.methodNotAllowed);\n\n    if (typeof allow === 'string') {\n        allow = [allow];\n    }\n\n    if (Array.isArray(allow)) {\n        err.output.headers.Allow = allow.join(', ');\n    }\n\n    return err;\n};\n\n\nexports.notAcceptable = function (message, data) {\n\n    return internals.create(406, message, data, exports.notAcceptable);\n};\n\n\nexports.proxyAuthRequired = function (message, data) {\n\n    return internals.create(407, message, data, exports.proxyAuthRequired);\n};\n\n\nexports.clientTimeout = function (message, data) {\n\n    return internals.create(408, message, data, exports.clientTimeout);\n};\n\n\nexports.conflict = function (message, data) {\n\n    return internals.create(409, message, data, exports.conflict);\n};\n\n\nexports.resourceGone = function (message, data) {\n\n    return internals.create(410, message, data, exports.resourceGone);\n};\n\n\nexports.lengthRequired = function (message, data) {\n\n    return internals.create(411, message, data, exports.lengthRequired);\n};\n\n\nexports.preconditionFailed = function (message, data) {\n\n    return internals.create(412, message, data, exports.preconditionFailed);\n};\n\n\nexports.entityTooLarge = function (message, data) {\n\n    return internals.create(413, message, data, exports.entityTooLarge);\n};\n\n\nexports.uriTooLong = function (message, data) {\n\n    return internals.create(414, message, data, exports.uriTooLong);\n};\n\n\nexports.unsupportedMediaType = function (message, data) {\n\n    return internals.create(415, message, data, exports.unsupportedMediaType);\n};\n\n\nexports.rangeNotSatisfiable = function (message, data) {\n\n    return internals.create(416, message, data, exports.rangeNotSatisfiable);\n};\n\n\nexports.expectationFailed = function (message, data) {\n\n    return internals.create(417, message, data, exports.expectationFailed);\n};\n\n\nexports.badData = function (message, data) {\n\n    return internals.create(422, message, data, exports.badData);\n};\n\n\nexports.locked = function (message, data) {\n\n    return internals.create(423, message, data, exports.locked);\n};\n\n\nexports.preconditionRequired = function (message, data) {\n\n    return internals.create(428, message, data, exports.preconditionRequired);\n};\n\n\nexports.tooManyRequests = function (message, data) {\n\n    return internals.create(429, message, data, exports.tooManyRequests);\n};\n\n\nexports.illegal = function (message, data) {\n\n    return internals.create(451, message, data, exports.illegal);\n};\n\n\n// 5xx Server Errors\n\nexports.internal = function (message, data, statusCode) {\n\n    return internals.serverError(message, data, statusCode, exports.internal);\n};\n\n\ninternals.serverError = function (message, data, statusCode, ctor) {\n\n    let error;\n    if (data instanceof Error) {\n        error = exports.wrap(data, statusCode, message);\n    }\n    else {\n        error = internals.create(statusCode || 500, message, undefined, ctor);\n        error.data = data;\n    }\n\n    return error;\n};\n\n\nexports.notImplemented = function (message, data) {\n\n    return internals.serverError(message, data, 501, exports.notImplemented);\n};\n\n\nexports.badGateway = function (message, data) {\n\n    return internals.serverError(message, data, 502, exports.badGateway);\n};\n\n\nexports.serverUnavailable = function (message, data) {\n\n    return internals.serverError(message, data, 503, exports.serverUnavailable);\n};\n\n\nexports.gatewayTimeout = function (message, data) {\n\n    return internals.serverError(message, data, 504, exports.gatewayTimeout);\n};\n\n\nexports.badImplementation = function (message, data) {\n\n    const err = internals.serverError(message, data, 500, exports.badImplementation);\n    err.isDeveloperError = true;\n    return err;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/catbox/lib/policy.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Joi = require('joi');\n\n\n// Declare internals\n\nconst internals = {\n    day: 24 * 60 * 60 * 1000\n};\n\n\nexports = module.exports = internals.Policy = function (options, cache, segment) {\n\n    Hoek.assert(this instanceof internals.Policy, 'Cache Policy must be instantiated using new');\n\n    this._cache = cache;\n    this._pendings = {};                                        // id -> [callbacks]\n    this._pendingGenerateCall = {};                             // id -> boolean\n    this.rules(options);\n\n    this.stats = {\n        sets: 0,\n        gets: 0,\n        hits: 0,\n        stales: 0,\n        generates: 0,\n        errors: 0\n    };\n\n    if (cache) {\n        const nameErr = cache.validateSegmentName(segment);\n        Hoek.assert(nameErr === null, 'Invalid segment name: ' + segment + (nameErr ? ' (' + nameErr.message + ')' : ''));\n\n        this._segment = segment;\n    }\n};\n\n\ninternals.Policy.prototype.rules = function (options) {\n\n    this.rule = internals.Policy.compile(options, !!this._cache);\n};\n\n\ninternals.Policy.prototype.get = function (key, callback) {     // key: string or { id: 'id' }\n\n    ++this.stats.gets;\n\n    // Check if request is already pending\n\n    const id = (key && typeof key === 'object') ? key.id : key;\n    const pendingsId = '+' + id;                                  // Prefix to avoid conflicts with JS internals (e.g. __proto__)\n    if (this._pendings[pendingsId]) {\n        this._pendings[pendingsId].push(process.domain ? process.domain.bind(callback) : callback);     // Explicitly bind callback to its process.domain (_finalize might get called from a different active process.domain)\n        return;\n    }\n\n    this._pendings[pendingsId] = [callback];\n\n    // Lookup in cache\n\n    const timer = new Hoek.Timer();\n    this._get(id, (err, cached) => {\n\n        if (err) {\n            ++this.stats.errors;\n        }\n\n        // Prepare report\n\n        const report = {\n            msec: timer.elapsed(),\n            error: err\n        };\n\n        if (cached) {\n            report.stored = cached.stored;\n            report.ttl = cached.ttl;\n            const staleIn = typeof this.rule.staleIn === 'function' ? this.rule.staleIn(cached.stored, cached.ttl) : this.rule.staleIn;\n            cached.isStale = (staleIn ? (Date.now() - cached.stored) >= staleIn : false);\n            report.isStale = cached.isStale;\n\n            if (cached.isStale) {\n                ++this.stats.stales;\n            }\n        }\n\n        // No generate method\n\n        if (!this.rule.generateFunc ||\n            (err && !this.rule.generateOnReadError)) {\n\n            return internals.respond(this, id, err, cached ? cached.item : null, cached, report);\n        }\n\n        // Check if found and fresh\n\n        if (cached &&\n            !cached.isStale) {\n\n            return internals.respond(this, id, null, cached.item, cached, report);\n        }\n\n        return this._generate(id, key, cached, report);\n    });\n};\n\n\ninternals.Policy.prototype._generate = function (id, key, cached, report) {\n\n    const respond = Hoek.once(internals.respond);\n\n    if (cached) {                                       // Must be stale\n\n        // Set stale timeout\n\n        cached.ttl = cached.ttl - this.rule.staleTimeout;       // Adjust TTL for when the timeout is invoked (staleTimeout must be valid if isStale is true)\n        if (cached.ttl > 0) {\n            setTimeout(() => {\n\n                return respond(this, id, null, cached.item, cached, report);\n            }, this.rule.staleTimeout);\n        }\n    }\n    else if (this.rule.generateTimeout) {\n\n        // Set item generation timeout (when not in cache)\n\n        setTimeout(() => {\n\n            return respond(this, id, Boom.serverUnavailable(), null, null, report);\n        }, this.rule.generateTimeout);\n    }\n\n    // Generate new value\n\n    const pendingId = ('+' + id);\n    if (!this._pendingGenerateCall[pendingId]) {                // Check if a generate call is already in progress\n        ++this.stats.generates;                                 // Record generation before call in case it times out\n\n        if (this.rule.pendingGenerateTimeout) {\n            this._pendingGenerateCall[pendingId] = true;\n            setTimeout(() => {\n\n                delete this._pendingGenerateCall[pendingId];\n            }, this.rule.pendingGenerateTimeout);\n        }\n\n        try {\n            this._callGenerateFunc(id, key, cached, report, respond);\n        }\n        catch (err) {\n            delete this._pendingGenerateCall[pendingId];\n            return respond(this, id, err, null, null, report);\n        }\n    }\n};\n\n\ninternals.Policy.prototype._callGenerateFunc = function (id, key, cached, report, respond) {\n\n    this.rule.generateFunc.call(null, key, (generateError, value, ttl) => {\n\n        delete this._pendingGenerateCall['+' + id];\n\n        const finalize = (err) => {\n\n            const error = generateError || (this.rule.generateIgnoreWriteError ? null : err);\n            if (cached &&\n                error &&\n                !this.rule.dropOnError) {\n\n                return respond(this, id, error, cached.item, cached, report);\n            }\n\n            return respond(this, id, error, value, null, report);       // Ignored if stale value already returned\n        };\n\n        // Error (if dropOnError is not set to false) or not cached\n\n        if ((generateError && this.rule.dropOnError) || ttl === 0) {                                    // null or undefined means use policy\n            return this.drop(id, finalize);                 // Invalidate cache\n        }\n\n        if (!generateError) {\n            return this.set(id, value, ttl, finalize);      // Lazy save (replaces stale cache copy with late-coming fresh copy)\n        }\n\n        return finalize();\n    });\n};\n\n\ninternals.Policy.prototype._get = function (id, callback) {\n\n    if (!this._cache) {\n        return Hoek.nextTick(callback)(null, null);\n    }\n\n    this._cache.get({ segment: this._segment, id }, callback);\n};\n\n\ninternals.respond = function (policy, id, err, value, cached, report) {\n\n    id = '+' + id;\n    const pendings = policy._pendings[id];\n    delete policy._pendings[id];\n\n    const length = pendings.length;\n    for (let i = 0; i < length; ++i) {\n        Hoek.nextTick(pendings[i])(err, value, cached, report);\n    }\n\n    if (report.isStale !== undefined) {\n        policy.stats.hits = policy.stats.hits + length;\n    }\n};\n\n\ninternals.Policy.prototype.set = function (key, value, ttl, callback) {\n\n    callback = callback || Hoek.ignore;\n\n    ++this.stats.sets;\n\n    if (!this._cache) {\n        return callback(null);\n    }\n\n    ttl = ttl || internals.Policy.ttl(this.rule);\n    const id = (key && typeof key === 'object') ? key.id : key;\n    this._cache.set({ segment: this._segment, id }, value, ttl, (err) => {\n\n        if (err) {\n            ++this.stats.errors;\n        }\n\n        return callback(err);\n    });\n};\n\n\ninternals.Policy.prototype.drop = function (key, callback) {\n\n    callback = callback || Hoek.ignore;\n\n    if (!this._cache) {\n        return callback(null);\n    }\n\n    const id = (key && typeof key === 'object') ? key.id : key;\n    if (!id) {\n        return callback(new Error('Invalid key'));\n    }\n\n    this._cache.drop({ segment: this._segment, id }, (err) => {\n\n        if (err) {\n            ++this.stats.errors;\n        }\n\n        return callback(err);\n    });\n};\n\n\ninternals.Policy.prototype.ttl = function (created) {\n\n    return internals.Policy.ttl(this.rule, created);\n};\n\n\ninternals.schema = Joi.object({\n    expiresIn: Joi.number().integer().min(1),\n    expiresAt: Joi.string().regex(/^\\d\\d?\\:\\d\\d$/),\n    staleIn: [Joi.number().integer().min(1).max(86400000 - 1), Joi.func()],               // One day - 1 (max is inclusive)\n    staleTimeout: Joi.number().integer().min(1),\n    generateFunc: Joi.func(),\n    generateTimeout: Joi.number().integer().min(1).allow(false),\n    generateOnReadError: Joi.boolean(),\n    generateIgnoreWriteError: Joi.boolean(),\n    dropOnError: Joi.boolean(),\n    pendingGenerateTimeout: Joi.number().integer().min(1),\n\n    // Ignored external keys (hapi)\n\n    privacy: Joi.any(),\n    cache: Joi.any(),\n    segment: Joi.any(),\n    shared: Joi.any()\n})\n    .without('expiresIn', 'expiresAt')\n    .with('staleIn', 'generateFunc')\n    .with('generateOnReadError', 'generateFunc')\n    .with('generateIgnoreWriteError', 'generateFunc')\n    .with('dropOnError', 'generateFunc')\n    .and('generateFunc', 'generateTimeout')\n    .and('staleIn', 'staleTimeout');\n\n\ninternals.Policy.compile = function (options, serverSide) {\n\n    /*\n        {\n            expiresIn: 30000,\n            expiresAt: '13:00',\n\n            generateFunc: function (id, next) { next(err, result, ttl); }\n            generateTimeout: 500,\n            generateOnReadError: true,\n            generateIgnoreWriteError: true,\n            staleIn: 20000,\n            staleTimeout: 500,\n            dropOnError: true\n        }\n     */\n\n    const rule = {};\n\n    if (!options ||\n        !Object.keys(options).length) {\n\n        return rule;\n    }\n\n    // Validate rule\n\n    Joi.assert(options, internals.schema, 'Invalid cache policy configuration');\n\n    const hasExpiresIn = options.expiresIn !== undefined && options.expiresIn !== null;\n    const hasExpiresAt = options.expiresAt !== undefined && options.expiresAt !== null;\n\n    Hoek.assert(!hasExpiresAt || typeof options.expiresAt === 'string', 'expiresAt must be a string', options);\n    Hoek.assert(!hasExpiresIn || Hoek.isInteger(options.expiresIn), 'expiresIn must be an integer', options);\n    Hoek.assert(!hasExpiresIn || !options.staleIn || typeof options.staleIn === 'function' || options.staleIn < options.expiresIn, 'staleIn must be less than expiresIn');\n    Hoek.assert(!options.staleIn || serverSide, 'Cannot use stale options without server-side caching');\n    Hoek.assert(!options.staleTimeout || !hasExpiresIn || options.staleTimeout < options.expiresIn, 'staleTimeout must be less than expiresIn');\n    Hoek.assert(!options.staleTimeout || !hasExpiresIn || typeof options.staleIn === 'function' || options.staleTimeout < (options.expiresIn - options.staleIn), 'staleTimeout must be less than the delta between expiresIn and staleIn');\n    Hoek.assert(!options.staleTimeout || !options.pendingGenerateTimeout || options.staleTimeout < options.pendingGenerateTimeout, 'pendingGenerateTimeout must be greater than staleTimeout if specified');\n\n    // Expiration\n\n    if (hasExpiresAt) {\n\n        // expiresAt\n\n        const time = /^(\\d\\d?):(\\d\\d)$/.exec(options.expiresAt);\n        rule.expiresAt = {\n            hours: parseInt(time[1], 10),\n            minutes: parseInt(time[2], 10)\n        };\n    }\n    else {\n\n        // expiresIn\n\n        rule.expiresIn = options.expiresIn || 0;\n    }\n\n    // generateTimeout\n\n    if (options.generateFunc) {\n        rule.generateFunc = options.generateFunc;\n        rule.generateTimeout = options.generateTimeout;\n\n        // Stale\n\n        if (options.staleIn) {\n            rule.staleIn = options.staleIn;\n            rule.staleTimeout = options.staleTimeout;\n        }\n\n        rule.dropOnError = options.dropOnError !== undefined ? options.dropOnError : true;                                          // Defaults to true\n        rule.pendingGenerateTimeout = options.pendingGenerateTimeout !== undefined ? options.pendingGenerateTimeout : 0;            // Defaults to zero\n    }\n\n    rule.generateOnReadError = options.generateOnReadError !== undefined ? options.generateOnReadError : true;                      // Defaults to true\n    rule.generateIgnoreWriteError = options.generateIgnoreWriteError !== undefined ? options.generateIgnoreWriteError : true;       // Defaults to true\n\n    return rule;\n};\n\n\ninternals.Policy.ttl = function (rule, created, now) {\n\n    now = now || Date.now();\n    created = created || now;\n    const age = now - created;\n\n    if (age < 0) {\n        return 0;                                                                   // Created in the future, assume expired/bad\n    }\n\n    if (rule.expiresIn) {\n        return Math.max(rule.expiresIn - age, 0);\n    }\n\n    if (rule.expiresAt) {\n        if (age > internals.day) {                                                  // If the item was created more than a 24 hours ago\n            return 0;\n        }\n\n        const expiresAt = new Date(created);                                        // Compare expiration time on the same day\n        expiresAt.setHours(rule.expiresAt.hours);\n        expiresAt.setMinutes(rule.expiresAt.minutes);\n        expiresAt.setSeconds(0);\n        expiresAt.setMilliseconds(0);\n        let expires = expiresAt.getTime();\n\n        if (expires <= created) {\n            expires = expires + internals.day;                                     // Move to tomorrow\n        }\n\n        if (now >= expires) {                                                      // Expired\n            return 0;\n        }\n\n        return expires - now;\n    }\n\n    return 0;                                                                       // No rule\n};\n\n\ninternals.Policy.prototype.isReady = function () {\n\n    if (!this._cache) {\n        return false;\n    }\n\n    return this._cache.connection.isReady();\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Any = require('./any');\nconst Cast = require('./cast');\nconst Errors = require('./errors');\nconst Lazy = require('./lazy');\nconst Ref = require('./ref');\n\n\n// Declare internals\n\nconst internals = {\n    alternatives: require('./alternatives'),\n    array: require('./array'),\n    boolean: require('./boolean'),\n    binary: require('./binary'),\n    date: require('./date'),\n    number: require('./number'),\n    object: require('./object'),\n    string: require('./string')\n};\n\n\ninternals.root = function () {\n\n    const any = new Any();\n\n    const root = any.clone();\n    root.any = function () {\n\n        Hoek.assert(arguments.length === 0, 'Joi.any() does not allow arguments.');\n\n        return any;\n    };\n\n    root.alternatives = root.alt = function () {\n\n        return arguments.length ? internals.alternatives.try.apply(internals.alternatives, arguments) : internals.alternatives;\n    };\n\n    root.array = function () {\n\n        Hoek.assert(arguments.length === 0, 'Joi.array() does not allow arguments.');\n\n        return internals.array;\n    };\n\n    root.boolean = root.bool = function () {\n\n        Hoek.assert(arguments.length === 0, 'Joi.boolean() does not allow arguments.');\n\n        return internals.boolean;\n    };\n\n    root.binary = function () {\n\n        Hoek.assert(arguments.length === 0, 'Joi.binary() does not allow arguments.');\n\n        return internals.binary;\n    };\n\n    root.date = function () {\n\n        Hoek.assert(arguments.length === 0, 'Joi.date() does not allow arguments.');\n\n        return internals.date;\n    };\n\n    root.func = function () {\n\n        Hoek.assert(arguments.length === 0, 'Joi.func() does not allow arguments.');\n\n        return internals.object._func();\n    };\n\n    root.number = function () {\n\n        Hoek.assert(arguments.length === 0, 'Joi.number() does not allow arguments.');\n\n        return internals.number;\n    };\n\n    root.object = function () {\n\n        return arguments.length ? internals.object.keys.apply(internals.object, arguments) : internals.object;\n    };\n\n    root.string = function () {\n\n        Hoek.assert(arguments.length === 0, 'Joi.string() does not allow arguments.');\n\n        return internals.string;\n    };\n\n    root.ref = function () {\n\n        return Ref.create.apply(null, arguments);\n    };\n\n    root.isRef = function (ref) {\n\n        return Ref.isRef(ref);\n    };\n\n    root.validate = function (value /*, [schema], [options], callback */) {\n\n        const last = arguments[arguments.length - 1];\n        const callback = typeof last === 'function' ? last : null;\n\n        const count = arguments.length - (callback ? 1 : 0);\n        if (count === 1) {\n            return any.validate(value, callback);\n        }\n\n        const options = count === 3 ? arguments[2] : {};\n        const schema = root.compile(arguments[1]);\n\n        return schema._validateWithOptions(value, options, callback);\n    };\n\n    root.describe = function () {\n\n        const schema = arguments.length ? root.compile(arguments[0]) : any;\n        return schema.describe();\n    };\n\n    root.compile = function (schema) {\n\n        try {\n            return Cast.schema(schema);\n        }\n        catch (err) {\n            if (err.hasOwnProperty('path')) {\n                err.message = err.message + '(' + err.path + ')';\n            }\n            throw err;\n        }\n    };\n\n    root.assert = function (value, schema, message) {\n\n        root.attempt(value, schema, message);\n    };\n\n    root.attempt = function (value, schema, message) {\n\n        const result = root.validate(value, schema);\n        const error = result.error;\n        if (error) {\n            if (!message) {\n                error.message = error.annotate();\n                throw error;\n            }\n\n            if (!(message instanceof Error)) {\n                error.message = message + ' ' + error.annotate();\n                throw error;\n            }\n\n            throw message;\n        }\n\n        return result.value;\n    };\n\n    root.reach = function (schema, path) {\n\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\n        Hoek.assert(typeof path === 'string', 'path must be a string');\n\n        if (path === '') {\n            return schema;\n        }\n\n        const parts = path.split('.');\n        const children = schema._inner.children;\n        if (!children) {\n            return;\n        }\n\n        const key = parts[0];\n        for (let i = 0; i < children.length; ++i) {\n            const child = children[i];\n            if (child.key === key) {\n                return this.reach(child.schema, path.substr(key.length + 1));\n            }\n        }\n    };\n\n    root.lazy = function (fn) {\n\n        return Lazy.set(fn);\n    };\n\n    root.extend = function () {\n\n        const extensions = Hoek.flatten(Array.prototype.slice.call(arguments));\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\n\n        this.assert(extensions, root.extensionsSchema);\n\n        const joi = Object.create(this);\n\n        for (let i = 0; i < extensions.length; ++i) {\n            const extension = extensions[i];\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\n            const ctor = base.constructor;\n            const type = class extends ctor { // eslint-disable-line no-loop-func\n\n                constructor() {\n\n                    super();\n                    if (extension.base) {\n                        Object.assign(this, base);\n                    }\n\n                    this._type = extension.name;\n\n                    if (extension.language) {\n                        this._settings = this._settings || { language: {} };\n                        this._settings.language = Hoek.applyToDefaults(this._settings.language, {\n                            [extension.name]: extension.language\n                        });\n                    }\n                }\n\n            };\n\n            if (extension.coerce) {\n                type.prototype._coerce = function (value, state, options) {\n\n                    if (ctor.prototype._coerce) {\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\n\n                        if (baseRet.errors) {\n                            return baseRet;\n                        }\n\n                        value = baseRet.value;\n                    }\n\n                    const ret = extension.coerce.call(this, value, state, options);\n                    if (ret instanceof Errors.Err) {\n                        return { value, errors: ret };\n                    }\n\n                    return { value: ret };\n                };\n            }\n            if (extension.pre) {\n                type.prototype._base = function (value, state, options) {\n\n                    if (ctor.prototype._base) {\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\n\n                        if (baseRet.errors) {\n                            return baseRet;\n                        }\n\n                        value = baseRet.value;\n                    }\n\n                    const ret = extension.pre.call(this, value, state, options);\n                    if (ret instanceof Errors.Err) {\n                        return { value, errors: ret };\n                    }\n\n                    return { value: ret };\n                };\n            }\n\n            if (extension.rules) {\n                for (let j = 0; j < extension.rules.length; ++j) {\n                    const rule = extension.rules[j];\n                    const ruleArgs = rule.params ?\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\n                        [];\n                    const validateArgs = rule.params ? Cast.schema(rule.params) : null;\n\n                    type.prototype[rule.name] = function () { // eslint-disable-line no-loop-func\n\n                        if (arguments.length > ruleArgs.length) {\n                            throw new Error('Unexpected number of arguments');\n                        }\n\n                        const args = Array.prototype.slice.call(arguments);\n                        let hasRef = false;\n                        const arg = {};\n\n                        for (let k = 0; k < ruleArgs.length; ++k) {\n                            arg[ruleArgs[k]] = args[k];\n                            if (!hasRef && Ref.isRef(args[k])) {\n                                hasRef = true;\n                            }\n                        }\n\n                        if (validateArgs) {\n                            joi.assert(arg, validateArgs);\n                        }\n\n                        let schema;\n                        if (rule.validate) {\n                            const validate = function (value, state, options) {\n\n                                return rule.validate.call(this, arg, value, state, options);\n                            };\n\n                            schema = this._test(rule.name, arg, validate, {\n                                description: rule.description,\n                                hasRef\n                            });\n                        }\n                        else {\n                            schema = this.clone();\n                        }\n\n                        if (rule.setup) {\n                            rule.setup.call(schema, arg);\n                        }\n\n                        return schema;\n                    };\n                }\n            }\n\n            if (extension.describe) {\n                type.prototype.describe = function () {\n\n                    const description = ctor.prototype.describe.call(this);\n                    return extension.describe.call(this, description);\n                };\n            }\n\n            const instance = new type();\n            joi[extension.name] = function () {\n\n                return instance;\n            };\n        }\n\n        return joi;\n    };\n\n    root.extensionsSchema = internals.array.items(internals.object.keys({\n        base: internals.object.type(Any, 'Joi object'),\n        name: internals.string.required(),\n        coerce: internals.object._func().arity(3),\n        pre: internals.object._func().arity(3),\n        language: internals.object,\n        describe: internals.object._func().arity(1),\n        rules: internals.array.items(internals.object.keys({\n            name: internals.string.required(),\n            setup: internals.object._func().arity(1),\n            validate: internals.object._func().arity(4),\n            params: [\n                internals.object.pattern(/.*/, internals.object.type(Any, 'Joi object')),\n                internals.object.type(internals.object.constructor, 'Joi object')\n            ],\n            description: [internals.string, internals.object._func().arity(1)]\n        }).or('setup', 'validate'))\n    })).strict();\n\n    root.version = require('../package.json').version;\n\n    return root;\n};\n\n\nmodule.exports = internals.root();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/any.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Ref = require('./ref');\nconst Errors = require('./errors');\nlet Alternatives = null;                // Delay-loaded to prevent circular dependencies\nlet Cast = null;\n\n\n// Declare internals\n\nconst internals = {\n    Set: require('./set')\n};\n\n\ninternals.defaults = {\n    abortEarly: true,\n    convert: true,\n    allowUnknown: false,\n    skipFunctions: false,\n    stripUnknown: false,\n    language: {},\n    presence: 'optional',\n    strip: false,\n    noDefaults: false\n\n    // context: null\n};\n\n\nmodule.exports = internals.Any = class {\n\n    constructor() {\n\n        Cast = Cast || require('./cast');\n\n        this.isJoi = true;\n        this._type = 'any';\n        this._settings = null;\n        this._valids = new internals.Set();\n        this._invalids = new internals.Set();\n        this._tests = [];\n        this._refs = [];\n        this._flags = {\n            /*\n             presence: 'optional',                   // optional, required, forbidden, ignore\n             allowOnly: false,\n             allowUnknown: undefined,\n             default: undefined,\n             forbidden: false,\n             encoding: undefined,\n             insensitive: false,\n             trim: false,\n             case: undefined,                        // upper, lower\n             empty: undefined,\n             func: false,\n             raw: false\n             */\n        };\n\n        this._description = null;\n        this._unit = null;\n        this._notes = [];\n        this._tags = [];\n        this._examples = [];\n        this._meta = [];\n\n        this._inner = {};                           // Hash of arrays of immutable objects\n    }\n\n    createError(type, context, state, options) {\n\n        return Errors.create(type, context, state, options, this._flags);\n    }\n\n    checkOptions(options) {\n\n        const Schemas = require('./schemas');\n        const result = Schemas.options.validate(options);\n        if (result.error) {\n            throw new Error(result.error.details[0].message);\n        }\n    }\n\n    clone() {\n\n        const obj = Object.create(Object.getPrototypeOf(this));\n\n        obj.isJoi = true;\n        obj._type = this._type;\n        obj._settings = internals.concatSettings(this._settings);\n        obj._valids = Hoek.clone(this._valids);\n        obj._invalids = Hoek.clone(this._invalids);\n        obj._tests = this._tests.slice();\n        obj._refs = this._refs.slice();\n        obj._flags = Hoek.clone(this._flags);\n\n        obj._description = this._description;\n        obj._unit = this._unit;\n        obj._notes = this._notes.slice();\n        obj._tags = this._tags.slice();\n        obj._examples = this._examples.slice();\n        obj._meta = this._meta.slice();\n\n        obj._inner = {};\n        const inners = Object.keys(this._inner);\n        for (let i = 0; i < inners.length; ++i) {\n            const key = inners[i];\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\n        }\n\n        return obj;\n    }\n\n    concat(schema) {\n\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\n\n        let obj = this.clone();\n\n        if (this._type === 'any' && schema._type !== 'any') {\n\n            // Reset values as if we were \"this\"\n            const tmpObj = schema.clone();\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\n\n            for (let i = 0; i < keysToRestore.length; ++i) {\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\n            }\n\n            obj = tmpObj;\n        }\n\n        obj._settings = obj._settings ? internals.concatSettings(obj._settings, schema._settings) : schema._settings;\n        obj._valids.merge(schema._valids, schema._invalids);\n        obj._invalids.merge(schema._invalids, schema._valids);\n        obj._tests = obj._tests.concat(schema._tests);\n        obj._refs = obj._refs.concat(schema._refs);\n        Hoek.merge(obj._flags, schema._flags);\n\n        obj._description = schema._description || obj._description;\n        obj._unit = schema._unit || obj._unit;\n        obj._notes = obj._notes.concat(schema._notes);\n        obj._tags = obj._tags.concat(schema._tags);\n        obj._examples = obj._examples.concat(schema._examples);\n        obj._meta = obj._meta.concat(schema._meta);\n\n        const inners = Object.keys(schema._inner);\n        const isObject = obj._type === 'object';\n        for (let i = 0; i < inners.length; ++i) {\n            const key = inners[i];\n            const source = schema._inner[key];\n            if (source) {\n                const target = obj._inner[key];\n                if (target) {\n                    if (isObject && key === 'children') {\n                        const keys = {};\n\n                        for (let j = 0; j < target.length; ++j) {\n                            keys[target[j].key] = j;\n                        }\n\n                        for (let j = 0; j < source.length; ++j) {\n                            const sourceKey = source[j].key;\n                            if (keys[sourceKey] >= 0) {\n                                target[keys[sourceKey]] = {\n                                    key: sourceKey,\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\n                                };\n                            }\n                            else {\n                                target.push(source[j]);\n                            }\n                        }\n                    }\n                    else {\n                        obj._inner[key] = obj._inner[key].concat(source);\n                    }\n                }\n                else {\n                    obj._inner[key] = source.slice();\n                }\n            }\n        }\n\n        return obj;\n    }\n\n    _test(name, arg, func, options) {\n\n        const obj = this.clone();\n        obj._tests.push({ func, name, arg, options });\n        return obj;\n    }\n\n    options(options) {\n\n        Hoek.assert(!options.context, 'Cannot override context');\n        this.checkOptions(options);\n\n        const obj = this.clone();\n        obj._settings = internals.concatSettings(obj._settings, options);\n        return obj;\n    }\n\n    strict(isStrict) {\n\n        const obj = this.clone();\n        obj._settings = obj._settings || {};\n        obj._settings.convert = isStrict === undefined ? false : !isStrict;\n        return obj;\n    }\n\n    raw(isRaw) {\n\n        const obj = this.clone();\n        obj._flags.raw = isRaw === undefined ? true : isRaw;\n        return obj;\n    }\n\n    error(err) {\n\n        Hoek.assert(err && err instanceof Error, 'Must provide a valid Error object');\n\n        const obj = this.clone();\n        obj._flags.error = err;\n        return obj;\n    }\n\n    allow() {\n\n        const obj = this.clone();\n        const values = Hoek.flatten(Array.prototype.slice.call(arguments));\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            obj._invalids.remove(value);\n            obj._valids.add(value, obj._refs);\n        }\n        return obj;\n    }\n\n    valid() {\n\n        const obj = this.allow.apply(this, arguments);\n        obj._flags.allowOnly = true;\n        return obj;\n    }\n\n    invalid(value) {\n\n        const obj = this.clone();\n        const values = Hoek.flatten(Array.prototype.slice.call(arguments));\n        for (let i = 0; i < values.length; ++i) {\n            value = values[i];\n\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            obj._valids.remove(value);\n            obj._invalids.add(value, this._refs);\n        }\n\n        return obj;\n    }\n\n    required() {\n\n        const obj = this.clone();\n        obj._flags.presence = 'required';\n        return obj;\n    }\n\n    optional() {\n\n        const obj = this.clone();\n        obj._flags.presence = 'optional';\n        return obj;\n    }\n\n\n    forbidden() {\n\n        const obj = this.clone();\n        obj._flags.presence = 'forbidden';\n        return obj;\n    }\n\n\n    strip() {\n\n        const obj = this.clone();\n        obj._flags.strip = true;\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args, root) {\n\n        children = [].concat(children);\n\n        if (children.length !== 1 || children[0] !== '') {\n            root = root ? (root + '.') : '';\n\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\n\n                return root + child;\n            });\n\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\n        }\n\n        return this[fn].apply(this, args);\n    }\n\n    default(value, description) {\n\n        if (typeof value === 'function' &&\n            !Ref.isRef(value)) {\n\n            if (!value.description &&\n                description) {\n\n                value.description = description;\n            }\n\n            if (!this._flags.func) {\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\n            }\n        }\n\n        const obj = this.clone();\n        obj._flags.default = value;\n        Ref.push(obj._refs, value);\n        return obj;\n    }\n\n    empty(schema) {\n\n        const obj = this.clone();\n        obj._flags.empty = schema === undefined ? undefined : Cast.schema(schema);\n        return obj;\n    }\n\n    when(ref, options) {\n\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(options.then)) : undefined;\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(options.otherwise)) : undefined;\n\n        Alternatives = Alternatives || require('./alternatives');\n        const obj = Alternatives.when(ref, { is: options.is, then, otherwise });\n        obj._flags.presence = 'ignore';\n        obj._settings = internals.concatSettings(obj._settings, { baseType: this });\n\n        return obj;\n    }\n\n    description(desc) {\n\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n\n        const obj = this.clone();\n        obj._description = desc;\n        return obj;\n    }\n\n    notes(notes) {\n\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\n\n        const obj = this.clone();\n        obj._notes = obj._notes.concat(notes);\n        return obj;\n    }\n\n    tags(tags) {\n\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\n\n        const obj = this.clone();\n        obj._tags = obj._tags.concat(tags);\n        return obj;\n    }\n\n    meta(meta) {\n\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\n\n        const obj = this.clone();\n        obj._meta = obj._meta.concat(meta);\n        return obj;\n    }\n\n    example(value) {\n\n        Hoek.assert(arguments.length, 'Missing example');\n        const result = this._validate(value, null, internals.defaults);\n        Hoek.assert(!result.errors, 'Bad example:', result.errors && Errors.process(result.errors, value));\n\n        const obj = this.clone();\n        obj._examples.push(value);\n        return obj;\n    }\n\n    unit(name) {\n\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n\n        const obj = this.clone();\n        obj._unit = name;\n        return obj;\n    }\n\n    _prepareEmptyValue(value) {\n\n        if (typeof value === 'string' && this._flags.trim) {\n            return value.trim();\n        }\n\n        return value;\n    }\n\n    _validate(value, state, options, reference) {\n\n        const originalValue = value;\n\n        // Setup state and settings\n\n        state = state || { key: '', path: '', parent: null, reference };\n\n        if (this._settings) {\n            options = internals.concatSettings(options, this._settings);\n        }\n\n        let errors = [];\n        const finish = () => {\n\n            let finalValue;\n\n            if (!this._flags.strip) {\n                if (value !== undefined) {\n                    finalValue = this._flags.raw ? originalValue : value;\n                }\n                else if (options.noDefaults) {\n                    finalValue = originalValue;\n                }\n                else if (Ref.isRef(this._flags.default)) {\n                    finalValue = this._flags.default(state.parent, options);\n                }\n                else if (typeof this._flags.default === 'function' &&\n                    !(this._flags.func && !this._flags.default.description)) {\n\n                    let args;\n\n                    if (state.parent !== null &&\n                        this._flags.default.length > 0) {\n\n                        args = [Hoek.clone(state.parent), options];\n                    }\n\n                    const defaultValue = internals._try(this._flags.default, args);\n                    finalValue = defaultValue.value;\n                    if (defaultValue.error) {\n                        errors.push(this.createError('any.default', defaultValue.error, state, options));\n                    }\n                }\n                else {\n                    finalValue = Hoek.clone(this._flags.default);\n                }\n            }\n\n            return {\n                value: finalValue,\n                errors: errors.length ? errors : null\n            };\n        };\n\n        if (this._coerce) {\n            const coerced = this._coerce.call(this, value, state, options);\n            if (coerced.errors) {\n                value = coerced.value;\n                errors = errors.concat(coerced.errors);\n                return finish();                            // Coerced error always aborts early\n            }\n\n            value = coerced.value;\n        }\n\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\n            value = undefined;\n        }\n\n        // Check presence requirements\n\n        const presence = this._flags.presence || options.presence;\n        if (presence === 'optional') {\n            if (value === undefined) {\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\n                if (isDeepDefault && this._type === 'object') {\n                    value = {};\n                }\n                else {\n                    return finish();\n                }\n            }\n        }\n        else if (presence === 'required' &&\n            value === undefined) {\n\n            errors.push(this.createError('any.required', null, state, options));\n            return finish();\n        }\n        else if (presence === 'forbidden') {\n            if (value === undefined) {\n                return finish();\n            }\n\n            errors.push(this.createError('any.unknown', null, state, options));\n            return finish();\n        }\n\n        // Check allowed and denied values using the original value\n\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\n            return finish();\n        }\n\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', null, state, options));\n            if (options.abortEarly ||\n                value === undefined) {          // No reason to keep validating missing value\n\n                return finish();\n            }\n        }\n\n        // Convert value and validate type\n\n        if (this._base) {\n            const base = this._base.call(this, value, state, options);\n            if (base.errors) {\n                value = base.value;\n                errors = errors.concat(base.errors);\n                return finish();                            // Base error always aborts early\n            }\n\n            if (base.value !== value) {\n                value = base.value;\n\n                // Check allowed and denied values using the converted value\n\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\n                    return finish();\n                }\n\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', null, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n            }\n        }\n\n        // Required values did not match\n\n        if (this._flags.allowOnly) {\n            errors.push(this.createError('any.allowOnly', { valids: this._valids.values({ stripUndefined: true }) }, state, options));\n            if (options.abortEarly) {\n                return finish();\n            }\n        }\n\n        // Helper.validate tests\n\n        for (let i = 0; i < this._tests.length; ++i) {\n            const test = this._tests[i];\n            const ret = test.func.call(this, value, state, options);\n            if (ret instanceof Errors.Err) {\n                errors.push(ret);\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n            else {\n                value = ret;\n            }\n        }\n\n        return finish();\n    }\n\n    _validateWithOptions(value, options, callback) {\n\n        if (options) {\n            this.checkOptions(options);\n        }\n\n        const settings = internals.concatSettings(internals.defaults, options);\n        const result = this._validate(value, null, settings);\n        const errors = Errors.process(result.errors, value);\n\n        if (callback) {\n            return callback(errors, result.value);\n        }\n\n        return { error: errors, value: result.value };\n    }\n\n    validate(value, options, callback) {\n\n        if (typeof options === 'function') {\n            return this._validateWithOptions(value, null, options);\n        }\n\n        return this._validateWithOptions(value, options, callback);\n    }\n\n    describe() {\n\n        const description = {\n            type: this._type\n        };\n\n        const flags = Object.keys(this._flags);\n        if (flags.length) {\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\n                description.flags = {};\n                for (let i = 0; i < flags.length; ++i) {\n                    const flag = flags[i];\n                    if (flag === 'empty') {\n                        description.flags[flag] = this._flags[flag].describe();\n                    }\n                    else if (flag === 'default') {\n                        if (Ref.isRef(this._flags[flag])) {\n                            description.flags[flag] = this._flags[flag].toString();\n                        }\n                        else if (typeof this._flags[flag] === 'function') {\n                            description.flags[flag] = this._flags[flag].description;\n                        }\n                        else {\n                            description.flags[flag] = this._flags[flag];\n                        }\n                    }\n                    else if (flag === 'lazy' || flag === 'label') {\n                        // We don't want it in the description\n                    }\n                    else {\n                        description.flags[flag] = this._flags[flag];\n                    }\n                }\n            }\n            else {\n                description.flags = this._flags;\n            }\n        }\n\n        if (this._description) {\n            description.description = this._description;\n        }\n\n        if (this._notes.length) {\n            description.notes = this._notes;\n        }\n\n        if (this._tags.length) {\n            description.tags = this._tags;\n        }\n\n        if (this._meta.length) {\n            description.meta = this._meta;\n        }\n\n        if (this._examples.length) {\n            description.examples = this._examples;\n        }\n\n        if (this._unit) {\n            description.unit = this._unit;\n        }\n\n        const valids = this._valids.values();\n        if (valids.length) {\n            description.valids = valids.map((v) => {\n\n                return Ref.isRef(v) ? v.toString() : v;\n            });\n        }\n\n        const invalids = this._invalids.values();\n        if (invalids.length) {\n            description.invalids = invalids.map((v) => {\n\n                return Ref.isRef(v) ? v.toString() : v;\n            });\n        }\n\n        description.rules = [];\n\n        for (let i = 0; i < this._tests.length; ++i) {\n            const validator = this._tests[i];\n            const item = { name: validator.name };\n\n            if (validator.arg !== void 0) {\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\n            }\n\n            const options = validator.options;\n            if (options) {\n                if (options.hasRef) {\n                    item.arg = {};\n                    const keys = Object.keys(validator.arg);\n                    for (let j = 0; j < keys.length; ++j) {\n                        const key = keys[j];\n                        const value = validator.arg[key];\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\n                    }\n                }\n\n                if (typeof options.description === 'string') {\n                    item.description = options.description;\n                }\n                else if (typeof options.description === 'function') {\n                    item.description = options.description(item.arg);\n                }\n            }\n\n            description.rules.push(item);\n        }\n\n        if (!description.rules.length) {\n            delete description.rules;\n        }\n\n        const label = this._getLabel();\n        if (label) {\n            description.label = label;\n        }\n\n        return description;\n    }\n\n    label(name) {\n\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n\n        const obj = this.clone();\n        obj._flags.label = name;\n        return obj;\n    }\n\n    _getLabel(def) {\n\n        return this._flags.label || def;\n    }\n\n};\n\n\ninternals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects\n\n// Aliases\n\ninternals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;\ninternals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;\ninternals.Any.prototype.exist = internals.Any.prototype.required;\n\n\ninternals._try = function (fn, args) {\n\n    let err;\n    let result;\n\n    try {\n        result = fn.apply(null, args);\n    }\n    catch (e) {\n        err = e;\n    }\n\n    return {\n        value: result,\n        error: err\n    };\n};\n\ninternals.concatSettings = function (target, source) {\n\n    // Used to avoid cloning context\n\n    if (!target &&\n        !source) {\n\n        return null;\n    }\n\n    const obj = {};\n\n    if (target) {\n        Object.assign(obj, target);\n    }\n\n    if (source) {\n        const sKeys = Object.keys(source);\n        for (let i = 0; i < sKeys.length; ++i) {\n            const key = sKeys[i];\n            if (key !== 'language' ||\n                !obj.hasOwnProperty(key)) {\n\n                obj[key] = source[key];\n            }\n            else {\n                obj[key] = Hoek.applyToDefaults(obj[key], source[key]);\n            }\n        }\n    }\n\n    return obj;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/ref.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.create = function (key, options) {\n\n    Hoek.assert(typeof key === 'string', 'Invalid reference key:', key);\n\n    const settings = Hoek.clone(options);         // options can be reused and modified\n\n    const ref = function (value, validationOptions) {\n\n        return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);\n    };\n\n    ref.isContext = (key[0] === ((settings && settings.contextPrefix) || '$'));\n    ref.key = (ref.isContext ? key.slice(1) : key);\n    ref.path = ref.key.split((settings && settings.separator) || '.');\n    ref.depth = ref.path.length;\n    ref.root = ref.path[0];\n    ref.isJoi = true;\n\n    ref.toString = function () {\n\n        return (ref.isContext ? 'context:' : 'ref:') + ref.key;\n    };\n\n    return ref;\n};\n\n\nexports.isRef = function (ref) {\n\n    return typeof ref === 'function' && ref.isJoi;\n};\n\n\nexports.push = function (array, ref) {\n\n    if (exports.isRef(ref) &&\n        !ref.isContext) {\n\n        array.push(ref.root);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/errors.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Language = require('./language');\n\n\n// Declare internals\n\nconst internals = {};\n\ninternals.stringify = function (value, wrapArrays) {\n\n    const type = typeof value;\n\n    if (value === null) {\n        return 'null';\n    }\n\n    if (type === 'string') {\n        return value;\n    }\n\n    if (value instanceof exports.Err || type === 'function') {\n        return value.toString();\n    }\n\n    if (type === 'object') {\n        if (Array.isArray(value)) {\n            let partial = '';\n\n            for (let i = 0; i < value.length; ++i) {\n                partial = partial + (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);\n            }\n\n            return wrapArrays ? '[' + partial + ']' : partial;\n        }\n\n        return value.toString();\n    }\n\n    return JSON.stringify(value);\n};\n\nexports.Err = class {\n\n    constructor(type, context, state, options, flags) {\n\n        this.isJoi = true;\n        this.type = type;\n        this.context = context || {};\n        this.context.key = state.key;\n        this.path = state.path;\n        this.options = options;\n        this.flags = flags;\n    }\n\n    toString() {\n\n        const localized = this.options.language;\n\n        if (this.flags.label) {\n            this.context.key = this.flags.label;\n        }\n        else if (this.context.key === '' || this.context.key === null) {\n            this.context.key = localized.root || Language.errors.root;\n        }\n\n        let format = Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);\n        const hasKey = /\\{\\{\\!?key\\}\\}/.test(format);\n        const skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';\n\n        if (skipKey) {\n            format = format.slice(2);\n        }\n\n        if (!hasKey && !skipKey) {\n            format = (Hoek.reach(localized, 'key') || Hoek.reach(Language.errors, 'key')) + format;\n        }\n\n        let wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');\n        if (typeof wrapArrays !== 'boolean') {\n            wrapArrays = Language.errors.messages.wrapArrays;\n        }\n\n        return format.replace(/\\{\\{(\\!?)([^}]+)\\}\\}/g, ($0, isSecure, name) => {\n\n            const value = Hoek.reach(this.context, name);\n            const normalized = internals.stringify(value, wrapArrays);\n            return (isSecure ? Hoek.escapeHtml(normalized) : normalized);\n        });\n    }\n\n};\n\n\nexports.create = function (type, context, state, options, flags) {\n\n    return new exports.Err(type, context, state, options, flags);\n};\n\n\nexports.process = function (errors, object) {\n\n    if (!errors || !errors.length) {\n        return null;\n    }\n\n    // Construct error\n\n    let message = '';\n    const details = [];\n\n    const processErrors = function (localErrors, parent) {\n\n        for (let i = 0; i < localErrors.length; ++i) {\n            const item = localErrors[i];\n\n            if (item.flags.error) {\n                return item.flags.error;\n            }\n\n            let itemMessage;\n            if (parent === undefined) {\n                itemMessage = item.toString();\n                message = message + (message ? '. ' : '') + itemMessage;\n            }\n\n            // Do not push intermediate errors, we're only interested in leafs\n\n            if (item.context.reason && item.context.reason.length) {\n                const override = processErrors(item.context.reason, item.path);\n                if (override) {\n                    return override;\n                }\n            }\n            else {\n                details.push({\n                    message: itemMessage || item.toString(),\n                    path: internals.getPath(item),\n                    type: item.type,\n                    context: item.context\n                });\n            }\n        }\n    };\n\n    const override = processErrors(errors);\n    if (override) {\n        return override;\n    }\n\n    const error = new Error(message);\n    error.isJoi = true;\n    error.name = 'ValidationError';\n    error.details = details;\n    error._object = object;\n    error.annotate = internals.annotate;\n    return error;\n};\n\n\ninternals.getPath = function (item) {\n\n    return item.path || item.context.key;\n};\n\n\n// Inspired by json-stringify-safe\ninternals.safeStringify = function (obj, spaces) {\n\n    return JSON.stringify(obj, internals.serializer(), spaces);\n};\n\ninternals.serializer = function () {\n\n    const keys = [];\n    const stack = [];\n\n    const cycleReplacer = (key, value) => {\n\n        if (stack[0] === value) {\n            return '[Circular ~]';\n        }\n\n        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n    };\n\n    return function (key, value) {\n\n        if (stack.length > 0) {\n            const thisPos = stack.indexOf(this);\n            if (~thisPos) {\n                stack.length = thisPos + 1;\n                keys.length = thisPos + 1;\n                keys[thisPos] = key;\n            }\n            else {\n                stack.push(this);\n                keys.push(key);\n            }\n\n            if (~stack.indexOf(value)) {\n                value = cycleReplacer.call(this, key, value);\n            }\n        }\n        else {\n            stack.push(value);\n        }\n\n        if (Array.isArray(value) && value.placeholders) {\n            const placeholders = value.placeholders;\n            const arrWithPlaceholders = [];\n            for (let i = 0; i < value.length; ++i) {\n                if (placeholders[i]) {\n                    arrWithPlaceholders.push(placeholders[i]);\n                }\n                arrWithPlaceholders.push(value[i]);\n            }\n\n            value = arrWithPlaceholders;\n        }\n\n        if (value === Infinity || value === -Infinity || Number.isNaN(value) ||\n            typeof value === 'function' || typeof value === 'symbol') {\n            return '[' + value.toString() + ']';\n        }\n\n        return value;\n    };\n};\n\n\ninternals.annotate = function (stripColorCodes) {\n\n    const redFgEscape = stripColorCodes ? '' : '\\u001b[31m';\n    const redBgEscape = stripColorCodes ? '' : '\\u001b[41m';\n    const endColor = stripColorCodes ? '' : '\\u001b[0m';\n\n    if (typeof this._object !== 'object') {\n        return this.details[0].message;\n    }\n\n    const obj = Hoek.clone(this._object || {});\n\n    const lookup = {};\n    for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first\n        const pos = i + 1;\n        const error = this.details[i];\n        const path = error.path.split('.');\n        let ref = obj;\n        for (let j = 0; j < path.length && ref; ++j) {\n            const seg = path[j];\n            if (j + 1 < path.length) {\n                ref = ref[seg];\n            }\n            else {\n                const value = ref[seg];\n                if (Array.isArray(ref)) {\n                    const arrayLabel = `_$idx$_${pos}_$end$_`;\n                    if (!ref.placeholders) {\n                        ref.placeholders = {};\n                    }\n\n                    if (ref.placeholders[seg]) {\n                        ref.placeholders[seg] = ref.placeholders[seg].replace('_$end$_', `, ${pos}_$end$_`);\n                    }\n                    else {\n                        ref.placeholders[seg] = arrayLabel;\n                    }\n                }\n                else {\n                    if (value !== undefined) {\n                        delete ref[seg];\n                        const objectLabel = `${seg}_$key$_${pos}_$end$_`;\n                        ref[objectLabel] = value;\n                        lookup[error.path] = objectLabel;\n                    }\n                    else if (lookup[error.path]) {\n                        const replacement = lookup[error.path];\n                        const appended = replacement.replace('_$end$_', `, ${pos}_$end$_`);\n                        ref[appended] = ref[replacement];\n                        lookup[error.path] = appended;\n                        delete ref[replacement];\n                    }\n                    else {\n                        ref[`_$miss$_${seg}|${pos}_$end$_`] = '__missing__';\n                    }\n                }\n            }\n        }\n    }\n\n    const replacers = {\n        key: /_\\$key\\$_([, \\d]+)_\\$end\\$_\\\"/g,\n        missing: /\\\"_\\$miss\\$_([^\\|]+)\\|(\\d+)_\\$end\\$_\\\"\\: \\\"__missing__\\\"/g,\n        arrayIndex: /\\s*\\\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\\\",?\\n(.*)/g,\n        specials: /\"\\[(NaN|Symbol.*|-?Infinity|function.*|\\(.*)\\]\"/g\n    };\n\n    let message = internals.safeStringify(obj, 2)\n        .replace(replacers.key, ($0, $1) => `\" ${redFgEscape}[${$1}]${endColor}`)\n        .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}\"${$1}\"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)\n        .replace(replacers.arrayIndex, ($0, $1, $2) => `\\n${$2} ${redFgEscape}[${$1}]${endColor}`)\n        .replace(replacers.specials, ($0, $1) => $1);\n\n    message = `${message}\\n${redFgEscape}`;\n\n    for (let i = 0; i < this.details.length; ++i) {\n        const pos = i + 1;\n        message = `${message}\\n[${pos}] ${this.details[i].message}`;\n    }\n\n    message = message + endColor;\n\n    return message;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/language.js":"'use strict';\n\n// Load modules\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.errors = {\n    root: 'value',\n    key: '\"{{!key}}\" ',\n    messages: {\n        wrapArrays: true\n    },\n    any: {\n        unknown: 'is not allowed',\n        invalid: 'contains an invalid value',\n        empty: 'is not allowed to be empty',\n        required: 'is required',\n        allowOnly: 'must be one of {{valids}}',\n        default: 'threw an error when running default method'\n    },\n    alternatives: {\n        base: 'not matching any of the allowed alternatives'\n    },\n    array: {\n        base: 'must be an array',\n        includes: 'at position {{pos}} does not match any of the allowed types',\n        includesSingle: 'single value of \"{{!key}}\" does not match any of the allowed types',\n        includesOne: 'at position {{pos}} fails because {{reason}}',\n        includesOneSingle: 'single value of \"{{!key}}\" fails because {{reason}}',\n        includesRequiredUnknowns: 'does not contain {{unknownMisses}} required value(s)',\n        includesRequiredKnowns: 'does not contain {{knownMisses}}',\n        includesRequiredBoth: 'does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)',\n        excludes: 'at position {{pos}} contains an excluded value',\n        excludesSingle: 'single value of \"{{!key}}\" contains an excluded value',\n        min: 'must contain at least {{limit}} items',\n        max: 'must contain less than or equal to {{limit}} items',\n        length: 'must contain {{limit}} items',\n        ordered: 'at position {{pos}} fails because {{reason}}',\n        orderedLength: 'at position {{pos}} fails because array must contain at most {{limit}} items',\n        sparse: 'must not be a sparse array',\n        unique: 'position {{pos}} contains a duplicate value'\n    },\n    boolean: {\n        base: 'must be a boolean'\n    },\n    binary: {\n        base: 'must be a buffer or a string',\n        min: 'must be at least {{limit}} bytes',\n        max: 'must be less than or equal to {{limit}} bytes',\n        length: 'must be {{limit}} bytes'\n    },\n    date: {\n        base: 'must be a number of milliseconds or valid date string',\n        format: 'must be a string with one of the following formats {{format}}',\n        strict: 'must be a valid date',\n        min: 'must be larger than or equal to \"{{limit}}\"',\n        max: 'must be less than or equal to \"{{limit}}\"',\n        isoDate: 'must be a valid ISO 8601 date',\n        timestamp: {\n            javascript: 'must be a valid timestamp or number of milliseconds',\n            unix: 'must be a valid timestamp or number of seconds'\n        },\n        ref: 'references \"{{ref}}\" which is not a date'\n    },\n    function: {\n        base: 'must be a Function',\n        arity: 'must have an arity of {{n}}',\n        minArity: 'must have an arity greater or equal to {{n}}',\n        maxArity: 'must have an arity lesser or equal to {{n}}',\n        ref: 'must be a Joi reference'\n    },\n    lazy: {\n        base: '!!schema error: lazy schema must be set',\n        schema: '!!schema error: lazy schema function must return a schema'\n    },\n    object: {\n        base: 'must be an object',\n        child: '!!child \"{{!child}}\" fails because {{reason}}',\n        min: 'must have at least {{limit}} children',\n        max: 'must have less than or equal to {{limit}} children',\n        length: 'must have {{limit}} children',\n        allowUnknown: '!!\"{{!child}}\" is not allowed',\n        with: 'missing required peer \"{{peer}}\"',\n        without: 'conflict with forbidden peer \"{{peer}}\"',\n        missing: 'must contain at least one of {{peers}}',\n        xor: 'contains a conflict between exclusive peers {{peers}}',\n        or: 'must contain at least one of {{peers}}',\n        and: 'contains {{present}} without its required peers {{missing}}',\n        nand: '!!\"{{main}}\" must not exist simultaneously with {{peers}}',\n        assert: '!!\"{{ref}}\" validation failed because \"{{ref}}\" failed to {{message}}',\n        rename: {\n            multiple: 'cannot rename child \"{{from}}\" because multiple renames are disabled and another key was already renamed to \"{{to}}\"',\n            override: 'cannot rename child \"{{from}}\" because override is disabled and target \"{{to}}\" exists'\n        },\n        type: 'must be an instance of \"{{type}}\"',\n        schema: 'must be a Joi instance'\n    },\n    number: {\n        base: 'must be a number',\n        min: 'must be larger than or equal to {{limit}}',\n        max: 'must be less than or equal to {{limit}}',\n        less: 'must be less than {{limit}}',\n        greater: 'must be greater than {{limit}}',\n        float: 'must be a float or double',\n        integer: 'must be an integer',\n        negative: 'must be a negative number',\n        positive: 'must be a positive number',\n        precision: 'must have no more than {{limit}} decimal places',\n        ref: 'references \"{{ref}}\" which is not a number',\n        multiple: 'must be a multiple of {{multiple}}'\n    },\n    string: {\n        base: 'must be a string',\n        min: 'length must be at least {{limit}} characters long',\n        max: 'length must be less than or equal to {{limit}} characters long',\n        length: 'length must be {{limit}} characters long',\n        alphanum: 'must only contain alpha-numeric characters',\n        token: 'must only contain alpha-numeric and underscore characters',\n        regex: {\n            base: 'with value \"{{!value}}\" fails to match the required pattern: {{pattern}}',\n            name: 'with value \"{{!value}}\" fails to match the {{name}} pattern',\n            invert: {\n                base: 'with value \"{{!value}}\" matches the inverted pattern: {{pattern}}',\n                name: 'with value \"{{!value}}\" matches the inverted {{name}} pattern'\n            }\n        },\n        email: 'must be a valid email',\n        uri: 'must be a valid uri',\n        uriRelativeOnly: 'must be a valid relative uri',\n        uriCustomScheme: 'must be a valid uri with a scheme matching the {{scheme}} pattern',\n        isoDate: 'must be a valid ISO 8601 date',\n        guid: 'must be a valid GUID',\n        hex: 'must only contain hexadecimal characters',\n        base64: 'must be a valid base64 string',\n        hostname: 'must be a valid hostname',\n        lowercase: 'must only contain lowercase characters',\n        uppercase: 'must only contain uppercase characters',\n        trim: 'must not have leading or trailing whitespace',\n        creditCard: 'must be a credit card',\n        ref: 'references \"{{ref}}\" which is not a number',\n        ip: 'must be a valid ip address with a {{cidr}} CIDR',\n        ipVersion: 'must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR'\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/set.js":"'use strict';\n\nconst Ref = require('./ref');\n\nmodule.exports = class Set {\n\n    constructor() {\n\n        this._set = [];\n    }\n\n    add(value, refs) {\n\n        if (!Ref.isRef(value) && this.has(value, null, null, false)) {\n\n            return;\n        }\n\n        if (refs !== undefined) { // If it's a merge, we don't have any refs\n            Ref.push(refs, value);\n        }\n\n        this._set.push(value);\n        return this;\n    }\n\n    merge(add, remove) {\n\n        for (let i = 0; i < add._set.length; ++i) {\n            this.add(add._set[i]);\n        }\n\n        for (let i = 0; i < remove._set.length; ++i) {\n            this.remove(remove._set[i]);\n        }\n\n        return this;\n    }\n\n    remove(value) {\n\n        this._set = this._set.filter((item) => value !== item);\n        return this;\n    }\n\n    has(value, state, options, insensitive) {\n\n        for (let i = 0; i < this._set.length; ++i) {\n            let items = this._set[i];\n\n            if (state && Ref.isRef(items)) { // Only resolve references if there is a state, otherwise it's a merge\n                items = items(state.reference || state.parent, options);\n            }\n\n            if (!Array.isArray(items)) {\n                items = [items];\n            }\n\n            for (let j = 0; j < items.length; ++j) {\n                const item = items[j];\n                if (typeof value !== typeof item) {\n                    continue;\n                }\n\n                if (value === item ||\n                    (value instanceof Date && item instanceof Date && value.getTime() === item.getTime()) ||\n                    (insensitive && typeof value === 'string' && value.toLowerCase() === item.toLowerCase()) ||\n                    (Buffer.isBuffer(value) && Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary'))) {\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    values(options) {\n\n        if (options && options.stripUndefined) {\n            const values = [];\n\n            for (let i = 0; i < this._set.length; ++i) {\n                const item = this._set[i];\n                if (item !== undefined) {\n                    values.push(item);\n                }\n            }\n\n            return values;\n        }\n\n        return this._set.slice();\n    }\n\n    slice() {\n\n        const newSet = new Set();\n        newSet._set = this._set.slice();\n\n        return newSet;\n    }\n\n    concat(source) {\n\n        const newSet = new Set();\n        newSet._set = this._set.concat(source._set);\n\n        return newSet;\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/cast.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Ref = require('./ref');\n\n// Type modules are delay-loaded to prevent circular dependencies\n\n\n// Declare internals\n\nconst internals = {\n    any: null,\n    date: require('./date'),\n    string: require('./string'),\n    number: require('./number'),\n    boolean: require('./boolean'),\n    alt: null,\n    object: null\n};\n\n\nexports.schema = function (config) {\n\n    internals.any = internals.any || new (require('./any'))();\n    internals.alt = internals.alt || require('./alternatives');\n    internals.object = internals.object || require('./object');\n\n    if (config !== undefined && config !== null && typeof config === 'object') {\n\n        if (config.isJoi) {\n            return config;\n        }\n\n        if (Array.isArray(config)) {\n            return internals.alt.try(config);\n        }\n\n        if (config instanceof RegExp) {\n            return internals.string.regex(config);\n        }\n\n        if (config instanceof Date) {\n            return internals.date.valid(config);\n        }\n\n        return internals.object.keys(config);\n    }\n\n    if (typeof config === 'string') {\n        return internals.string.valid(config);\n    }\n\n    if (typeof config === 'number') {\n        return internals.number.valid(config);\n    }\n\n    if (typeof config === 'boolean') {\n        return internals.boolean.valid(config);\n    }\n\n    if (Ref.isRef(config)) {\n        return internals.any.valid(config);\n    }\n\n    Hoek.assert(config === null, 'Invalid schema content:', config);\n\n    return internals.any.valid(null);\n};\n\n\nexports.ref = function (id) {\n\n    return Ref.isRef(id) ? id : Ref.create(id);\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/date.js":"'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Ref = require('./ref');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\ninternals.isoDate = /^(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/;\ninternals.invalidDate = new Date('');\ninternals.isIsoDate = (() => {\n\n    const isoString = internals.isoDate.toString();\n\n    return (date) => {\n\n        return date && (date.toString() === isoString);\n    };\n})();\n\ninternals.Date = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'date';\n    }\n\n    _base(value, state, options) {\n\n        const result = {\n            value: (options.convert && internals.Date.toDate(value, this._flags.format, this._flags.timestamp, this._flags.multiplier)) || value\n        };\n\n        if (result.value instanceof Date && !isNaN(result.value.getTime())) {\n            result.errors = null;\n        }\n        else if (!options.convert) {\n            result.errors = this.createError('date.strict', null, state, options);\n        }\n        else {\n            let type;\n            if (internals.isIsoDate(this._flags.format)) {\n                type = 'isoDate';\n            }\n            else if (this._flags.timestamp) {\n                type = `timestamp.${this._flags.timestamp}`;\n            }\n            else {\n                type = 'base';\n            }\n\n            result.errors = this.createError(`date.${type}`, null, state, options);\n        }\n\n        return result;\n    }\n\n    static toDate(value, format, timestamp, multiplier) {\n\n        if (value instanceof Date) {\n            return value;\n        }\n\n        if (typeof value === 'string' ||\n            (typeof value === 'number' && !isNaN(value) && isFinite(value))) {\n\n            if (typeof value === 'string' &&\n                /^[+-]?\\d+(\\.\\d+)?$/.test(value)) {\n\n                value = parseFloat(value);\n            }\n\n            let date;\n            if (format && internals.isIsoDate(format)) {\n                date = format.test(value) ? new Date(value) : internals.invalidDate;\n            }\n            else if (timestamp && multiplier) {\n                date = new Date(value * multiplier);\n            }\n            else {\n                date = new Date(value);\n            }\n\n            if (!isNaN(date.getTime())) {\n                return date;\n            }\n        }\n\n        return null;\n    }\n\n    iso() {\n\n        const obj = this.clone();\n        obj._flags.format = internals.isoDate;\n        return obj;\n    }\n\n    timestamp(type) {\n\n        type = type || 'javascript';\n\n        const allowed = ['javascript', 'unix'];\n        Hoek.assert(allowed.indexOf(type) !== -1, '\"type\" must be one of \"' + allowed.join('\", \"') + '\"');\n\n        const obj = this.clone();\n        obj._flags.timestamp = type;\n        obj._flags.multiplier = type === 'unix' ? 1000 : 1;\n        return obj;\n    }\n\n    _isIsoDate(value) {\n\n        return internals.isoDate.test(value);\n    }\n\n};\n\ninternals.compare = function (type, compare) {\n\n    return function (date) {\n\n        const isNow = date === 'now';\n        const isRef = Ref.isRef(date);\n\n        if (!isNow && !isRef) {\n            date = internals.Date.toDate(date);\n        }\n\n        Hoek.assert(date, 'Invalid date format');\n\n        return this._test(type, date, function (value, state, options) {\n\n            let compareTo;\n            if (isNow) {\n                compareTo = Date.now();\n            }\n            else if (isRef) {\n                compareTo = internals.Date.toDate(date(state.reference || state.parent, options));\n\n                if (!compareTo) {\n                    return this.createError('date.ref', { ref: date.key }, state, options);\n                }\n\n                compareTo = compareTo.getTime();\n            }\n            else {\n                compareTo = date.getTime();\n            }\n\n            if (compare(value.getTime(), compareTo)) {\n                return value;\n            }\n\n            return this.createError('date.' + type, { limit: new Date(compareTo) }, state, options);\n        });\n    };\n};\ninternals.Date.prototype.min = internals.compare('min', (value, date) => value >= date);\ninternals.Date.prototype.max = internals.compare('max', (value, date) => value <= date);\n\n\nmodule.exports = new internals.Date();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/string.js":"'use strict';\n\n// Load modules\n\nconst Net = require('net');\nconst Hoek = require('hoek');\nconst Isemail = require('isemail');\nconst Any = require('./any');\nconst Ref = require('./ref');\nconst JoiDate = require('./date');\nconst Uri = require('./string/uri');\nconst Ip = require('./string/ip');\n\n// Declare internals\n\nconst internals = {\n    uriRegex: Uri.createUriRegex(),\n    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional')\n};\n\ninternals.String = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'string';\n        this._invalids.add('');\n    }\n\n    _base(value, state, options) {\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            if (this._flags.case) {\n                value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());\n            }\n\n            if (this._flags.trim) {\n                value = value.trim();\n            }\n\n            if (this._inner.replacements) {\n\n                for (let i = 0; i < this._inner.replacements.length; ++i) {\n                    const replacement = this._inner.replacements[i];\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n\n            if (this._flags.truncate) {\n                for (let i = 0; i < this._tests.length; ++i) {\n                    const test = this._tests[i];\n                    if (test.name === 'max') {\n                        value = value.slice(0, test.arg);\n                        break;\n                    }\n                }\n            }\n        }\n\n        return {\n            value,\n            errors: (typeof value === 'string') ? null : this.createError('string.base', { value }, state, options)\n        };\n    }\n\n    insensitive() {\n\n        const obj = this.clone();\n        obj._flags.insensitive = true;\n        return obj;\n    }\n\n    creditCard() {\n\n        return this._test('creditCard', undefined, function (value, state, options) {\n\n            let i = value.length;\n            let sum = 0;\n            let mul = 1;\n\n            while (i--) {\n                const char = value.charAt(i) * mul;\n                sum = sum + (char - (char > 9) * 9);\n                mul = mul ^ 3;\n            }\n\n            const check = (sum % 10 === 0) && (sum > 0);\n            return check ? value : this.createError('string.creditCard', { value }, state, options);\n        });\n    }\n\n    regex(pattern, patternOptions) {\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n\n        const patternObject = {\n            pattern: new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined)         // Future version should break this and forbid unsupported regex flags\n        };\n\n        if (typeof patternOptions === 'string') {\n            patternObject.name = patternOptions;\n        }\n        else if (typeof patternOptions === 'object') {\n            patternObject.invert = !!patternOptions.invert;\n\n            if (patternOptions.name) {\n                patternObject.name = patternOptions.name;\n            }\n        }\n\n        const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n\n        return this._test('regex', patternObject, function (value, state, options) {\n\n            const patternMatch = patternObject.pattern.test(value);\n\n            if (patternMatch ^ patternObject.invert) {\n                return value;\n            }\n\n            return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);\n        });\n    }\n\n    alphanum() {\n\n        return this._test('alphanum', undefined, function (value, state, options) {\n\n            if (/^[a-zA-Z0-9]+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.alphanum', { value }, state, options);\n        });\n    }\n\n    token() {\n\n        return this._test('token', undefined, function (value, state, options) {\n\n            if (/^\\w+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.token', { value }, state, options);\n        });\n    }\n\n    email(isEmailOptions) {\n\n        if (isEmailOptions) {\n            Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n            Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n            Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' ||\n                typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n            Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' ||\n                Hoek.isInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0,\n                'minDomainAtoms must be a positive integer');\n            Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' ||\n                (Hoek.isInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0),\n                'errorLevel must be a non-negative integer or boolean');\n        }\n\n        return this._test('email', isEmailOptions, function (value, state, options) {\n\n            try {\n                const result = Isemail.validate(value, isEmailOptions);\n                if (result === true || result === 0) {\n                    return value;\n                }\n            }\n            catch (e) { }\n\n            return this.createError('string.email', { value }, state, options);\n        });\n    }\n\n    ip(ipOptions) {\n\n        let regex = internals.ipRegex;\n        ipOptions = ipOptions || {};\n        Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n        if (ipOptions.cidr) {\n            Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n            ipOptions.cidr = ipOptions.cidr.toLowerCase();\n\n            Hoek.assert(ipOptions.cidr in Ip.cidrs, 'cidr must be one of ' + Object.keys(Ip.cidrs).join(', '));\n\n            // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n            if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n                regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n            }\n        }\n        else {\n\n            // Set our default cidr strategy\n            ipOptions.cidr = 'optional';\n        }\n\n        let versions;\n        if (ipOptions.version) {\n            if (!Array.isArray(ipOptions.version)) {\n                ipOptions.version = [ipOptions.version];\n            }\n\n            Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n\n            versions = [];\n            for (let i = 0; i < ipOptions.version.length; ++i) {\n                let version = ipOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n                versions.push(version);\n            }\n\n            // Make sure we have a set of versions\n            versions = Hoek.unique(versions);\n\n            regex = Ip.createIpRegex(versions, ipOptions.cidr);\n        }\n\n        return this._test('ip', ipOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (versions) {\n                return this.createError('string.ipVersion', { value, cidr: ipOptions.cidr, version: versions }, state, options);\n            }\n\n            return this.createError('string.ip', { value, cidr: ipOptions.cidr }, state, options);\n        });\n    }\n\n    uri(uriOptions) {\n\n        let customScheme = '';\n        let allowRelative = false;\n        let relativeOnly = false;\n        let regex = internals.uriRegex;\n\n        if (uriOptions) {\n            Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n\n            if (uriOptions.scheme) {\n                Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n                if (!Array.isArray(uriOptions.scheme)) {\n                    uriOptions.scheme = [uriOptions.scheme];\n                }\n\n                Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');\n\n                // Flatten the array into a string to be used to match the schemes.\n                for (let i = 0; i < uriOptions.scheme.length; ++i) {\n                    const scheme = uriOptions.scheme[i];\n                    Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');\n\n                    // Add OR separators if a value already exists\n                    customScheme = customScheme + (customScheme ? '|' : '');\n\n                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n                    if (scheme instanceof RegExp) {\n                        customScheme = customScheme + scheme.source;\n                    }\n                    else {\n                        Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n                        customScheme = customScheme + Hoek.escapeRegex(scheme);\n                    }\n                }\n            }\n\n            if (uriOptions.allowRelative) {\n                allowRelative = true;\n            }\n\n            if (uriOptions.relativeOnly) {\n                relativeOnly = true;\n            }\n        }\n\n        if (customScheme || allowRelative || relativeOnly) {\n            regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly);\n        }\n\n        return this._test('uri', uriOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (relativeOnly) {\n                return this.createError('string.uriRelativeOnly', { value }, state, options);\n            }\n\n            if (customScheme) {\n                return this.createError('string.uriCustomScheme', { scheme: customScheme, value }, state, options);\n            }\n\n            return this.createError('string.uri', { value }, state, options);\n        });\n    }\n\n    isoDate() {\n\n        return this._test('isoDate', undefined, function (value, state, options) {\n\n            if (JoiDate._isIsoDate(value)) {\n                return value;\n            }\n\n            return this.createError('string.isoDate', { value }, state, options);\n        });\n    }\n\n    guid(guidOptions) {\n\n        const brackets = {\n            '{': '}', '[': ']', '(': ')', '': ''\n        };\n\n        const uuids = {\n            'uuidv1': '1',\n            'uuidv2': '2',\n            'uuidv3': '3',\n            'uuidv4': '4',\n            'uuidv5': '5'\n        };\n\n        const versions = [];\n\n        if (guidOptions && guidOptions.version) {\n            if (!Array.isArray(guidOptions.version)) {\n                guidOptions.version = [guidOptions.version];\n            }\n\n            Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n\n            for (let i = 0; i < guidOptions.version.length; ++i) {\n                let version = guidOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                Hoek.assert(uuids[version], 'version at position ' + i + ' must be one of ' + Object.keys(uuids).join(', '));\n                Hoek.assert(versions.indexOf(version) === -1, 'version at position ' + i + ' must not be a duplicate.');\n                versions.push(version);\n            }\n        }\n\n        const regex = /^([\\[{\\(]?)([0-9A-F]{8})([:-]?)([0-9A-F]{4})([:-]?)([0-9A-F]{4})([:-]?)([0-9A-F]{4})([:-]?)([0-9A-F]{12})([\\]}\\)]?)$/i;\n\n        return this._test('guid', guidOptions, function (value, state, options) {\n\n            const results = regex.exec(value);\n\n            if (!results) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            // Matching braces\n            if (brackets[results[1]] !== results[11]) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            // Matching separators\n            if (results[3] !== results[5] || results[3] !== results[7] || results[3] !== results[9]) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            // Specific UUID versions\n            if (versions.length) {\n                const validVersions = versions.some((uuidVersion) => {\n\n                    return results[6][0] === uuids[uuidVersion];\n                });\n\n                // Valid version and 89AB check\n                if (!(validVersions && /[89AB]/i.test(results[8][0]))) {\n                    return this.createError('string.guid', { value }, state, options);\n                }\n            }\n\n            return value;\n        });\n    }\n\n    hex() {\n\n        const regex = /^[a-f0-9]+$/i;\n\n        return this._test('hex', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.hex', { value }, state, options);\n        });\n    }\n\n    base64() {\n\n        const regex = /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/;\n\n        return this._test('base64', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.base64', { value }, state, options);\n        });\n    }\n\n    hostname() {\n\n        const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n\n        return this._test('hostname', undefined, function (value, state, options) {\n\n            if ((value.length <= 255 && regex.test(value)) ||\n                Net.isIPv6(value)) {\n\n                return value;\n            }\n\n            return this.createError('string.hostname', { value }, state, options);\n        });\n    }\n\n    lowercase() {\n\n        const obj = this._test('lowercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleLowerCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.lowercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'lower';\n        return obj;\n    }\n\n    uppercase() {\n\n        const obj = this._test('uppercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleUpperCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.uppercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'upper';\n        return obj;\n    }\n\n    trim() {\n\n        const obj = this._test('trim', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.trim()) {\n\n                return value;\n            }\n\n            return this.createError('string.trim', { value }, state, options);\n        });\n\n        obj._flags.trim = true;\n        return obj;\n    }\n\n    replace(pattern, replacement) {\n\n        if (typeof pattern === 'string') {\n            pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n        }\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Hoek.assert(typeof replacement === 'string', 'replacement must be a String');\n\n        // This can not be considere a test like trim, we can't \"reject\"\n        // anything from this rule, so just clone the current object\n        const obj = this.clone();\n\n        if (!obj._inner.replacements) {\n            obj._inner.replacements = [];\n        }\n\n        obj._inner.replacements.push({\n            pattern,\n            replacement\n        });\n\n        return obj;\n    }\n\n    truncate(enabled) {\n\n        const obj = this.clone();\n        obj._flags.truncate = enabled === undefined ? true : !!enabled;\n        return obj;\n    }\n\n};\n\ninternals.compare = function (type, compare) {\n\n    return function (limit, encoding) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Hoek.isInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n        return this._test(type, limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!Hoek.isInteger(compareTo)) {\n                    return this.createError('string.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (compare(value, compareTo, encoding)) {\n                return value;\n            }\n\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\n        });\n    };\n};\n\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length >= limit;\n});\n\n\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length <= limit;\n});\n\n\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length === limit;\n});\n\n// Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\n\nmodule.exports = new internals.String();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/isemail/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Dns = require('dns');\n\n\n// Declare internals\n\nconst internals = {\n    hasOwn: Object.prototype.hasOwnProperty,\n    indexOf: Array.prototype.indexOf,\n    defaultThreshold: 16,\n    maxIPv6Groups: 8,\n\n    categories: {\n        valid: 1,\n        dnsWarn: 7,\n        rfc5321: 15,\n        cfws: 31,\n        deprecated: 63,\n        rfc5322: 127,\n        error: 255\n    },\n\n    diagnoses: {\n\n        // Address is valid\n\n        valid: 0,\n\n        // Address is valid, but the DNS check failed\n\n        dnsWarnNoMXRecord: 5,\n        dnsWarnNoRecord: 6,\n\n        // Address is valid for SMTP but has unusual elements\n\n        rfc5321TLD: 9,\n        rfc5321TLDNumeric: 10,\n        rfc5321QuotedString: 11,\n        rfc5321AddressLiteral: 12,\n\n        // Address is valid for message, but must be modified for envelope\n\n        cfwsComment: 17,\n        cfwsFWS: 18,\n\n        // Address contains deprecated elements, but may still be valid in some contexts\n\n        deprecatedLocalPart: 33,\n        deprecatedFWS: 34,\n        deprecatedQTEXT: 35,\n        deprecatedQP: 36,\n        deprecatedComment: 37,\n        deprecatedCTEXT: 38,\n        deprecatedIPv6: 39,\n        deprecatedCFWSNearAt: 49,\n\n        // Address is only valid according to broad definition in RFC 5322, but is otherwise invalid\n\n        rfc5322Domain: 65,\n        rfc5322TooLong: 66,\n        rfc5322LocalTooLong: 67,\n        rfc5322DomainTooLong: 68,\n        rfc5322LabelTooLong: 69,\n        rfc5322DomainLiteral: 70,\n        rfc5322DomainLiteralOBSDText: 71,\n        rfc5322IPv6GroupCount: 72,\n        rfc5322IPv62x2xColon: 73,\n        rfc5322IPv6BadCharacter: 74,\n        rfc5322IPv6MaxGroups: 75,\n        rfc5322IPv6ColonStart: 76,\n        rfc5322IPv6ColonEnd: 77,\n\n        // Address is invalid for any purpose\n\n        errExpectingDTEXT: 129,\n        errNoLocalPart: 130,\n        errNoDomain: 131,\n        errConsecutiveDots: 132,\n        errATEXTAfterCFWS: 133,\n        errATEXTAfterQS: 134,\n        errATEXTAfterDomainLiteral: 135,\n        errExpectingQPair: 136,\n        errExpectingATEXT: 137,\n        errExpectingQTEXT: 138,\n        errExpectingCTEXT: 139,\n        errBackslashEnd: 140,\n        errDotStart: 141,\n        errDotEnd: 142,\n        errDomainHyphenStart: 143,\n        errDomainHyphenEnd: 144,\n        errUnclosedQuotedString: 145,\n        errUnclosedComment: 146,\n        errUnclosedDomainLiteral: 147,\n        errFWSCRLFx2: 148,\n        errFWSCRLFEnd: 149,\n        errCRNoLF: 150,\n        errUnknownTLD: 160,\n        errDomainTooShort: 161\n    },\n\n    components: {\n        localpart: 0,\n        domain: 1,\n        literal: 2,\n        contextComment: 3,\n        contextFWS: 4,\n        contextQuotedString: 5,\n        contextQuotedPair: 6\n    }\n};\n\n\n// $lab:coverage:off$\ninternals.defer = typeof process !== 'undefined' && process && typeof process.nextTick === 'function' ?\n    process.nextTick.bind(process) :\n    function (callback) {\n\n        return setTimeout(callback, 0);\n    };\n// $lab:coverage:on$\n\n\ninternals.specials = function () {\n\n    const specials = '()<>[]:;@\\\\,.\"';        // US-ASCII visible characters not valid for atext (http://tools.ietf.org/html/rfc5322#section-3.2.3)\n    const lookup = new Array(0x100);\n    for (let i = 0xff; i >= 0; --i) {\n        lookup[i] = false;\n    }\n\n    for (let i = 0; i < specials.length; ++i) {\n        lookup[specials.charCodeAt(i)] = true;\n    }\n\n    return function (code) {\n\n        return lookup[code];\n    };\n}();\n\n\ninternals.regex = {\n    ipV4: /\\b(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n    ipV6: /^[a-fA-F\\d]{0,4}$/\n};\n\n\ninternals.checkIpV6 = function (items) {\n\n    return items.every((value) => internals.regex.ipV6.test(value));\n};\n\n\ninternals.validDomain = function (tldAtom, options) {\n\n    if (options.tldBlacklist) {\n        if (Array.isArray(options.tldBlacklist)) {\n            return internals.indexOf.call(options.tldBlacklist, tldAtom) === -1;\n        }\n\n        return !internals.hasOwn.call(options.tldBlacklist, tldAtom);\n    }\n\n    if (Array.isArray(options.tldWhitelist)) {\n        return internals.indexOf.call(options.tldWhitelist, tldAtom) !== -1;\n    }\n\n    return internals.hasOwn.call(options.tldWhitelist, tldAtom);\n};\n\n\n/**\n * Check that an email address conforms to RFCs 5321, 5322 and others\n *\n * We distinguish clearly between a Mailbox as defined by RFC 5321 and an\n * addr-spec as defined by RFC 5322. Depending on the context, either can be\n * regarded as a valid email address. The RFC 5321 Mailbox specification is\n * more restrictive (comments, white space and obsolete forms are not allowed).\n *\n * @param {string} email The email address to check. See README for specifics.\n * @param {Object} options The (optional) options:\n *   {boolean} checkDNS If true then will check DNS for MX records. If\n *     true this call to isEmail _will_ be asynchronous.\n *   {*} errorLevel Determines the boundary between valid and invalid\n *     addresses.\n *   {*} tldBlacklist The set of domains to consider invalid.\n *   {*} tldWhitelist The set of domains to consider valid.\n *   {*} minDomainAtoms The minimum number of domain atoms which must be present\n *     for the address to be valid.\n * @param {function(number|boolean)} callback The (optional) callback handler.\n * @return {*}\n */\n\nexports.validate = internals.validate = function (email, options, callback) {\n\n    options = options || {};\n\n    if (typeof options === 'function') {\n        callback = options;\n        options = {};\n    }\n\n    if (typeof callback !== 'function') {\n        if (options.checkDNS) {\n            throw new TypeError('expected callback function for checkDNS option');\n        }\n\n        callback = null;\n    }\n\n    let diagnose;\n    let threshold;\n\n    if (typeof options.errorLevel === 'number') {\n        diagnose = true;\n        threshold = options.errorLevel;\n    }\n    else {\n        diagnose = !!options.errorLevel;\n        threshold = internals.diagnoses.valid;\n    }\n\n    if (options.tldWhitelist) {\n        if (typeof options.tldWhitelist === 'string') {\n            options.tldWhitelist = [options.tldWhitelist];\n        }\n        else if (typeof options.tldWhitelist !== 'object') {\n            throw new TypeError('expected array or object tldWhitelist');\n        }\n    }\n\n    if (options.tldBlacklist) {\n        if (typeof options.tldBlacklist === 'string') {\n            options.tldBlacklist = [options.tldBlacklist];\n        }\n        else if (typeof options.tldBlacklist !== 'object') {\n            throw new TypeError('expected array or object tldBlacklist');\n        }\n    }\n\n    if (options.minDomainAtoms && (options.minDomainAtoms !== ((+options.minDomainAtoms) | 0) || options.minDomainAtoms < 0)) {\n        throw new TypeError('expected positive integer minDomainAtoms');\n    }\n\n    let maxResult = internals.diagnoses.valid;\n    const updateResult = (value) => {\n\n        if (value > maxResult) {\n            maxResult = value;\n        }\n    };\n\n    const context = {\n        now: internals.components.localpart,\n        prev: internals.components.localpart,\n        stack: [internals.components.localpart]\n    };\n\n    let prevToken = '';\n\n    const parseData = {\n        local: '',\n        domain: ''\n    };\n    const atomData = {\n        locals: [''],\n        domains: ['']\n    };\n\n    let elementCount = 0;\n    let elementLength = 0;\n    let crlfCount = 0;\n    let charCode;\n\n    let hyphenFlag = false;\n    let assertEnd = false;\n\n    const emailLength = email.length;\n\n    let token;                                      // Token is used outside the loop, must declare similarly\n    for (let i = 0; i < emailLength; ++i) {\n        token = email[i];\n\n        switch (context.now) {\n            // Local-part\n            case internals.components.localpart:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   local-part      =   dot-atom / quoted-string / obs-local-part\n                //\n                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n                //\n                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n                //\n                //   quoted-string   =   [CFWS]\n                //                       DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                //                       [CFWS]\n                //\n                //   obs-local-part  =   word *(\".\" word)\n                //\n                //   word            =   atom / quoted-string\n                //\n                //   atom            =   [CFWS] 1*atext [CFWS]\n                switch (token) {\n                    // Comment\n                    case '(':\n                        if (elementLength === 0) {\n                            // Comments are OK at the beginning of an element\n                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsComment : internals.diagnoses.deprecatedComment);\n                        }\n                        else {\n                            updateResult(internals.diagnoses.cfwsComment);\n                            // Cannot start a comment in an element, should be end\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // Next dot-atom element\n                    case '.':\n                        if (elementLength === 0) {\n                            // Another dot, already?\n                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n                        }\n                        else {\n                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n                            if (assertEnd) {\n                                updateResult(internals.diagnoses.deprecatedLocalPart);\n                            }\n\n                            // CFWS & quoted strings are OK again now we're at the beginning of an element (although they are obsolete forms)\n                            assertEnd = false;\n                            elementLength = 0;\n                            ++elementCount;\n                            parseData.local += token;\n                            atomData.locals[elementCount] = '';\n                        }\n\n                        break;\n\n                        // Quoted string\n                    case '\"':\n                        if (elementLength === 0) {\n                            // The entire local-part can be a quoted string for RFC 5321; if one atom is quoted it's an RFC 5322 obsolete form\n                            updateResult(elementCount === 0 ? internals.diagnoses.rfc5321QuotedString : internals.diagnoses.deprecatedLocalPart);\n\n                            parseData.local += token;\n                            atomData.locals[elementCount] += token;\n                            ++elementLength;\n\n                            // Quoted string must be the entire element\n                            assertEnd = true;\n                            context.stack.push(context.now);\n                            context.now = internals.components.contextQuotedString;\n                        }\n                        else {\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        if (elementLength === 0) {\n                            updateResult(elementCount === 0 ? internals.diagnoses.cfwsFWS : internals.diagnoses.deprecatedFWS);\n                        }\n                        else {\n                            // We can't start FWS in the middle of an element, better be end\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                    case '@':\n                        // At this point we should have a valid local-part\n                        // $lab:coverage:off$\n                        if (context.stack.length !== 1) {\n                            throw new Error('unexpected item on context stack');\n                        }\n                        // $lab:coverage:on$\n\n                        if (parseData.local.length === 0) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errNoLocalPart);\n                        }\n                        else if (elementLength === 0) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errDotEnd);\n                        }\n                            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1 the maximum total length of a user name or other local-part is 64\n                            //    octets\n                        else if (parseData.local.length > 64) {\n                            updateResult(internals.diagnoses.rfc5322LocalTooLong);\n                        }\n                            // http://tools.ietf.org/html/rfc5322#section-3.4.1 comments and folding white space SHOULD NOT be used around \"@\" in the\n                            //    addr-spec\n                            //\n                            // http://tools.ietf.org/html/rfc2119\n                            // 4. SHOULD NOT this phrase, or the phrase \"NOT RECOMMENDED\" mean that there may exist valid reasons in particular\n                            //    circumstances when the particular behavior is acceptable or even useful, but the full implications should be understood\n                            //    and the case carefully weighed before implementing any behavior described with this label.\n                        else if (context.prev === internals.components.contextComment || context.prev === internals.components.contextFWS) {\n                            updateResult(internals.diagnoses.deprecatedCFWSNearAt);\n                        }\n\n                        // Clear everything down for the domain parsing\n                        context.now = internals.components.domain;\n                        context.stack[0] = internals.components.domain;\n                        elementCount = 0;\n                        elementLength = 0;\n                        assertEnd = false; // CFWS can only appear at the end of the element\n                        break;\n\n                        // ATEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n                        //            \"!\" / \"#\" /     ;  characters not including\n                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n                        //            \"&\" / \"'\" /\n                        //            \"*\" / \"+\" /\n                        //            \"-\" / \"/\" /\n                        //            \"=\" / \"?\" /\n                        //            \"^\" / \"_\" /\n                        //            \"`\" / \"{\" /\n                        //            \"|\" / \"}\" /\n                        //            \"~\"\n                        if (assertEnd) {\n                            // We have encountered atext where it is no longer valid\n                            switch (context.prev) {\n                                case internals.components.contextComment:\n                                case internals.components.contextFWS:\n                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                                    break;\n\n                                case internals.components.contextQuotedString:\n                                    updateResult(internals.diagnoses.errATEXTAfterQS);\n                                    break;\n\n                                    // $lab:coverage:off$\n                                default:\n                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                                    // $lab:coverage:on$\n                            }\n                        }\n                        else {\n                            context.prev = context.now;\n                            charCode = token.charCodeAt(0);\n\n                            // Especially if charCode == 10\n                            if (charCode < 33 || charCode > 126 || internals.specials(charCode)) {\n\n                                // Fatal error\n                                updateResult(internals.diagnoses.errExpectingATEXT);\n                            }\n\n                            parseData.local += token;\n                            atomData.locals[elementCount] += token;\n                            ++elementLength;\n                        }\n                }\n\n                break;\n\n            case internals.components.domain:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   domain          =   dot-atom / domain-literal / obs-domain\n                //\n                //   dot-atom        =   [CFWS] dot-atom-text [CFWS]\n                //\n                //   dot-atom-text   =   1*atext *(\".\" 1*atext)\n                //\n                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n                //\n                //   dtext           =   %d33-90 /          ; Printable US-ASCII\n                //                       %d94-126 /         ;  characters not including\n                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n                //\n                //   obs-domain      =   atom *(\".\" atom)\n                //\n                //   atom            =   [CFWS] 1*atext [CFWS]\n\n                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                //   Mailbox        = Local-part \"@\" ( Domain / address-literal )\n                //\n                //   Domain         = sub-domain *(\".\" sub-domain)\n                //\n                //   address-literal  = \"[\" ( IPv4-address-literal /\n                //                    IPv6-address-literal /\n                //                    General-address-literal ) \"]\"\n                //                    ; See Section 4.1.3\n\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //      Note: A liberal syntax for the domain portion of addr-spec is\n                //      given here.  However, the domain portion contains addressing\n                //      information specified by and used in other protocols (e.g.,\n                //      [RFC1034], [RFC1035], [RFC1123], [RFC5321]).  It is therefore\n                //      incumbent upon implementations to conform to the syntax of\n                //      addresses for the context in which they are used.\n                //\n                // is_email() author's note: it's not clear how to interpret this in\n                // he context of a general email address validator. The conclusion I\n                // have reached is this: \"addressing information\" must comply with\n                // RFC 5321 (and in turn RFC 1035), anything that is \"semantically\n                // invisible\" must comply only with RFC 5322.\n                switch (token) {\n                    // Comment\n                    case '(':\n                        if (elementLength === 0) {\n                            // Comments at the start of the domain are deprecated in the text, comments at the start of a subdomain are obs-domain\n                            // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedComment);\n                        }\n                        else {\n                            // We can't start a comment mid-element, better be at the end\n                            assertEnd = true;\n                            updateResult(internals.diagnoses.cfwsComment);\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // Next dot-atom element\n                    case '.':\n                        if (elementLength === 0) {\n                            // Another dot, already? Fatal error.\n                            updateResult(elementCount === 0 ? internals.diagnoses.errDotStart : internals.diagnoses.errConsecutiveDots);\n                        }\n                        else if (hyphenFlag) {\n                            // Previous subdomain ended in a hyphen. Fatal error.\n                            updateResult(internals.diagnoses.errDomainHyphenEnd);\n                        }\n                        else if (elementLength > 63) {\n                            // Nowhere in RFC 5321 does it say explicitly that the domain part of a Mailbox must be a valid domain according to the\n                            // DNS standards set out in RFC 1035, but this *is* implied in several places. For instance, wherever the idea of host\n                            // routing is discussed the RFC says that the domain must be looked up in the DNS. This would be nonsense unless the\n                            // domain was designed to be a valid DNS domain. Hence we must conclude that the RFC 1035 restriction on label length\n                            // also applies to RFC 5321 domains.\n                            //\n                            // http://tools.ietf.org/html/rfc1035#section-2.3.4\n                            // labels          63 octets or less\n\n                            updateResult(internals.diagnoses.rfc5322LabelTooLong);\n                        }\n\n                        // CFWS is OK again now we're at the beginning of an element (although\n                        // it may be obsolete CFWS)\n                        assertEnd = false;\n                        elementLength = 0;\n                        ++elementCount;\n                        atomData.domains[elementCount] = '';\n                        parseData.domain += token;\n\n                        break;\n\n                        // Domain literal\n                    case '[':\n                        if (parseData.domain.length === 0) {\n                            // Domain literal must be the only component\n                            assertEnd = true;\n                            ++elementLength;\n                            context.stack.push(context.now);\n                            context.now = internals.components.literal;\n                            parseData.domain += token;\n                            atomData.domains[elementCount] += token;\n                            parseData.literal = '';\n                        }\n                        else {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        if (elementLength === 0) {\n                            updateResult(elementCount === 0 ? internals.diagnoses.deprecatedCFWSNearAt : internals.diagnoses.deprecatedFWS);\n                        }\n                        else {\n                            // We can't start FWS in the middle of an element, so this better be the end\n                            updateResult(internals.diagnoses.cfwsFWS);\n                            assertEnd = true;\n                        }\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // This must be ATEXT\n                    default:\n                        // RFC 5322 allows any atext...\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //    atext = ALPHA / DIGIT / ; Printable US-ASCII\n                        //            \"!\" / \"#\" /     ;  characters not including\n                        //            \"$\" / \"%\" /     ;  specials.  Used for atoms.\n                        //            \"&\" / \"'\" /\n                        //            \"*\" / \"+\" /\n                        //            \"-\" / \"/\" /\n                        //            \"=\" / \"?\" /\n                        //            \"^\" / \"_\" /\n                        //            \"`\" / \"{\" /\n                        //            \"|\" / \"}\" /\n                        //            \"~\"\n\n                        // But RFC 5321 only allows letter-digit-hyphen to comply with DNS rules\n                        //   (RFCs 1034 & 1123)\n                        // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                        //   sub-domain     = Let-dig [Ldh-str]\n                        //\n                        //   Let-dig        = ALPHA / DIGIT\n                        //\n                        //   Ldh-str        = *( ALPHA / DIGIT / \"-\" ) Let-dig\n                        //\n                        if (assertEnd) {\n                            // We have encountered ATEXT where it is no longer valid\n                            switch (context.prev) {\n                                case internals.components.contextComment:\n                                case internals.components.contextFWS:\n                                    updateResult(internals.diagnoses.errATEXTAfterCFWS);\n                                    break;\n\n                                case internals.components.literal:\n                                    updateResult(internals.diagnoses.errATEXTAfterDomainLiteral);\n                                    break;\n\n                                    // $lab:coverage:off$\n                                default:\n                                    throw new Error('more atext found where none is allowed, but unrecognized prev context: ' + context.prev);\n                                    // $lab:coverage:on$\n                            }\n                        }\n\n                        charCode = token.charCodeAt(0);\n                        // Assume this token isn't a hyphen unless we discover it is\n                        hyphenFlag = false;\n\n                        if (charCode < 33 || charCode > 126 || internals.specials(charCode)) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingATEXT);\n                        }\n                        else if (token === '-') {\n                            if (elementLength === 0) {\n                                // Hyphens cannot be at the beginning of a subdomain, fatal error\n                                updateResult(internals.diagnoses.errDomainHyphenStart);\n                            }\n\n                            hyphenFlag = true;\n                        }\n                            // Check if it's a neither a number nor a latin letter\n                        else if (charCode < 48 || charCode > 122 || (charCode > 57 && charCode < 65) || (charCode > 90 && charCode < 97)) {\n                            // This is not an RFC 5321 subdomain, but still OK by RFC 5322\n                            updateResult(internals.diagnoses.rfc5322Domain);\n                        }\n\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        ++elementLength;\n                }\n\n                break;\n\n                // Domain literal\n            case internals.components.literal:\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   domain-literal  =   [CFWS] \"[\" *([FWS] dtext) [FWS] \"]\" [CFWS]\n                //\n                //   dtext           =   %d33-90 /          ; Printable US-ASCII\n                //                       %d94-126 /         ;  characters not including\n                //                       obs-dtext          ;  \"[\", \"]\", or \"\\\"\n                //\n                //   obs-dtext       =   obs-NO-WS-CTL / quoted-pair\n                switch (token) {\n                    // End of domain literal\n                    case ']':\n                        if (maxResult < internals.categories.deprecated) {\n                            // Could be a valid RFC 5321 address literal, so let's check\n\n                            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                            //   address-literal  = \"[\" ( IPv4-address-literal /\n                            //                    IPv6-address-literal /\n                            //                    General-address-literal ) \"]\"\n                            //                    ; See Section 4.1.3\n                            //\n                            // http://tools.ietf.org/html/rfc5321#section-4.1.3\n                            //   IPv4-address-literal  = Snum 3(\".\"  Snum)\n                            //\n                            //   IPv6-address-literal  = \"IPv6:\" IPv6-addr\n                            //\n                            //   General-address-literal  = Standardized-tag \":\" 1*dcontent\n                            //\n                            //   Standardized-tag  = Ldh-str\n                            //                     ; Standardized-tag MUST be specified in a\n                            //                     ; Standards-Track RFC and registered with IANA\n                            //\n                            //   dcontent      = %d33-90 / ; Printable US-ASCII\n                            //                 %d94-126 ; excl. \"[\", \"\\\", \"]\"\n                            //\n                            //   Snum          = 1*3DIGIT\n                            //                 ; representing a decimal integer\n                            //                 ; value in the range 0 through 255\n                            //\n                            //   IPv6-addr     = IPv6-full / IPv6-comp / IPv6v4-full / IPv6v4-comp\n                            //\n                            //   IPv6-hex      = 1*4HEXDIG\n                            //\n                            //   IPv6-full     = IPv6-hex 7(\":\" IPv6-hex)\n                            //\n                            //   IPv6-comp     = [IPv6-hex *5(\":\" IPv6-hex)] \"::\"\n                            //                 [IPv6-hex *5(\":\" IPv6-hex)]\n                            //                 ; The \"::\" represents at least 2 16-bit groups of\n                            //                 ; zeros.  No more than 6 groups in addition to the\n                            //                 ; \"::\" may be present.\n                            //\n                            //   IPv6v4-full   = IPv6-hex 5(\":\" IPv6-hex) \":\" IPv4-address-literal\n                            //\n                            //   IPv6v4-comp   = [IPv6-hex *3(\":\" IPv6-hex)] \"::\"\n                            //                 [IPv6-hex *3(\":\" IPv6-hex) \":\"]\n                            //                 IPv4-address-literal\n                            //                 ; The \"::\" represents at least 2 16-bit groups of\n                            //                 ; zeros.  No more than 4 groups in addition to the\n                            //                 ; \"::\" and IPv4-address-literal may be present.\n\n                            let index = -1;\n                            let addressLiteral = parseData.literal;\n                            const matchesIP = internals.regex.ipV4.exec(addressLiteral);\n\n                            // Maybe extract IPv4 part from the end of the address-literal\n                            if (matchesIP) {\n                                index = matchesIP.index;\n                                if (index !== 0) {\n                                    // Convert IPv4 part to IPv6 format for futher testing\n                                    addressLiteral = addressLiteral.slice(0, index) + '0:0';\n                                }\n                            }\n\n                            if (index === 0) {\n                                // Nothing there except a valid IPv4 address, so...\n                                updateResult(internals.diagnoses.rfc5321AddressLiteral);\n                            }\n                            else if (addressLiteral.slice(0, 5).toLowerCase() !== 'ipv6:') {\n                                updateResult(internals.diagnoses.rfc5322DomainLiteral);\n                            }\n                            else {\n                                const match = addressLiteral.slice(5);\n                                let maxGroups = internals.maxIPv6Groups;\n                                const groups = match.split(':');\n                                index = match.indexOf('::');\n\n                                if (!~index) {\n                                    // Need exactly the right number of groups\n                                    if (groups.length !== maxGroups) {\n                                        updateResult(internals.diagnoses.rfc5322IPv6GroupCount);\n                                    }\n                                }\n                                else if (index !== match.lastIndexOf('::')) {\n                                    updateResult(internals.diagnoses.rfc5322IPv62x2xColon);\n                                }\n                                else {\n                                    if (index === 0 || index === match.length - 2) {\n                                        // RFC 4291 allows :: at the start or end of an address with 7 other groups in addition\n                                        ++maxGroups;\n                                    }\n\n                                    if (groups.length > maxGroups) {\n                                        updateResult(internals.diagnoses.rfc5322IPv6MaxGroups);\n                                    }\n                                    else if (groups.length === maxGroups) {\n                                        // Eliding a single \"::\"\n                                        updateResult(internals.diagnoses.deprecatedIPv6);\n                                    }\n                                }\n\n                                // IPv6 testing strategy\n                                if (match[0] === ':' && match[1] !== ':') {\n                                    updateResult(internals.diagnoses.rfc5322IPv6ColonStart);\n                                }\n                                else if (match[match.length - 1] === ':' && match[match.length - 2] !== ':') {\n                                    updateResult(internals.diagnoses.rfc5322IPv6ColonEnd);\n                                }\n                                else if (internals.checkIpV6(groups)) {\n                                    updateResult(internals.diagnoses.rfc5321AddressLiteral);\n                                }\n                                else {\n                                    updateResult(internals.diagnoses.rfc5322IPv6BadCharacter);\n                                }\n                            }\n                        }\n                        else {\n                            updateResult(internals.diagnoses.rfc5322DomainLiteral);\n                        }\n\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        ++elementLength;\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                    case '\\\\':\n                        updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        updateResult(internals.diagnoses.cfwsFWS);\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // DTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                        //   dtext         =   %d33-90 /  ; Printable US-ASCII\n                        //                     %d94-126 / ;  characters not including\n                        //                     obs-dtext  ;  \"[\", \"]\", or \"\\\"\n                        //\n                        //   obs-dtext     =   obs-NO-WS-CTL / quoted-pair\n                        //\n                        //   obs-NO-WS-CTL =   %d1-8 /    ; US-ASCII control\n                        //                     %d11 /     ;  characters that do not\n                        //                     %d12 /     ;  include the carriage\n                        //                     %d14-31 /  ;  return, line feed, and\n                        //                     %d127      ;  white space characters\n                        charCode = token.charCodeAt(0);\n\n                        // '\\r', '\\n', ' ', and '\\t' have already been parsed above\n                        if (charCode > 127 || charCode === 0 || token === '[') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingDTEXT);\n                            break;\n                        }\n                        else if (charCode < 33 || charCode === 127) {\n                            updateResult(internals.diagnoses.rfc5322DomainLiteralOBSDText);\n                        }\n\n                        parseData.literal += token;\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n                        ++elementLength;\n                }\n\n                break;\n\n                // Quoted string\n            case internals.components.contextQuotedString:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                //   quoted-string = [CFWS]\n                //                   DQUOTE *([FWS] qcontent) [FWS] DQUOTE\n                //                   [CFWS]\n                //\n                //   qcontent      = qtext / quoted-pair\n                switch (token) {\n                    // Quoted pair\n                    case '\\\\':\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space. Spaces are allowed as regular characters inside a quoted string - it's only FWS if we include '\\t' or '\\r\\n'\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case '\\t':\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                        //   Runs of FWS, comment, or CFWS that occur between lexical tokens in\n                        //   a structured header field are semantically interpreted as a single\n                        //   space character.\n\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                        //   the CRLF in any FWS/CFWS that appears within the quoted-string [is]\n                        //   semantically \"invisible\" and therefore not part of the\n                        //   quoted-string\n\n                        parseData.local += ' ';\n                        atomData.locals[elementCount] += ' ';\n                        ++elementLength;\n\n                        updateResult(internals.diagnoses.cfwsFWS);\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // End of quoted string\n                    case '\"':\n                        parseData.local += token;\n                        atomData.locals[elementCount] += token;\n                        ++elementLength;\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                        // QTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.4\n                        //   qtext          =   %d33 /             ; Printable US-ASCII\n                        //                      %d35-91 /          ;  characters not including\n                        //                      %d93-126 /         ;  \"\\\" or the quote character\n                        //                      obs-qtext\n                        //\n                        //   obs-qtext      =   obs-NO-WS-CTL\n                        //\n                        //   obs-NO-WS-CTL  =   %d1-8 /            ; US-ASCII control\n                        //                      %d11 /             ;  characters that do not\n                        //                      %d12 /             ;  include the carriage\n                        //                      %d14-31 /          ;  return, line feed, and\n                        //                      %d127              ;  white space characters\n                        charCode = token.charCodeAt(0);\n\n                        if (charCode > 127 || charCode === 0 || charCode === 10) {\n                            updateResult(internals.diagnoses.errExpectingQTEXT);\n                        }\n                        else if (charCode < 32 || charCode === 127) {\n                            updateResult(internals.diagnoses.deprecatedQTEXT);\n                        }\n\n                        parseData.local += token;\n                        atomData.locals[elementCount] += token;\n                        ++elementLength;\n                }\n\n                // http://tools.ietf.org/html/rfc5322#section-3.4.1\n                //   If the string can be represented as a dot-atom (that is, it contains\n                //   no characters other than atext characters or \".\" surrounded by atext\n                //   characters), then the dot-atom form SHOULD be used and the quoted-\n                //   string form SHOULD NOT be used.\n\n                break;\n                // Quoted pair\n            case internals.components.contextQuotedPair:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.1\n                //   quoted-pair     =   (\"\\\" (VCHAR / WSP)) / obs-qp\n                //\n                //   VCHAR           =  %d33-126   ; visible (printing) characters\n                //   WSP             =  SP / HTAB  ; white space\n                //\n                //   obs-qp          =   \"\\\" (%d0 / obs-NO-WS-CTL / LF / CR)\n                //\n                //   obs-NO-WS-CTL   =   %d1-8 /   ; US-ASCII control\n                //                       %d11 /    ;  characters that do not\n                //                       %d12 /    ;  include the carriage\n                //                       %d14-31 / ;  return, line feed, and\n                //                       %d127     ;  white space characters\n                //\n                // i.e. obs-qp       =  \"\\\" (%d0-8, %d10-31 / %d127)\n                charCode = token.charCodeAt(0);\n\n                if (charCode > 127) {\n                    // Fatal error\n                    updateResult(internals.diagnoses.errExpectingQPair);\n                }\n                else if ((charCode < 31 && charCode !== 9) || charCode === 127) {\n                    // ' ' and '\\t' are allowed\n                    updateResult(internals.diagnoses.deprecatedQP);\n                }\n\n                // At this point we know where this qpair occurred so we could check to see if the character actually needed to be quoted at all.\n                // http://tools.ietf.org/html/rfc5321#section-4.1.2\n                //   the sending system SHOULD transmit the form that uses the minimum quoting possible.\n\n                context.prev = context.now;\n                // End of qpair\n                context.now = context.stack.pop();\n                token = '\\\\' + token;\n\n                switch (context.now) {\n                    case internals.components.contextComment:\n                        break;\n\n                    case internals.components.contextQuotedString:\n                        parseData.local += token;\n                        atomData.locals[elementCount] += token;\n\n                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n                        elementLength += 2;\n                        break;\n\n                    case internals.components.literal:\n                        parseData.domain += token;\n                        atomData.domains[elementCount] += token;\n\n                        // The maximum sizes specified by RFC 5321 are octet counts, so we must include the backslash\n                        elementLength += 2;\n                        break;\n\n                        // $lab:coverage:off$\n                    default:\n                        throw new Error('quoted pair logic invoked in an invalid context: ' + context.now);\n                        // $lab:coverage:on$\n                }\n                break;\n\n                // Comment\n            case internals.components.contextComment:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                //   comment  = \"(\" *([FWS] ccontent) [FWS] \")\"\n                //\n                //   ccontent = ctext / quoted-pair / comment\n                switch (token) {\n                    // Nested comment\n                    case '(':\n                        // Nested comments are ok\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextComment;\n                        break;\n\n                        // End of comment\n                    case ')':\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n                        break;\n\n                        // Quoted pair\n                    case '\\\\':\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextQuotedPair;\n                        break;\n\n                        // Folding white space\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                            break;\n                        }\n\n                        // Fallthrough\n\n                    case ' ':\n                    case '\\t':\n                        updateResult(internals.diagnoses.cfwsFWS);\n\n                        context.stack.push(context.now);\n                        context.now = internals.components.contextFWS;\n                        prevToken = token;\n                        break;\n\n                        // CTEXT\n                    default:\n                        // http://tools.ietf.org/html/rfc5322#section-3.2.3\n                        //   ctext         = %d33-39 /  ; Printable US-ASCII\n                        //                   %d42-91 /  ;  characters not including\n                        //                   %d93-126 / ;  \"(\", \")\", or \"\\\"\n                        //                   obs-ctext\n                        //\n                        //   obs-ctext     = obs-NO-WS-CTL\n                        //\n                        //   obs-NO-WS-CTL = %d1-8 /    ; US-ASCII control\n                        //                   %d11 /     ;  characters that do not\n                        //                   %d12 /     ;  include the carriage\n                        //                   %d14-31 /  ;  return, line feed, and\n                        //                   %d127      ;  white space characters\n                        charCode = token.charCodeAt(0);\n\n                        if (charCode > 127 || charCode === 0 || charCode === 10) {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errExpectingCTEXT);\n                            break;\n                        }\n                        else if (charCode < 32 || charCode === 127) {\n                            updateResult(internals.diagnoses.deprecatedCTEXT);\n                        }\n                }\n\n                break;\n\n                // Folding white space\n            case internals.components.contextFWS:\n                // http://tools.ietf.org/html/rfc5322#section-3.2.2\n                //   FWS     =   ([*WSP CRLF] 1*WSP) /  obs-FWS\n                //                                   ; Folding white space\n\n                // But note the erratum:\n                // http://www.rfc-editor.org/errata_search.php?rfc=5322&eid=1908:\n                //   In the obsolete syntax, any amount of folding white space MAY be\n                //   inserted where the obs-FWS rule is allowed.  This creates the\n                //   possibility of having two consecutive \"folds\" in a line, and\n                //   therefore the possibility that a line which makes up a folded header\n                //   field could be composed entirely of white space.\n                //\n                //   obs-FWS =   1*([CRLF] WSP)\n\n                if (prevToken === '\\r') {\n                    if (token === '\\r') {\n                        // Fatal error\n                        updateResult(internals.diagnoses.errFWSCRLFx2);\n                        break;\n                    }\n\n                    if (++crlfCount > 1) {\n                        // Multiple folds => obsolete FWS\n                        updateResult(internals.diagnoses.deprecatedFWS);\n                    }\n                    else {\n                        crlfCount = 1;\n                    }\n                }\n\n                switch (token) {\n                    case '\\r':\n                        if (emailLength === ++i || email[i] !== '\\n') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errCRNoLF);\n                        }\n\n                        break;\n\n                    case ' ':\n                    case '\\t':\n                        break;\n\n                    default:\n                        if (prevToken === '\\r') {\n                            // Fatal error\n                            updateResult(internals.diagnoses.errFWSCRLFEnd);\n                        }\n\n                        crlfCount = 0;\n\n                        // End of FWS\n                        context.prev = context.now;\n                        context.now = context.stack.pop();\n\n                        // Look at this token again in the parent context\n                        --i;\n                }\n\n                prevToken = token;\n                break;\n\n                // Unexpected context\n                // $lab:coverage:off$\n            default:\n                throw new Error('unknown context: ' + context.now);\n                // $lab:coverage:on$\n        } // Primary state machine\n\n        if (maxResult > internals.categories.rfc5322) {\n            // Fatal error, no point continuing\n            break;\n        }\n    } // Token loop\n\n    // Check for errors\n    if (maxResult < internals.categories.rfc5322) {\n        // Fatal errors\n        if (context.now === internals.components.contextQuotedString) {\n            updateResult(internals.diagnoses.errUnclosedQuotedString);\n        }\n        else if (context.now === internals.components.contextQuotedPair) {\n            updateResult(internals.diagnoses.errBackslashEnd);\n        }\n        else if (context.now === internals.components.contextComment) {\n            updateResult(internals.diagnoses.errUnclosedComment);\n        }\n        else if (context.now === internals.components.literal) {\n            updateResult(internals.diagnoses.errUnclosedDomainLiteral);\n        }\n        else if (token === '\\r') {\n            updateResult(internals.diagnoses.errFWSCRLFEnd);\n        }\n        else if (parseData.domain.length === 0) {\n            updateResult(internals.diagnoses.errNoDomain);\n        }\n        else if (elementLength === 0) {\n            updateResult(internals.diagnoses.errDotEnd);\n        }\n        else if (hyphenFlag) {\n            updateResult(internals.diagnoses.errDomainHyphenEnd);\n        }\n\n            // Other errors\n        else if (parseData.domain.length > 255) {\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.2\n            //   The maximum total length of a domain name or number is 255 octets.\n            updateResult(internals.diagnoses.rfc5322DomainTooLong);\n        }\n        else if (parseData.local.length + parseData.domain.length + /* '@' */ 1 > 254) {\n            // http://tools.ietf.org/html/rfc5321#section-4.1.2\n            //   Forward-path   = Path\n            //\n            //   Path           = \"<\" [ A-d-l \":\" ] Mailbox \">\"\n            //\n            // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n            //   The maximum total length of a reverse-path or forward-path is 256 octets (including the punctuation and element separators).\n            //\n            // Thus, even without (obsolete) routing information, the Mailbox can only be 254 characters long. This is confirmed by this verified\n            // erratum to RFC 3696:\n            //\n            // http://www.rfc-editor.org/errata_search.php?rfc=3696&eid=1690\n            //   However, there is a restriction in RFC 2821 on the length of an address in MAIL and RCPT commands of 254 characters.  Since\n            //   addresses that do not fit in those fields are not normally useful, the upper limit on address lengths should normally be considered\n            //   to be 254.\n            updateResult(internals.diagnoses.rfc5322TooLong);\n        }\n        else if (elementLength > 63) {\n            // http://tools.ietf.org/html/rfc1035#section-2.3.4\n            // labels   63 octets or less\n            updateResult(internals.diagnoses.rfc5322LabelTooLong);\n        }\n        else if (options.minDomainAtoms && atomData.domains.length < options.minDomainAtoms) {\n            updateResult(internals.diagnoses.errDomainTooShort);\n        }\n        else if (options.tldWhitelist || options.tldBlacklist) {\n            const tldAtom = atomData.domains[elementCount];\n\n            if (!internals.validDomain(tldAtom, options)) {\n                updateResult(internals.diagnoses.errUnknownTLD);\n            }\n        }\n    } // Check for errors\n\n    let dnsPositive = false;\n    let finishImmediately = false;\n\n    const finish = () => {\n\n        if (!dnsPositive && maxResult < internals.categories.dnsWarn) {\n            // Per RFC 5321, domain atoms are limited to letter-digit-hyphen, so we only need to check code <= 57 to check for a digit\n            const code = atomData.domains[elementCount].charCodeAt(0);\n            if (code <= 57) {\n                updateResult(internals.diagnoses.rfc5321TLDNumeric);\n            }\n            else if (elementCount === 0) {\n                updateResult(internals.diagnoses.rfc5321TLD);\n            }\n        }\n\n        if (maxResult < threshold) {\n            maxResult = internals.diagnoses.valid;\n        }\n\n        const finishResult = diagnose ? maxResult : maxResult < internals.defaultThreshold;\n\n        if (callback) {\n            if (finishImmediately) {\n                callback(finishResult);\n            }\n            else {\n                internals.defer(callback.bind(null, finishResult));\n            }\n        }\n\n        return finishResult;\n    }; // Finish\n\n    if (options.checkDNS && maxResult < internals.categories.dnsWarn) {\n        // http://tools.ietf.org/html/rfc5321#section-2.3.5\n        //   Names that can be resolved to MX RRs or address (i.e., A or AAAA) RRs (as discussed in Section 5) are permitted, as are CNAME RRs whose\n        //   targets can be resolved, in turn, to MX or address RRs.\n        //\n        // http://tools.ietf.org/html/rfc5321#section-5.1\n        //   The lookup first attempts to locate an MX record associated with the name.  If a CNAME record is found, the resulting name is processed\n        //   as if it were the initial name. ... If an empty list of MXs is returned, the address is treated as if it was associated with an implicit\n        //   MX RR, with a preference of 0, pointing to that host.\n        //\n        // isEmail() author's note: We will regard the existence of a CNAME to be sufficient evidence of the domain's existence. For performance\n        // reasons we will not repeat the DNS lookup for the CNAME's target, but we will raise a warning because we didn't immediately find an MX\n        // record.\n        if (elementCount === 0) {\n            // Checking TLD DNS only works if you explicitly check from the root\n            parseData.domain += '.';\n        }\n\n        const dnsDomain = parseData.domain;\n        Dns.resolveMx(dnsDomain, (err, mxRecords) => {\n\n            // If we have a fatal error, then we must assume that there are no records\n            if (err && err.code !== Dns.NODATA) {\n                updateResult(internals.diagnoses.dnsWarnNoRecord);\n                return finish();\n            }\n\n            if (mxRecords && mxRecords.length) {\n                dnsPositive = true;\n                return finish();\n            }\n\n            let count = 3;\n            let done = false;\n            updateResult(internals.diagnoses.dnsWarnNoMXRecord);\n\n            const handleRecords = (ignoreError, records) => {\n\n                if (done) {\n                    return;\n                }\n\n                --count;\n\n                if (records && records.length) {\n                    done = true;\n                    return finish();\n                }\n\n                if (count === 0) {\n                    // No usable records for the domain can be found\n                    updateResult(internals.diagnoses.dnsWarnNoRecord);\n                    done = true;\n                    finish();\n                }\n            };\n\n            Dns.resolveCname(dnsDomain, handleRecords);\n            Dns.resolve4(dnsDomain, handleRecords);\n            Dns.resolve6(dnsDomain, handleRecords);\n        });\n\n        finishImmediately = true;\n    }\n    else {\n        const result = finish();\n        finishImmediately = true;\n        return result;\n    } // CheckDNS\n};\n\n\nexports.diagnoses = internals.validate.diagnoses = (function () {\n\n    const diag = {};\n    const keys = Object.keys(internals.diagnoses);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        diag[key] = internals.diagnoses[key];\n    }\n\n    return diag;\n})();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/string/uri.js":"'use strict';\n\n// Load Modules\n\nconst RFC3986 = require('./rfc3986');\n\n\n// Declare internals\n\nconst internals = {\n    Uri: {\n        createUriRegex: function (optionalScheme, allowRelative, relativeOnly) {\n\n            let scheme = RFC3986.scheme;\n            let prefix;\n\n            if (relativeOnly) {\n                prefix = '(?:' + RFC3986.relativeRef + ')';\n            }\n            else {\n                // If we were passed a scheme, use it instead of the generic one\n                if (optionalScheme) {\n\n                    // Have to put this in a non-capturing group to handle the OR statements\n                    scheme = '(?:' + optionalScheme + ')';\n                }\n\n                const withScheme = '(?:' + scheme + ':' + RFC3986.hierPart + ')';\n\n                prefix = allowRelative ? '(?:' + withScheme + '|' + RFC3986.relativeRef + ')' : withScheme;\n            }\n\n            /**\n             * URI = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n             *\n             * OR\n             *\n             * relative-ref = relative-part [ \"?\" query ] [ \"#\" fragment ]\n             */\n            return new RegExp('^' + prefix + '(?:\\\\?' + RFC3986.query + ')?' + '(?:#' + RFC3986.fragment + ')?$');\n        }\n    }\n};\n\n\nmodule.exports = internals.Uri;\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/string/rfc3986.js":"'use strict';\n\n// Load modules\n\n\n// Delcare internals\n\nconst internals = {\n    rfc3986: {}\n};\n\n\ninternals.generate = function () {\n\n    /**\n     * elements separated by forward slash (\"/\") are alternatives.\n     */\n    const or = '|';\n\n    /**\n     * DIGIT = %x30-39 ; 0-9\n     */\n    const digit = '0-9';\n    const digitOnly = '[' + digit + ']';\n\n    /**\n     * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z\n     */\n    const alpha = 'a-zA-Z';\n    const alphaOnly = '[' + alpha + ']';\n\n    /**\n     * cidr       = DIGIT                ; 0-9\n     *            / %x31-32 DIGIT         ; 10-29\n     *            / \"3\" %x30-32           ; 30-32\n     */\n    internals.rfc3986.cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';\n\n    /**\n     * HEXDIG = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\n     */\n    const hexDigit = digit + 'A-Fa-f';\n    const hexDigitOnly = '[' + hexDigit + ']';\n\n    /**\n     * unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n     */\n    const unreserved = alpha + digit + '-\\\\._~';\n\n    /**\n     * sub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n     */\n    const subDelims = '!\\\\$&\\'\\\\(\\\\)\\\\*\\\\+,;=';\n\n    /**\n     * pct-encoded = \"%\" HEXDIG HEXDIG\n     */\n    const pctEncoded = '%' + hexDigit;\n\n    /**\n     * pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n     */\n    const pchar = unreserved + pctEncoded + subDelims + ':@';\n    const pcharOnly = '[' + pchar + ']';\n\n    /**\n     * Rule to support zero-padded addresses.\n     */\n    const zeroPad = '0?';\n\n    /**\n     * dec-octet   = DIGIT                 ; 0-9\n     *            / %x31-39 DIGIT         ; 10-99\n     *            / \"1\" 2DIGIT            ; 100-199\n     *            / \"2\" %x30-34 DIGIT     ; 200-249\n     *            / \"25\" %x30-35          ; 250-255\n     */\n    const decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';\n\n    /**\n     * IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\n     */\n    internals.rfc3986.IPv4address = '(?:' + decOctect + '\\\\.){3}' + decOctect;\n\n    /**\n     * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal\n     * ls32 = ( h16 \":\" h16 ) / IPv4address ; least-significant 32 bits of address\n     * IPv6address =                            6( h16 \":\" ) ls32\n     *             /                       \"::\" 5( h16 \":\" ) ls32\n     *             / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n     *             / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n     *             / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n     *             / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n     *             / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n     *             / [ *5( h16 \":\" ) h16 ] \"::\"              h16\n     *             / [ *6( h16 \":\" ) h16 ] \"::\"\n     */\n    const h16 = hexDigitOnly + '{1,4}';\n    const ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';\n    const IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;\n    const IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;\n    const IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;\n    const IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;\n    const IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;\n    const IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;\n    const IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;\n    const IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;\n    const IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';\n    internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';\n\n    /**\n     * IPvFuture = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\n     */\n    internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\\\.[' + unreserved + subDelims + ':]+';\n\n    /**\n     * scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n     */\n    internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\\\.]*';\n\n    /**\n     * userinfo = *( unreserved / pct-encoded / sub-delims / \":\" )\n     */\n    const userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';\n\n    /**\n     * IP-literal = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n     */\n    const IPLiteral = '\\\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\\\]';\n\n    /**\n     * reg-name = *( unreserved / pct-encoded / sub-delims )\n     */\n    const regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';\n\n    /**\n     * host = IP-literal / IPv4address / reg-name\n     */\n    const host = '(?:' + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';\n\n    /**\n     * port = *DIGIT\n     */\n    const port = digitOnly + '*';\n\n    /**\n     * authority   = [ userinfo \"@\" ] host [ \":\" port ]\n     */\n    const authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';\n\n    /**\n     * segment       = *pchar\n     * segment-nz    = 1*pchar\n     * path          = path-abempty    ; begins with \"/\" or is empty\n     *               / path-absolute   ; begins with \"/\" but not \"//\"\n     *               / path-noscheme   ; begins with a non-colon segment\n     *               / path-rootless   ; begins with a segment\n     *               / path-empty      ; zero characters\n     * path-abempty  = *( \"/\" segment )\n     * path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\n     * path-rootless = segment-nz *( \"/\" segment )\n     */\n    const segment = pcharOnly + '*';\n    const segmentNz = pcharOnly + '+';\n    const segmentNzNc = '[' + unreserved + pctEncoded + subDelims + '@' + ']+';\n    const pathEmpty = '';\n    const pathAbEmpty = '(?:\\\\/' + segment + ')*';\n    const pathAbsolute = '\\\\/(?:' + segmentNz + pathAbEmpty + ')?';\n    const pathRootless = segmentNz + pathAbEmpty;\n    const pathNoScheme = segmentNzNc + pathAbEmpty;\n\n    /**\n     * hier-part = \"//\" authority path\n     */\n    internals.rfc3986.hierPart = '(?:' + '(?:\\\\/\\\\/' + authority + pathAbEmpty + ')' + or + pathAbsolute + or + pathRootless + ')';\n\n    /**\n     * relative-part = \"//\" authority path-abempty\n     *                 / path-absolute\n     *                 / path-noscheme\n     *                 / path-empty\n     */\n    internals.rfc3986.relativeRef = '(?:' + '(?:\\\\/\\\\/' + authority + pathAbEmpty  + ')' + or + pathAbsolute + or + pathNoScheme + or + pathEmpty + ')';\n\n    /**\n     * query = *( pchar / \"/\" / \"?\" )\n     */\n    internals.rfc3986.query = '[' + pchar + '\\\\/\\\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.\n\n    /**\n     * fragment = *( pchar / \"/\" / \"?\" )\n     */\n    internals.rfc3986.fragment = '[' + pchar + '\\\\/\\\\?]*';\n};\n\n\ninternals.generate();\n\nmodule.exports = internals.rfc3986;\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/string/ip.js":"'use strict';\n\n// Load modules\n\nconst RFC3986 = require('./rfc3986');\n\n\n// Declare internals\n\nconst internals = {\n    Ip: {\n        cidrs: {\n            required: '\\\\/(?:' + RFC3986.cidr + ')',\n            optional: '(?:\\\\/(?:' + RFC3986.cidr + '))?',\n            forbidden: ''\n        },\n        versions: {\n            ipv4: RFC3986.IPv4address,\n            ipv6: RFC3986.IPv6address,\n            ipvfuture: RFC3986.IPvFuture\n        }\n    }\n};\n\n\ninternals.Ip.createIpRegex = function (versions, cidr) {\n\n    let regex;\n    for (let i = 0; i < versions.length; ++i) {\n        const version = versions[i];\n        if (!regex) {\n            regex = '^(?:' + internals.Ip.versions[version];\n        }\n        regex = regex + '|' + internals.Ip.versions[version];\n    }\n\n    return new RegExp(regex + ')' + internals.Ip.cidrs[cidr] + '$');\n};\n\nmodule.exports = internals.Ip;\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/number.js":"'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Ref = require('./ref');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {\n    precisionRx: /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/\n};\n\n\ninternals.Number = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'number';\n        this._invalids.add(Infinity);\n        this._invalids.add(-Infinity);\n    }\n\n    _base(value, state, options) {\n\n        const result = {\n            errors: null,\n            value\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            const number = parseFloat(value);\n            result.value = (isNaN(number) || !isFinite(value)) ? NaN : number;\n        }\n\n        const isNumber = typeof result.value === 'number' && !isNaN(result.value);\n\n        if (options.convert && 'precision' in this._flags && isNumber) {\n\n            // This is conceptually equivalent to using toFixed but it should be much faster\n            const precision = Math.pow(10, this._flags.precision);\n            result.value = Math.round(result.value * precision) / precision;\n        }\n\n        result.errors = isNumber ? null : this.createError('number.base', null, state, options);\n        return result;\n    }\n\n    multiple(base) {\n\n        const isRef = Ref.isRef(base);\n\n        if (!isRef) {\n            Hoek.assert(typeof base === 'number' && isFinite(base), 'multiple must be a number');\n            Hoek.assert(base > 0, 'multiple must be greater than 0');\n        }\n\n        return this._test('multiple', base, function (value, state, options) {\n\n            const divisor = isRef ? base(state.reference || state.parent, options) : base;\n\n            if (isRef && (typeof divisor !== 'number' || !isFinite(divisor))) {\n                return this.createError('number.ref', { ref: base.key }, state, options);\n            }\n\n            if (value % divisor === 0) {\n                return value;\n            }\n\n            return this.createError('number.multiple', { multiple: base, value }, state, options);\n        });\n    }\n\n    integer() {\n\n        return this._test('integer', undefined, function (value, state, options) {\n\n            return Hoek.isInteger(value) ? value : this.createError('number.integer', { value }, state, options);\n        });\n    }\n\n    negative() {\n\n        return this._test('negative', undefined, function (value, state, options) {\n\n            if (value < 0) {\n                return value;\n            }\n\n            return this.createError('number.negative', { value }, state, options);\n        });\n    }\n\n    positive() {\n\n        return this._test('positive', undefined, function (value, state, options) {\n\n            if (value > 0) {\n                return value;\n            }\n\n            return this.createError('number.positive', { value }, state, options);\n        });\n    }\n\n    precision(limit) {\n\n        Hoek.assert(Hoek.isInteger(limit), 'limit must be an integer');\n        Hoek.assert(!('precision' in this._flags), 'precision already set');\n\n        const obj = this._test('precision', limit, function (value, state, options) {\n\n            const places = value.toString().match(internals.precisionRx);\n            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);\n            if (decimals <= limit) {\n                return value;\n            }\n\n            return this.createError('number.precision', { limit, value }, state, options);\n        });\n\n        obj._flags.precision = limit;\n        return obj;\n    }\n\n};\n\n\ninternals.compare = function (type, compare) {\n\n    return function (limit) {\n\n        const isRef = Ref.isRef(limit);\n        const isNumber = typeof limit === 'number' && !isNaN(limit);\n\n        Hoek.assert(isNumber || isRef, 'limit must be a number or reference');\n\n        return this._test(type, limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {\n                    return this.createError('number.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (compare(value, compareTo)) {\n                return value;\n            }\n\n            return this.createError('number.' + type, { limit: compareTo, value }, state, options);\n        });\n    };\n};\n\n\ninternals.Number.prototype.min = internals.compare('min', (value, limit) => value >= limit);\ninternals.Number.prototype.max = internals.compare('max', (value, limit) => value <= limit);\ninternals.Number.prototype.greater = internals.compare('greater', (value, limit) => value > limit);\ninternals.Number.prototype.less = internals.compare('less', (value, limit) => value < limit);\n\n\nmodule.exports = new internals.Number();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/boolean.js":"'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {\n    Set: require('./set')\n};\n\n\ninternals.Boolean = class extends Any {\n    constructor() {\n\n        super();\n        this._type = 'boolean';\n        this._flags.insensitive = true;\n        this._inner.truthySet = new internals.Set();\n        this._inner.falsySet = new internals.Set();\n    }\n\n    _base(value, state, options) {\n\n        const result = {\n            value\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            const normalized = this._flags.insensitive ? value.toLowerCase() : value;\n            result.value = (normalized === 'true' ? true\n                : (normalized === 'false' ? false : value));\n        }\n\n        if (typeof result.value !== 'boolean') {\n            result.value = (this._inner.truthySet.has(value, null, null, this._flags.insensitive) ? true\n                : (this._inner.falsySet.has(value, null, null, this._flags.insensitive) ? false : value));\n        }\n\n        result.errors = (typeof result.value === 'boolean') ? null : this.createError('boolean.base', null, state, options);\n        return result;\n    }\n\n    truthy() {\n\n        const obj = this.clone();\n        const values = Hoek.flatten(Array.prototype.slice.call(arguments));\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n\n            Hoek.assert(value !== undefined, 'Cannot call truthy with undefined');\n            obj._inner.truthySet.add(value);\n        }\n        return obj;\n    }\n\n    falsy() {\n\n        const obj = this.clone();\n        const values = Hoek.flatten(Array.prototype.slice.call(arguments));\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n\n            Hoek.assert(value !== undefined, 'Cannot call falsy with undefined');\n            obj._inner.falsySet.add(value);\n        }\n        return obj;\n    }\n\n    insensitive(enabled) {\n\n        const insensitive = enabled === undefined ? true : !!enabled;\n\n        if (insensitive !== this._flags.insensitive) {\n            const obj = this.clone();\n            obj._flags.insensitive = insensitive;\n            return obj;\n        }\n\n        return this;\n    }\n\n    describe() {\n\n        const description = Any.prototype.describe.call(this);\n        description.truthy = [true].concat(this._inner.truthySet.values());\n        description.falsy = [false].concat(this._inner.falsySet.values());\n        return description;\n    }\n};\n\n\nmodule.exports = new internals.Boolean();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/lazy.js":"'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Lazy = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'lazy';\n    }\n\n    _base(value, state, options) {\n\n        const result = { value };\n        const lazy = this._flags.lazy;\n\n        if (!lazy) {\n            result.errors = this.createError('lazy.base', null, state, options);\n            return result;\n        }\n\n        const schema = lazy();\n\n        if (!(schema instanceof Any)) {\n            result.errors = this.createError('lazy.schema', null, state, options);\n            return result;\n        }\n\n        return schema._validate(value, state, options);\n    }\n\n    set(fn) {\n\n        Hoek.assert(typeof fn === 'function', 'You must provide a function as first argument');\n\n        const obj = this.clone();\n        obj._flags.lazy = fn;\n        return obj;\n    }\n\n};\n\nmodule.exports = new internals.Lazy();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/alternatives.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Any = require('./any');\nconst Cast = require('./cast');\nconst Ref = require('./ref');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Alternatives = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'alternatives';\n        this._invalids.remove(null);\n        this._inner.matches = [];\n    }\n\n    _base(value, state, options) {\n\n        let errors = [];\n        const il = this._inner.matches.length;\n        const baseType = this._settings && this._settings.baseType;\n\n        for (let i = 0; i < il; ++i) {\n            const item = this._inner.matches[i];\n            const schema = item.schema;\n            if (!schema) {\n                const failed = item.is._validate(item.ref(state.reference || state.parent, options), null, options, state.parent).errors;\n\n                if (failed) {\n                    if (item.otherwise) {\n                        return item.otherwise._validate(value, state, options);\n                    }\n                    else if (baseType && i  === (il - 1)) {\n                        return baseType._validate(value, state, options);\n                    }\n                }\n                else if (item.then || baseType) {\n                    return (item.then || baseType)._validate(value, state, options);\n                }\n\n                continue;\n            }\n\n            const result = schema._validate(value, state, options);\n            if (!result.errors) {     // Found a valid match\n                return result;\n            }\n\n            errors = errors.concat(result.errors);\n        }\n\n        return { errors: errors.length ? errors : this.createError('alternatives.base', null, state, options) };\n    }\n\n    try(/* schemas */) {\n\n        const schemas = Hoek.flatten(Array.prototype.slice.call(arguments));\n        Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n\n        const obj = this.clone();\n\n        for (let i = 0; i < schemas.length; ++i) {\n            const cast = Cast.schema(schemas[i]);\n            if (cast._refs.length) {\n                obj._refs = obj._refs.concat(cast._refs);\n            }\n            obj._inner.matches.push({ schema: cast });\n        }\n\n        return obj;\n    }\n\n    when(ref, options) {\n\n        Hoek.assert(Ref.isRef(ref) || typeof ref === 'string', 'Invalid reference:', ref);\n        Hoek.assert(options, 'Missing options');\n        Hoek.assert(typeof options === 'object', 'Invalid options');\n        Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n\n        const obj = this.clone();\n        let is = Cast.schema(options.is);\n\n        if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n\n            // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n            is = is.required();\n        }\n\n        const item = {\n            ref: Cast.ref(ref),\n            is,\n            then: options.then !== undefined ? Cast.schema(options.then) : undefined,\n            otherwise: options.otherwise !== undefined ? Cast.schema(options.otherwise) : undefined\n        };\n\n        if (obj._settings && obj._settings.baseType) {\n            item.then = item.then && obj._settings.baseType.concat(item.then);\n            item.otherwise = item.otherwise && obj._settings.baseType.concat(item.otherwise);\n        }\n\n        Ref.push(obj._refs, item.ref);\n        obj._refs = obj._refs.concat(item.is._refs);\n\n        if (item.then && item.then._refs) {\n            obj._refs = obj._refs.concat(item.then._refs);\n        }\n\n        if (item.otherwise && item.otherwise._refs) {\n            obj._refs = obj._refs.concat(item.otherwise._refs);\n        }\n\n        obj._inner.matches.push(item);\n\n        return obj;\n    }\n\n    describe() {\n\n        const description = Any.prototype.describe.call(this);\n        const alternatives = [];\n        for (let i = 0; i < this._inner.matches.length; ++i) {\n            const item = this._inner.matches[i];\n            if (item.schema) {\n\n                // try()\n\n                alternatives.push(item.schema.describe());\n            }\n            else {\n\n                // when()\n\n                const when = {\n                    ref: item.ref.toString(),\n                    is: item.is.describe()\n                };\n\n                if (item.then) {\n                    when.then = item.then.describe();\n                }\n\n                if (item.otherwise) {\n                    when.otherwise = item.otherwise.describe();\n                }\n\n                alternatives.push(when);\n            }\n        }\n\n        description.alternatives = alternatives;\n        return description;\n    }\n\n};\n\n\nmodule.exports = new internals.Alternatives();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/array.js":"'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Cast = require('./cast');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.fastSplice = function (arr, i) {\n\n    let pos = i;\n    while (pos < arr.length) {\n        arr[pos++] = arr[pos];\n    }\n\n    --arr.length;\n};\n\n\ninternals.Array = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'array';\n        this._inner.items = [];\n        this._inner.ordereds = [];\n        this._inner.inclusions = [];\n        this._inner.exclusions = [];\n        this._inner.requireds = [];\n        this._flags.sparse = false;\n    }\n\n    _base(value, state, options) {\n\n        const result = {\n            value\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            internals.safeParse(value, result);\n        }\n\n        let isArray = Array.isArray(result.value);\n        const wasArray = isArray;\n        if (options.convert && this._flags.single && !isArray) {\n            result.value = [result.value];\n            isArray = true;\n        }\n\n        if (!isArray) {\n            result.errors = this.createError('array.base', null, state, options);\n            return result;\n        }\n\n        if (this._inner.inclusions.length ||\n            this._inner.exclusions.length ||\n            this._inner.requireds.length ||\n            this._inner.ordereds.length ||\n            !this._flags.sparse) {\n\n            // Clone the array so that we don't modify the original\n            if (wasArray) {\n                result.value = result.value.slice(0);\n            }\n\n            result.errors = this._checkItems.call(this, result.value, wasArray, state, options);\n\n            if (result.errors && wasArray && options.convert && this._flags.single) {\n\n                // Attempt a 2nd pass by putting the array inside one.\n                const previousErrors = result.errors;\n\n                result.value = [result.value];\n                result.errors = this._checkItems.call(this, result.value, wasArray, state, options);\n\n                if (result.errors) {\n\n                    // Restore previous errors and value since this didn't validate either.\n                    result.errors = previousErrors;\n                    result.value = result.value[0];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    _checkItems(items, wasArray, state, options) {\n\n        const errors = [];\n        let errored;\n\n        const requireds = this._inner.requireds.slice();\n        const ordereds = this._inner.ordereds.slice();\n        const inclusions = this._inner.inclusions.concat(requireds);\n\n        let il = items.length;\n        for (let i = 0; i < il; ++i) {\n            errored = false;\n            const item = items[i];\n            let isValid = false;\n            const key = wasArray ? i : state.key;\n            const path = wasArray ? (state.path ? state.path + '.' : '') + i : state.path;\n            const localState = { key, path, parent: state.parent, reference: state.reference };\n            let res;\n\n            // Sparse\n\n            if (!this._flags.sparse && item === undefined) {\n                errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n\n                continue;\n            }\n\n            // Exclusions\n\n            for (let j = 0; j < this._inner.exclusions.length; ++j) {\n                res = this._inner.exclusions[j]._validate(item, localState, {});                // Not passing options to use defaults\n\n                if (!res.errors) {\n                    errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n                    errored = true;\n\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    break;\n                }\n            }\n\n            if (errored) {\n                continue;\n            }\n\n            // Ordered\n            if (this._inner.ordereds.length) {\n                if (ordereds.length > 0) {\n                    const ordered = ordereds.shift();\n                    res = ordered._validate(item, localState, options);\n                    if (!res.errors) {\n                        if (ordered._flags.strip) {\n                            internals.fastSplice(items, i);\n                            --i;\n                            --il;\n                        }\n                        else if (!this._flags.sparse && res.value === undefined) {\n                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                            if (options.abortEarly) {\n                                return errors;\n                            }\n\n                            continue;\n                        }\n                        else {\n                            items[i] = res.value;\n                        }\n                    }\n                    else {\n                        errors.push(this.createError('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                        if (options.abortEarly) {\n                            return errors;\n                        }\n                    }\n                    continue;\n                }\n                else if (!this._inner.items.length) {\n                    errors.push(this.createError('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n                    continue;\n                }\n            }\n\n            // Requireds\n\n            const requiredChecks = [];\n            let jl = requireds.length;\n            for (let j = 0; j < jl; ++j) {\n                res = requiredChecks[j] = requireds[j]._validate(item, localState, options);\n                if (!res.errors) {\n                    items[i] = res.value;\n                    isValid = true;\n                    internals.fastSplice(requireds, j);\n                    --j;\n                    --jl;\n\n                    if (!this._flags.sparse && res.value === undefined) {\n                        errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                        if (options.abortEarly) {\n                            return errors;\n                        }\n                    }\n\n                    break;\n                }\n            }\n\n            if (isValid) {\n                continue;\n            }\n\n            // Inclusions\n\n            const stripUnknown = options.stripUnknown\n                ? (options.stripUnknown === true ? true : !!options.stripUnknown.arrays)\n                : false;\n\n            jl = inclusions.length;\n            for (let j = 0; j < jl; ++j) {\n                const inclusion = inclusions[j];\n\n                // Avoid re-running requireds that already didn't match in the previous loop\n                const previousCheck = requireds.indexOf(inclusion);\n                if (previousCheck !== -1) {\n                    res = requiredChecks[previousCheck];\n                }\n                else {\n                    res = inclusion._validate(item, localState, options);\n\n                    if (!res.errors) {\n                        if (inclusion._flags.strip) {\n                            internals.fastSplice(items, i);\n                            --i;\n                            --il;\n                        }\n                        else if (!this._flags.sparse && res.value === undefined) {\n                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n                            errored = true;\n                        }\n                        else {\n                            items[i] = res.value;\n                        }\n                        isValid = true;\n                        break;\n                    }\n                }\n\n                // Return the actual error if only one inclusion defined\n                if (jl === 1) {\n                    if (stripUnknown) {\n                        internals.fastSplice(items, i);\n                        --i;\n                        --il;\n                        isValid = true;\n                        break;\n                    }\n\n                    errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                    errored = true;\n\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    break;\n                }\n            }\n\n            if (errored) {\n                continue;\n            }\n\n            if (this._inner.inclusions.length && !isValid) {\n                if (stripUnknown) {\n                    internals.fastSplice(items, i);\n                    --i;\n                    --il;\n                    continue;\n                }\n\n                errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n            }\n        }\n\n        if (requireds.length) {\n            this._fillMissedErrors.call(this, errors, requireds, state, options);\n        }\n\n        if (ordereds.length) {\n            this._fillOrderedErrors.call(this, errors, ordereds, state, options);\n        }\n\n        return errors.length ? errors : null;\n    }\n\n    describe() {\n\n        const description = Any.prototype.describe.call(this);\n\n        if (this._inner.ordereds.length) {\n            description.orderedItems = [];\n\n            for (let i = 0; i < this._inner.ordereds.length; ++i) {\n                description.orderedItems.push(this._inner.ordereds[i].describe());\n            }\n        }\n\n        if (this._inner.items.length) {\n            description.items = [];\n\n            for (let i = 0; i < this._inner.items.length; ++i) {\n                description.items.push(this._inner.items[i].describe());\n            }\n        }\n\n        return description;\n    }\n\n    items() {\n\n        const obj = this.clone();\n\n        Hoek.flatten(Array.prototype.slice.call(arguments)).forEach((type, index) => {\n\n            try {\n                type = Cast.schema(type);\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = index + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = index;\n                }\n                castErr.message = castErr.message + '(' + castErr.path + ')';\n                throw castErr;\n            }\n\n            obj._inner.items.push(type);\n\n            if (type._flags.presence === 'required') {\n                obj._inner.requireds.push(type);\n            }\n            else if (type._flags.presence === 'forbidden') {\n                obj._inner.exclusions.push(type.optional());\n            }\n            else {\n                obj._inner.inclusions.push(type);\n            }\n        });\n\n        return obj;\n    }\n\n    ordered() {\n\n        const obj = this.clone();\n\n        Hoek.flatten(Array.prototype.slice.call(arguments)).forEach((type, index) => {\n\n            try {\n                type = Cast.schema(type);\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = index + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = index;\n                }\n                castErr.message = castErr.message + '(' + castErr.path + ')';\n                throw castErr;\n            }\n            obj._inner.ordereds.push(type);\n        });\n\n        return obj;\n    }\n\n    min(limit) {\n\n        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            if (value.length >= limit) {\n                return value;\n            }\n\n            return this.createError('array.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            if (value.length <= limit) {\n                return value;\n            }\n\n            return this.createError('array.max', { limit, value }, state, options);\n        });\n    }\n\n    length(limit) {\n\n        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            if (value.length === limit) {\n                return value;\n            }\n\n            return this.createError('array.length', { limit, value }, state, options);\n        });\n    }\n\n    unique(comparator) {\n\n        Hoek.assert(comparator === undefined ||\n            typeof comparator === 'function' ||\n            typeof comparator === 'string', 'comparator must be a function or a string');\n\n        const settings = {};\n\n        if (typeof comparator === 'string') {\n            settings.path = comparator;\n        }\n        else if (typeof comparator === 'function') {\n            settings.comparator = comparator;\n        }\n\n        return this._test('unique', settings, function (value, state, options) {\n\n            const found = {\n                string: {},\n                number: {},\n                undefined: {},\n                boolean: {},\n                object: new Map(),\n                function: new Map(),\n                custom: new Map()\n            };\n\n            const compare = settings.comparator || Hoek.deepEqual;\n\n            for (let i = 0; i < value.length; ++i) {\n                const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];\n                const records = settings.comparator ? found.custom : found[typeof item];\n\n                // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n                // I still want to keep the test for future js versions with new types (eg. Symbol).\n                if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {\n                    if (records instanceof Map) {\n                        const entries = records.entries();\n                        let current;\n                        while (!(current = entries.next()).done) {\n                            if (compare(current.value[0], item)) {\n                                const localState = {\n                                    key: state.key,\n                                    path: (state.path ? state.path + '.' : '') + i,\n                                    parent: state.parent,\n                                    reference: state.reference\n                                };\n\n                                const context = {\n                                    pos: i,\n                                    value: value[i],\n                                    dupePos: current.value[1],\n                                    dupeValue: value[current.value[1]]\n                                };\n\n                                if (settings.path) {\n                                    context.path = settings.path;\n                                }\n\n                                return this.createError('array.unique', context, localState, options);\n                            }\n                        }\n\n                        records.set(item, i);\n                    }\n                    else {\n                        if (records[item] !== undefined) {\n                            const localState = {\n                                key: state.key,\n                                path: (state.path ? state.path + '.' : '') + i,\n                                parent: state.parent,\n                                reference: state.reference\n                            };\n\n                            const context = {\n                                pos: i,\n                                value: value[i],\n                                dupePos: records[item],\n                                dupeValue: value[records[item]]\n                            };\n\n                            if (settings.path) {\n                                context.path = settings.path;\n                            }\n\n                            return this.createError('array.unique', context, localState, options);\n                        }\n\n                        records[item] = i;\n                    }\n                }\n            }\n\n            return value;\n        });\n    }\n\n    sparse(enabled) {\n\n        const obj = this.clone();\n        obj._flags.sparse = enabled === undefined ? true : !!enabled;\n        return obj;\n    }\n\n    single(enabled) {\n\n        const obj = this.clone();\n        obj._flags.single = enabled === undefined ? true : !!enabled;\n        return obj;\n    }\n\n    _fillMissedErrors(errors, requireds, state, options) {\n\n        const knownMisses = [];\n        let unknownMisses = 0;\n        for (let i = 0; i < requireds.length; ++i) {\n            const label = requireds[i]._getLabel();\n            if (label) {\n                knownMisses.push(label);\n            }\n            else {\n                ++unknownMisses;\n            }\n        }\n\n        if (knownMisses.length) {\n            if (unknownMisses) {\n                errors.push(this.createError('array.includesRequiredBoth', { knownMisses, unknownMisses }, { key: state.key, path: state.path }, options));\n            }\n            else {\n                errors.push(this.createError('array.includesRequiredKnowns', { knownMisses }, { key: state.key, path: state.path }, options));\n            }\n        }\n        else {\n            errors.push(this.createError('array.includesRequiredUnknowns', { unknownMisses }, { key: state.key, path: state.path }, options));\n        }\n    }\n\n\n    _fillOrderedErrors(errors, ordereds, state, options) {\n\n        const requiredOrdereds = [];\n\n        for (let i = 0; i < ordereds.length; ++i) {\n            const presence = Hoek.reach(ordereds[i], '_flags.presence');\n            if (presence === 'required') {\n                requiredOrdereds.push(ordereds[i]);\n            }\n        }\n\n        if (requiredOrdereds.length) {\n            this._fillMissedErrors.call(this, errors, requiredOrdereds, state, options);\n        }\n    }\n\n};\n\n\ninternals.safeParse = function (value, result) {\n\n    try {\n        const converted = JSON.parse(value);\n        if (Array.isArray(converted)) {\n            result.value = converted;\n        }\n    }\n    catch (e) { }\n};\n\n\nmodule.exports = new internals.Array();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/binary.js":"'use strict';\n\n// Load modules\n\nconst Any = require('./any');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Binary = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'binary';\n    }\n\n    _base(value, state, options) {\n\n        const result = {\n            value\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            try {\n                result.value = new Buffer(value, this._flags.encoding);\n            }\n            catch (e) {\n            }\n        }\n\n        result.errors = Buffer.isBuffer(result.value) ? null : this.createError('binary.base', null, state, options);\n        return result;\n    }\n\n    encoding(encoding) {\n\n        Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n        const obj = this.clone();\n        obj._flags.encoding = encoding;\n        return obj;\n    }\n\n    min(limit) {\n\n        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            if (value.length >= limit) {\n                return value;\n            }\n\n            return this.createError('binary.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            if (value.length <= limit) {\n                return value;\n            }\n\n            return this.createError('binary.max', { limit, value }, state, options);\n        });\n    }\n\n    length(limit) {\n\n        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            if (value.length === limit) {\n                return value;\n            }\n\n            return this.createError('binary.length', { limit, value }, state, options);\n        });\n    }\n\n};\n\n\nmodule.exports = new internals.Binary();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/object.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Topo = require('topo');\nconst Any = require('./any');\nconst Errors = require('./errors');\nconst Cast = require('./cast');\nconst Ref = require('./ref');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Object = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'object';\n        this._inner.children = null;\n        this._inner.renames = [];\n        this._inner.dependencies = [];\n        this._inner.patterns = [];\n    }\n\n    _base(value, state, options) {\n\n        let target = value;\n        const errors = [];\n        const finish = () => {\n\n            return {\n                value: target,\n                errors: errors.length ? errors : null\n            };\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            value = internals.safeParse(value);\n        }\n\n        const type = this._flags.func ? 'function' : 'object';\n        if (!value ||\n            typeof value !== type ||\n            Array.isArray(value)) {\n\n            errors.push(this.createError(type + '.base', null, state, options));\n            return finish();\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!this._inner.renames.length &&\n            !this._inner.dependencies.length &&\n            !this._inner.children &&                    // null allows any keys\n            !this._inner.patterns.length) {\n\n            target = value;\n            return finish();\n        }\n\n        // Ensure target is a local copy (parsed) or shallow copy\n\n        if (target === value) {\n            if (type === 'object') {\n                target = Object.create(Object.getPrototypeOf(value));\n            }\n            else {\n                target = function () {\n\n                    return value.apply(this, arguments);\n                };\n\n                target.prototype = Hoek.clone(value.prototype);\n            }\n\n            const valueKeys = Object.keys(value);\n            for (let i = 0; i < valueKeys.length; ++i) {\n                target[valueKeys[i]] = value[valueKeys[i]];\n            }\n        }\n        else {\n            target = value;\n        }\n\n        // Rename keys\n\n        const renamed = {};\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            const rename = this._inner.renames[i];\n\n            if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n                continue;\n            }\n\n            if (!rename.options.multiple &&\n                renamed[rename.to]) {\n\n                errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n\n            if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                !rename.options.override &&\n                !renamed[rename.to]) {\n\n                errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n\n            if (target[rename.from] === undefined) {\n                delete target[rename.to];\n            }\n            else {\n                target[rename.to] = target[rename.from];\n            }\n\n            renamed[rename.to] = true;\n\n            if (!rename.options.alias) {\n                delete target[rename.from];\n            }\n        }\n\n        // Validate schema\n\n        if (!this._inner.children &&            // null allows any keys\n            !this._inner.patterns.length &&\n            !this._inner.dependencies.length) {\n\n            return finish();\n        }\n\n        const unprocessed = Hoek.mapToObject(Object.keys(target));\n\n        if (this._inner.children) {\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                const key = child.key;\n                const item = target[key];\n\n                delete unprocessed[key];\n\n                const localState = { key, path: (state.path || '') + (state.path && key ? '.' : '') + key, parent: target, reference: state.reference };\n                const result = child.schema._validate(item, localState, options);\n                if (result.errors) {\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\n\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\n                    delete target[key];\n                }\n                else if (result.value !== undefined) {\n                    target[key] = result.value;\n                }\n            }\n        }\n\n        // Unknown keys\n\n        let unprocessedKeys = Object.keys(unprocessed);\n        if (unprocessedKeys.length &&\n            this._inner.patterns.length) {\n\n            for (let i = 0; i < unprocessedKeys.length; ++i) {\n                const key = unprocessedKeys[i];\n                const localState = { key, path: (state.path ? state.path + '.' : '') + key, parent: target, reference: state.reference };\n                const item = target[key];\n\n                for (let j = 0; j < this._inner.patterns.length; ++j) {\n                    const pattern = this._inner.patterns[j];\n\n                    if (pattern.regex.test(key)) {\n                        delete unprocessed[key];\n\n                        const result = pattern.rule._validate(item, localState, options);\n                        if (result.errors) {\n                            errors.push(this.createError('object.child', { key, child: pattern.rule._getLabel(key), reason: result.errors }, localState, options));\n\n                            if (options.abortEarly) {\n                                return finish();\n                            }\n                        }\n\n                        if (result.value !== undefined) {\n                            target[key] = result.value;\n                        }\n                    }\n                }\n            }\n\n            unprocessedKeys = Object.keys(unprocessed);\n        }\n\n        if ((this._inner.children || this._inner.patterns.length) && unprocessedKeys.length) {\n            if (options.stripUnknown ||\n                options.skipFunctions) {\n\n                const stripUnknown = options.stripUnknown\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\n                    : false;\n\n\n                for (let i = 0; i < unprocessedKeys.length; ++i) {\n                    const key = unprocessedKeys[i];\n\n                    if (stripUnknown) {\n                        delete target[key];\n                        delete unprocessed[key];\n                    }\n                    else if (typeof target[key] === 'function') {\n                        delete unprocessed[key];\n                    }\n                }\n\n                unprocessedKeys = Object.keys(unprocessed);\n            }\n\n            if (unprocessedKeys.length &&\n                (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n\n                for (let i = 0; i < unprocessedKeys.length; ++i) {\n                    const unprocessedKey = unprocessedKeys[i];\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, { key: unprocessedKey, path: state.path + (state.path ? '.' : '') + unprocessedKey }, options));\n                }\n            }\n        }\n\n        // Validate dependencies\n\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\n            const dep = this._inner.dependencies[i];\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: (state.path || '') + (dep.key ? '.' + dep.key : '') }, options);\n            if (err instanceof Errors.Err) {\n                errors.push(err);\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n        }\n\n        return finish();\n    }\n\n    _func() {\n\n        const obj = this.clone();\n        obj._flags.func = true;\n        return obj;\n    }\n\n    keys(schema) {\n\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n\n        const obj = this.clone();\n\n        if (!schema) {\n            obj._inner.children = null;\n            return obj;\n        }\n\n        const children = Object.keys(schema);\n\n        if (!children.length) {\n            obj._inner.children = [];\n            return obj;\n        }\n\n        const topo = new Topo();\n        if (obj._inner.children) {\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n\n                // Only add the key if we are not going to replace it later\n                if (children.indexOf(child.key) === -1) {\n                    topo.add(child, { after: child._refs, group: child.key });\n                }\n            }\n        }\n\n        for (let i = 0; i < children.length; ++i) {\n            const key = children[i];\n            const child = schema[key];\n            try {\n                const cast = Cast.schema(child);\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = key + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = key;\n                }\n                throw castErr;\n            }\n        }\n\n        obj._inner.children = topo.nodes;\n\n        return obj;\n    }\n\n    unknown(allow) {\n\n        const obj = this.clone();\n        obj._flags.allowUnknown = (allow !== false);\n        return obj;\n    }\n\n    length(limit) {\n\n        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            if (Object.keys(value).length === limit) {\n                return value;\n            }\n\n            return this.createError('object.length', { limit }, state, options);\n        });\n    }\n\n    arity(n) {\n\n        Hoek.assert(Hoek.isInteger(n) && n >= 0, 'n must be a positive integer');\n\n        return this._test('arity', n, function (value, state, options) {\n\n            if (value.length === n) {\n                return value;\n            }\n\n            return this.createError('function.arity', { n }, state, options);\n        });\n    }\n\n    minArity(n) {\n\n        Hoek.assert(Hoek.isInteger(n) && n > 0, 'n must be a strict positive integer');\n\n        return this._test('minArity', n, function (value, state, options) {\n\n            if (value.length >= n) {\n                return value;\n            }\n\n            return this.createError('function.minArity', { n }, state, options);\n        });\n    }\n\n    maxArity(n) {\n\n        Hoek.assert(Hoek.isInteger(n) && n >= 0, 'n must be a positive integer');\n\n        return this._test('maxArity', n, function (value, state, options) {\n\n            if (value.length <= n) {\n                return value;\n            }\n\n            return this.createError('function.maxArity', { n }, state, options);\n        });\n    }\n\n    min(limit) {\n\n        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            if (Object.keys(value).length >= limit) {\n                return value;\n            }\n\n            return this.createError('object.min', { limit }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        Hoek.assert(Hoek.isInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            if (Object.keys(value).length <= limit) {\n                return value;\n            }\n\n            return this.createError('object.max', { limit }, state, options);\n        });\n    }\n\n    pattern(pattern, schema) {\n\n        Hoek.assert(pattern instanceof RegExp, 'Invalid regular expression');\n        Hoek.assert(schema !== undefined, 'Invalid rule');\n\n        pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\n\n        try {\n            schema = Cast.schema(schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = castErr.message + '(' + castErr.path + ')';\n            }\n\n            throw castErr;\n        }\n\n\n        const obj = this.clone();\n        obj._inner.patterns.push({ regex: pattern, rule: schema });\n        return obj;\n    }\n\n    schema() {\n\n        return this._test('schema', null, function (value, state, options) {\n\n            if (value instanceof Any) {\n                return value;\n            }\n\n            return this.createError('object.schema', null, state, options);\n        });\n    }\n\n    with(key, peers) {\n\n        return this._dependency('with', key, peers);\n    }\n\n    without(key, peers) {\n\n        return this._dependency('without', key, peers);\n    }\n\n    xor() {\n\n        const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n        return this._dependency('xor', null, peers);\n    }\n\n    or() {\n\n        const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n        return this._dependency('or', null, peers);\n    }\n\n    and() {\n\n        const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n        return this._dependency('and', null, peers);\n    }\n\n    nand() {\n\n        const peers = Hoek.flatten(Array.prototype.slice.call(arguments));\n        return this._dependency('nand', null, peers);\n    }\n\n    requiredKeys(children) {\n\n        children = Hoek.flatten(Array.prototype.slice.call(arguments));\n        return this.applyFunctionToChildren(children, 'required');\n    }\n\n    optionalKeys(children) {\n\n        children = Hoek.flatten(Array.prototype.slice.call(arguments));\n        return this.applyFunctionToChildren(children, 'optional');\n    }\n\n    rename(from, to, options) {\n\n        Hoek.assert(typeof from === 'string', 'Rename missing the from argument');\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n        }\n\n        const obj = this.clone();\n\n        obj._inner.renames.push({\n            from,\n            to,\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {})\n        });\n\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args, root) {\n\n        children = [].concat(children);\n        Hoek.assert(children.length > 0, 'expected at least one children');\n\n        const groupedChildren = internals.groupChildren(children);\n        let obj;\n\n        if ('' in groupedChildren) {\n            obj = this[fn].apply(this, args);\n            delete groupedChildren[''];\n        }\n        else {\n            obj = this.clone();\n        }\n\n        if (obj._inner.children) {\n            root = root ? (root + '.') : '';\n\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n                const group = groupedChildren[child.key];\n\n                if (group) {\n                    obj._inner.children[i] = {\n                        key: child.key,\n                        _refs: child._refs,\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n                    };\n\n                    delete groupedChildren[child.key];\n                }\n            }\n        }\n\n        const remaining = Object.keys(groupedChildren);\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n\n        return obj;\n    }\n\n    _dependency(type, key, peers) {\n\n        peers = [].concat(peers);\n        for (let i = 0; i < peers.length; ++i) {\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n        }\n\n        const obj = this.clone();\n        obj._inner.dependencies.push({ type, key, peers });\n        return obj;\n    }\n\n    describe(shallow) {\n\n        const description = Any.prototype.describe.call(this);\n\n        if (description.rules) {\n            for (let i = 0; i < description.rules.length; ++i) {\n                const rule = description.rules[i];\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\n                if (/* $lab:coverage:off$ */rule.arg &&\n                    typeof rule.arg === 'object' &&\n                    rule.arg.schema &&\n                    rule.arg.ref /* $lab:coverage:on$ */) {\n                    rule.arg = {\n                        schema: rule.arg.schema.describe(),\n                        ref: rule.arg.ref.toString()\n                    };\n                }\n            }\n        }\n\n        if (this._inner.children &&\n            !shallow) {\n\n            description.children = {};\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                description.children[child.key] = child.schema.describe();\n            }\n        }\n\n        if (this._inner.dependencies.length) {\n            description.dependencies = Hoek.clone(this._inner.dependencies);\n        }\n\n        if (this._inner.patterns.length) {\n            description.patterns = [];\n\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\n                const pattern = this._inner.patterns[i];\n                description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\n            }\n        }\n\n        if (this._inner.renames.length > 0) {\n            description.renames = Hoek.clone(this._inner.renames);\n        }\n\n        return description;\n    }\n\n    assert(ref, schema, message) {\n\n        ref = Cast.ref(ref);\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n        message = message || 'pass the assertion test';\n\n        try {\n            schema = Cast.schema(schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = castErr.message + '(' + castErr.path + ')';\n            }\n\n            throw castErr;\n        }\n\n        const key = ref.path[ref.path.length - 1];\n        const path = ref.path.join('.');\n\n        return this._test('assert', { schema, ref }, function (value, state, options) {\n\n            const result = schema._validate(ref(value), null, options, value);\n            if (!result.errors) {\n                return value;\n            }\n\n            const localState = Hoek.merge({}, state);\n            localState.key = key;\n            localState.path = path;\n            return this.createError('object.assert', { ref: localState.path, message }, localState, options);\n        });\n    }\n\n    type(constructor, name) {\n\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n        const typeData = {\n            name: name || constructor.name,\n            ctor: constructor\n        };\n\n        return this._test('type', typeData, function (value, state, options) {\n\n            if (value instanceof constructor) {\n                return value;\n            }\n\n            return this.createError('object.type', { type: typeData.name }, state, options);\n        });\n    }\n\n    ref() {\n\n        return this._test('ref', null, function (value, state, options) {\n\n            if (Ref.isRef(value)) {\n                return value;\n            }\n\n            return this.createError('function.ref', null, state, options);\n        });\n    }\n};\n\ninternals.safeParse = function (value) {\n\n    try {\n        return JSON.parse(value);\n    }\n    catch (parseErr) {}\n\n    return value;\n};\n\n\ninternals.renameDefaults = {\n    alias: false,                   // Keep old value in place\n    multiple: false,                // Allow renaming multiple keys into the same target\n    override: false                 // Overrides an existing key\n};\n\n\ninternals.groupChildren = function (children) {\n\n    children.sort();\n\n    const grouped = {};\n\n    for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n        Hoek.assert(typeof child === 'string', 'children must be strings');\n        const group = child.split('.')[0];\n        const childGroup = grouped[group] = (grouped[group] || []);\n        childGroup.push(child.substring(group.length + 1));\n    }\n\n    return grouped;\n};\n\n\ninternals.with = function (value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return value;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||\n            parent[peer] === undefined) {\n\n            return this.createError('object.with', { peer }, state, options);\n        }\n    }\n\n    return value;\n};\n\n\ninternals.without = function (value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return value;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            return this.createError('object.without', { peer }, state, options);\n        }\n    }\n\n    return value;\n};\n\n\ninternals.xor = function (value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    if (present.length === 1) {\n        return value;\n    }\n\n    if (present.length === 0) {\n        return this.createError('object.missing', { peers }, state, options);\n    }\n\n    return this.createError('object.xor', { peers }, state, options);\n};\n\n\ninternals.or = function (value, peers, parent, state, options) {\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n            return value;\n        }\n    }\n\n    return this.createError('object.missing', { peers }, state, options);\n};\n\n\ninternals.and = function (value, peers, parent, state, options) {\n\n    const missing = [];\n    const present = [];\n    const count = peers.length;\n    for (let i = 0; i < count; ++i) {\n        const peer = peers[i];\n        if (!Object.prototype.hasOwnProperty.call(parent, peer) ||\n            parent[peer] === undefined) {\n\n            missing.push(peer);\n        }\n        else {\n            present.push(peer);\n        }\n    }\n\n    const aon = (missing.length === count || present.length === count);\n    return !aon ? this.createError('object.and', { present, missing }, state, options) : null;\n};\n\n\ninternals.nand = function (value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        if (Object.prototype.hasOwnProperty.call(parent, peer) &&\n            parent[peer] !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    const values = Hoek.clone(peers);\n    const main = values.splice(0, 1)[0];\n    const allPresent = (present.length === peers.length);\n    return allPresent ? this.createError('object.nand', { main, peers: values }, state, options) : null;\n};\n\n\nmodule.exports = new internals.Object();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/topo/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Topo = function () {\n\n    this._items = [];\n    this.nodes = [];\n};\n\n\ninternals.Topo.prototype.add = function (nodes, options) {\n\n    options = options || {};\n\n    // Validate rules\n\n    const before = [].concat(options.before || []);\n    const after = [].concat(options.after || []);\n    const group = options.group || '?';\n    const sort = options.sort || 0;                   // Used for merging only\n\n    Hoek.assert(before.indexOf(group) === -1, 'Item cannot come before itself:', group);\n    Hoek.assert(before.indexOf('?') === -1, 'Item cannot come before unassociated items');\n    Hoek.assert(after.indexOf(group) === -1, 'Item cannot come after itself:', group);\n    Hoek.assert(after.indexOf('?') === -1, 'Item cannot come after unassociated items');\n\n    ([].concat(nodes)).forEach((node, i) => {\n\n        const item = {\n            seq: this._items.length,\n            sort: sort,\n            before: before,\n            after: after,\n            group: group,\n            node: node\n        };\n\n        this._items.push(item);\n    });\n\n    // Insert event\n\n    const error = this._sort();\n    Hoek.assert(!error, 'item', (group !== '?' ? 'added into group ' + group : ''), 'created a dependencies error');\n\n    return this.nodes;\n};\n\n\ninternals.Topo.prototype.merge = function (others) {\n\n    others = [].concat(others);\n    for (let i = 0; i < others.length; ++i) {\n        const other = others[i];\n        if (other) {\n            for (let j = 0; j < other._items.length; ++j) {\n                const item = Hoek.shallow(other._items[j]);\n                this._items.push(item);\n            }\n        }\n    }\n\n    // Sort items\n\n    this._items.sort(internals.mergeSort);\n    for (let i = 0; i < this._items.length; ++i) {\n        this._items[i].seq = i;\n    }\n\n    const error = this._sort();\n    Hoek.assert(!error, 'merge created a dependencies error');\n\n    return this.nodes;\n};\n\n\ninternals.mergeSort = function (a, b) {\n\n    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);\n};\n\n\ninternals.Topo.prototype._sort = function () {\n\n    // Construct graph\n\n    const graph = {};\n    const graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n    const groups = Object.create(null);\n\n    for (let i = 0; i < this._items.length; ++i) {\n        const item = this._items[i];\n        const seq = item.seq;                         // Unique across all items\n        const group = item.group;\n\n        // Determine Groups\n\n        groups[group] = groups[group] || [];\n        groups[group].push(seq);\n\n        // Build intermediary graph using 'before'\n\n        graph[seq] = item.before;\n\n        // Build second intermediary graph with 'after'\n\n        const after = item.after;\n        for (let j = 0; j < after.length; ++j) {\n            graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n        }\n    }\n\n    // Expand intermediary graph\n\n    let graphNodes = Object.keys(graph);\n    for (let i = 0; i < graphNodes.length; ++i) {\n        const node = graphNodes[i];\n        const expandedGroups = [];\n\n        const graphNodeItems = Object.keys(graph[node]);\n        for (let j = 0; j < graphNodeItems.length; ++j) {\n            const group = graph[node][graphNodeItems[j]];\n            groups[group] = groups[group] || [];\n\n            for (let k = 0; k < groups[group].length; ++k) {\n                expandedGroups.push(groups[group][k]);\n            }\n        }\n        graph[node] = expandedGroups;\n    }\n\n    // Merge intermediary graph using graphAfters into final graph\n\n    const afterNodes = Object.keys(graphAfters);\n    for (let i = 0; i < afterNodes.length; ++i) {\n        const group = afterNodes[i];\n\n        if (groups[group]) {\n            for (let j = 0; j < groups[group].length; ++j) {\n                const node = groups[group][j];\n                graph[node] = graph[node].concat(graphAfters[group]);\n            }\n        }\n    }\n\n    // Compile ancestors\n\n    let children;\n    const ancestors = {};\n    graphNodes = Object.keys(graph);\n    for (let i = 0; i < graphNodes.length; ++i) {\n        const node = graphNodes[i];\n        children = graph[node];\n\n        for (let j = 0; j < children.length; ++j) {\n            ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);\n        }\n    }\n\n    // Topo sort\n\n    const visited = {};\n    const sorted = [];\n\n    for (let i = 0; i < this._items.length; ++i) {\n        let next = i;\n\n        if (ancestors[i]) {\n            next = null;\n            for (let j = 0; j < this._items.length; ++j) {\n                if (visited[j] === true) {\n                    continue;\n                }\n\n                if (!ancestors[j]) {\n                    ancestors[j] = [];\n                }\n\n                const shouldSeeCount = ancestors[j].length;\n                let seenCount = 0;\n                for (let k = 0; k < shouldSeeCount; ++k) {\n                    if (sorted.indexOf(ancestors[j][k]) >= 0) {\n                        ++seenCount;\n                    }\n                }\n\n                if (seenCount === shouldSeeCount) {\n                    next = j;\n                    break;\n                }\n            }\n        }\n\n        if (next !== null) {\n            next = next.toString();         // Normalize to string TODO: replace with seq\n            visited[next] = true;\n            sorted.push(next);\n        }\n    }\n\n    if (sorted.length !== this._items.length) {\n        return new Error('Invalid dependencies');\n    }\n\n    const seqIndex = {};\n    for (let i = 0; i < this._items.length; ++i) {\n        const item = this._items[i];\n        seqIndex[item.seq] = item;\n    }\n\n    const sortedNodes = [];\n    this._items = sorted.map((value) => {\n\n        const sortedItem = seqIndex[value];\n        sortedNodes.push(sortedItem.node);\n        return sortedItem;\n    });\n\n    this.nodes = sortedNodes;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/catbox-memory/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.defaults = {\n    maxByteSize: 100 * 1024 * 1024,          // 100MB\n    allowMixedContent: false\n};\n\n// Provides a named reference for memory debugging\ninternals.MemoryCacheSegment = function MemoryCacheSegment() {\n};\n\ninternals.MemoryCacheEntry = function MemoryCacheEntry(key, value, ttl, allowMixedContent) {\n\n    let valueByteSize = 0;\n\n    if (allowMixedContent && Buffer.isBuffer(value)) {\n        this.item = new Buffer(value.length);\n        // copy buffer to prevent value from changing while in the cache\n        value.copy(this.item);\n        valueByteSize = this.item.length;\n    }\n    else {\n        // stringify() to prevent value from changing while in the cache\n        this.item = JSON.stringify(value);\n        valueByteSize = Buffer.byteLength(this.item);\n    }\n\n    this.stored = Date.now();\n    this.ttl = ttl;\n\n    // Approximate cache entry size without value: 144 bytes\n    this.byteSize = 144 + valueByteSize + Buffer.byteLength(key.segment) + Buffer.byteLength(key.id);\n\n    this.timeoutId = null;\n};\n\n\nexports = module.exports = internals.Connection = function MemoryCache(options) {\n\n    Hoek.assert(this.constructor === internals.Connection, 'Memory cache client must be instantiated using new');\n    Hoek.assert(!options || options.maxByteSize === undefined || options.maxByteSize >= 0, 'Invalid cache maxByteSize value');\n    Hoek.assert(!options || options.allowMixedContent === undefined || typeof options.allowMixedContent === 'boolean', 'Invalid allowMixedContent value');\n\n    this.settings = Hoek.applyToDefaults(internals.defaults, options || {});\n    this.cache = null;\n};\n\n\ninternals.Connection.prototype.start = function (callback) {\n\n    callback = Hoek.nextTick(callback);\n\n    if (!this.cache) {\n        this.cache = {};\n        this.byteSize = 0;\n    }\n\n    return callback();\n};\n\n\ninternals.Connection.prototype.stop = function () {\n\n    // Clean up pending eviction timers.\n    if (this.cache) {\n        const segments = Object.keys(this.cache);\n        for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n            const keys = Object.keys(this.cache[segment]);\n            for (let j = 0; j < keys.length; ++j) {\n                const key = keys[j];\n                clearTimeout(this.cache[segment][key].timeoutId);\n            }\n        }\n    }\n\n    this.cache = null;\n    this.byteSize = 0;\n    return;\n};\n\n\ninternals.Connection.prototype.isReady = function () {\n\n    return !!this.cache;\n};\n\n\ninternals.Connection.prototype.validateSegmentName = function (name) {\n\n    if (!name) {\n        return new Error('Empty string');\n    }\n\n    if (name.indexOf('\\u0000') !== -1) {\n        return new Error('Includes null character');\n    }\n\n    return null;\n};\n\n\ninternals.Connection.prototype.get = function (key, callback) {\n\n    callback = Hoek.nextTick(callback);\n\n    if (!this.cache) {\n        return callback(new Error('Connection not started'));\n    }\n\n    const segment = this.cache[key.segment];\n\n    if (!segment) {\n        return callback(null, null);\n    }\n\n    const envelope = segment[key.id];\n\n    if (!envelope) {\n        return callback(null, null);\n    }\n\n    let value = null;\n\n    if (Buffer.isBuffer(envelope.item)) {\n        value = envelope.item;\n    }\n    else {\n        value = internals.parseJSON(envelope.item);\n\n        if (value instanceof Error) {\n            return callback(new Error('Bad value content'));\n        }\n    }\n\n    const result = {\n        item: value,\n        stored: envelope.stored,\n        ttl: envelope.ttl\n    };\n\n    return callback(null, result);\n};\n\n\ninternals.Connection.prototype.set = function (key, value, ttl, callback) {\n\n    callback = Hoek.nextTick(callback);\n\n    if (!this.cache) {\n        return callback(new Error('Connection not started'));\n    }\n\n    if (ttl > 2147483647) {                                                         // Math.pow(2, 31)\n        return callback(new Error('Invalid ttl (greater than 2147483647)'));\n    }\n\n    let envelope = null;\n    try {\n        envelope = new internals.MemoryCacheEntry(key, value, ttl, this.settings.allowMixedContent);\n    }\n    catch (err) {\n        return callback(err);\n    }\n\n    this.cache[key.segment] = this.cache[key.segment] || new internals.MemoryCacheSegment();\n    const segment = this.cache[key.segment];\n    const cachedItem = segment[key.id];\n\n    if (cachedItem && cachedItem.timeoutId) {\n        clearTimeout(cachedItem.timeoutId);\n        this.byteSize -= cachedItem.byteSize;                   // If the item existed, decrement the byteSize as the value could be different\n    }\n\n    if (this.settings.maxByteSize) {\n        if (this.byteSize + envelope.byteSize > this.settings.maxByteSize) {\n            return callback(new Error('Cache size limit reached'));\n        }\n    }\n\n    const timeoutId = setTimeout(() => {\n\n        this.drop(key, () => {});\n    }, ttl);\n\n    envelope.timeoutId = timeoutId;\n\n    segment[key.id] = envelope;\n    this.byteSize += envelope.byteSize;\n\n    return callback(null);\n};\n\n\ninternals.Connection.prototype.drop = function (key, callback) {\n\n    callback = Hoek.nextTick(callback);\n\n    if (!this.cache) {\n        return callback(new Error('Connection not started'));\n    }\n\n    const segment = this.cache[key.segment];\n    if (segment) {\n        const item = segment[key.id];\n\n        if (item) {\n            clearTimeout(item.timeoutId);\n            this.byteSize -= item.byteSize;\n        }\n\n        delete segment[key.id];\n    }\n\n    return callback();\n};\n\n\ninternals.parseJSON = function (json) {\n\n    let obj = null;\n\n    try {\n        obj = JSON.parse(json);\n    }\n    catch (err) {\n        obj = err;\n    }\n\n    return obj;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/heavy/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Joi = require('joi');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.schema = {\n    process: Joi.object({\n        sampleInterval: Joi.number().min(0)\n    }),\n    policy: Joi.object({\n        maxHeapUsedBytes: Joi.number().min(0),\n        maxEventLoopDelay: Joi.number().min(0),\n        maxRssBytes: Joi.number().min(0)\n    })\n};\n\n\ninternals.defaults = {\n    process: {\n        sampleInterval: 0                           // Frequency of load sampling in milliseconds (zero is no sampling)\n    },\n    policy: {\n        maxHeapUsedBytes: 0,                        // Reject requests when V8 heap is over size in bytes (zero is no max)\n        maxRssBytes: 0,                             // Reject requests when process RSS is over size in bytes (zero is no max)\n        maxEventLoopDelay: 0                        // Milliseconds of delay after which requests are rejected (zero is no max)\n    }\n};\n\n\nexports = module.exports = internals.Heavy = function (options) {\n\n    options = options || {};\n\n    Joi.assert(options, internals.schema.process, 'Invalid load monitoring options');\n    this.settings = Hoek.applyToDefaults(internals.defaults, options);\n\n    this._eventLoopTimer = null;\n    this._loadBench = new Hoek.Bench();\n    this.load = {\n        eventLoopDelay: 0,\n        heapUsed: 0,\n        rss: 0\n    };\n};\n\n\ninternals.Heavy.prototype.start = function () {\n\n    if (!this.settings.sampleInterval) {\n        return;\n    }\n\n    const loopSample = () => {\n\n        this._loadBench.reset();\n        const measure = () => {\n\n            const mem = process.memoryUsage();\n\n            // Retain the same this.load object to keep external references valid\n\n            this.load.eventLoopDelay = (this._loadBench.elapsed() - this.settings.sampleInterval);\n            this.load.heapUsed = mem.heapUsed;\n            this.load.rss = mem.rss;\n\n            loopSample();\n        };\n\n        this._eventLoopTimer = setTimeout(measure, this.settings.sampleInterval);\n    };\n\n    loopSample();\n};\n\n\ninternals.Heavy.prototype.stop = function () {\n\n    clearTimeout(this._eventLoopTimer);\n    this._eventLoopTimer = null;\n};\n\n\ninternals.Heavy.prototype.policy = function (options) {\n\n    return new internals.Policy(this, options);\n};\n\n\ninternals.Policy = function (process, options) {\n\n    options = options || {};\n\n    Joi.assert(options, internals.schema.policy, 'Invalid load monitoring options');\n    Hoek.assert(process.settings.sampleInterval || (!options.maxEventLoopDelay && !options.maxHeapUsedBytes && !options.maxRssBytes), 'Load sample interval must be set to enable load limits');\n\n    this._process = process;\n    this.settings = Hoek.applyToDefaults(internals.defaults.policy, options);\n};\n\n\ninternals.Policy.prototype.check = function () {\n\n    if (!this._process.settings.sampleInterval) {\n        return null;\n    }\n\n    Hoek.assert(this._process._eventLoopTimer, 'Cannot check load when sampler is not started');\n\n    const elapsed = this._process._loadBench.elapsed();\n    const load = this._process.load;\n\n    if (elapsed > this._process.settings.sampleInterval) {\n        load.eventLoopDelay = Math.max(load.eventLoopDelay, elapsed - this._process.settings.sampleInterval);\n    }\n\n    if (this.settings.maxEventLoopDelay &&\n        load.eventLoopDelay > this.settings.maxEventLoopDelay) {\n\n        return Boom.serverUnavailable('Server under heavy load (event loop)', load);\n    }\n\n    if (this.settings.maxHeapUsedBytes &&\n        load.heapUsed > this.settings.maxHeapUsedBytes) {\n\n        return Boom.serverUnavailable('Server under heavy load (heap)', load);\n    }\n\n    if (this.settings.maxRssBytes &&\n        load.rss > this.settings.maxRssBytes) {\n\n        return Boom.serverUnavailable('Server under heavy load (rss)', load);\n    }\n\n    return null;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/items/lib/index.js":"'use strict';\n\n// Load modules\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.serial = function (array, method, callback) {\n\n    if (!array.length) {\n        callback();\n    }\n    else {\n        let i = 0;\n        const iterate = function () {\n\n            const done = function (err) {\n\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    i = i + 1;\n                    if (i < array.length) {\n                        iterate();\n                    }\n                    else {\n                        callback();\n                    }\n                }\n            };\n\n            method(array[i], done, i);\n        };\n\n        iterate();\n    }\n};\n\n\nexports.parallel = function (array, method, callback) {\n\n    if (!array.length) {\n        callback();\n    }\n    else {\n        let count = 0;\n        let errored = false;\n\n        const done = function (err) {\n\n            if (!errored) {\n                if (err) {\n                    errored = true;\n                    callback(err);\n                }\n                else {\n                    count = count + 1;\n                    if (count === array.length) {\n                        callback();\n                    }\n                }\n            }\n        };\n\n        for (let i = 0; i < array.length; ++i) {\n            method(array[i], done, i);\n        }\n    }\n};\n\n\nexports.parallel.execute = function (fnObj, callback) {\n\n    const result = {};\n    if (!fnObj) {\n        return callback(null, result);\n    }\n\n    const keys = Object.keys(fnObj);\n    let count = 0;\n    let errored = false;\n\n    if (!keys.length) {\n        return callback(null, result);\n    }\n\n    const done = function (key) {\n\n        return function (err, val) {\n\n            if (!errored) {\n                if (err) {\n                    errored = true;\n                    callback(err);\n                }\n                else {\n                    result[key] = val;\n                    if (++count === keys.length) {\n                        callback(null, result);\n                    }\n                }\n            }\n        };\n    };\n\n    for (let i = 0; i < keys.length; ++i) {\n        if (!errored) {\n            const key = keys[i];\n            fnObj[key](done(key));\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/mimos/lib/index.js":"'use strict';\r\n\r\n// Load modules\r\n\r\nconst Path = require('path');\r\nconst Hoek = require('hoek');\r\nconst MimeDb = require('mime-db');\r\n\r\n\r\n// Declare internals\r\n\r\nconst internals = {};\r\n\r\n\r\ninternals.compressibleRx = /^text\\/|\\+json$|\\+text$|\\+xml$/;\r\ninternals.compile = function (override) {\r\n\r\n    const db = Hoek.clone(MimeDb);\r\n    Hoek.merge(db, override, true, false);\r\n\r\n    const result = {\r\n        byType: db,\r\n        byExtension: {}\r\n    };\r\n\r\n    const keys = Object.keys(result.byType);\r\n    for (let i = 0; i < keys.length; ++i) {\r\n        const type = keys[i];\r\n        const mime = result.byType[type];\r\n        mime.type = mime.type || type;\r\n        mime.source = mime.source || 'mime-db';\r\n        mime.extensions = mime.extensions || [];\r\n        mime.compressible = (mime.compressible !== undefined ? mime.compressible : internals.compressibleRx.test(type));\r\n\r\n        Hoek.assert(!mime.predicate || typeof mime.predicate === 'function', 'predicate option must be a function');\r\n\r\n        for (let j = 0; j < mime.extensions.length; ++j) {\r\n            const ext = mime.extensions[j];\r\n            result.byExtension[ext] = mime;\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n\r\nmodule.exports = class Mimos {\r\n    constructor(options) {\r\n\r\n        options = options || {};\r\n        const result = options.override ? internals.compile(options.override) : internals.base;\r\n        this._byType = result.byType;\r\n        this._byExtension = result.byExtension;\r\n    }\r\n    path(path) {\r\n\r\n        const extension = Path.extname(path).slice(1).toLowerCase();\r\n        const mime = this._byExtension[extension] || {};\r\n\r\n        if (mime.predicate) {\r\n            return mime.predicate(Hoek.clone(mime));\r\n        }\r\n\r\n        return mime;\r\n    }\r\n    type(type) {\r\n\r\n        type = type.split(';', 1)[0].trim().toLowerCase();\r\n        let mime = this._byType[type];\r\n        if (!mime) {\r\n            mime = {\r\n                type: type,\r\n                source: 'mimos',\r\n                extensions: [],\r\n                compressible: internals.compressibleRx.test(type)\r\n            };\r\n\r\n            this._byType[type] = mime;\r\n            return mime;\r\n        }\r\n\r\n        if (mime.predicate) {\r\n            return mime.predicate(Hoek.clone(mime));\r\n        }\r\n\r\n        return mime;\r\n    }\r\n};\r\n\r\ninternals.base = internals.compile();       // Prevents an expensive copy on each constructor when no customization is needed\r\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/mime-db/index.js":"/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = require('./db.json')\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/connection.js":"'use strict';\n\n// Load modules\n\nconst Http = require('http');\nconst Https = require('https');\nconst Os = require('os');\nconst Path = require('path');\nconst Boom = require('boom');\nconst Call = require('call');\nconst Hoek = require('hoek');\nconst Podium = require('podium');\nconst Shot = require('shot');\nconst Statehood = require('statehood');\nconst Auth = require('./auth');\nconst Compression = require('./compression');\nconst Cors = require('./cors');\nconst Ext = require('./ext');\nconst Route = require('./route');\n\n\n// Declare internals\n\nconst internals = {\n    counter: {\n        min: 10000,\n        max: 99999\n    }\n};\n\n\nexports = module.exports = internals.Connection = function (server, options) {\n\n    const now = Date.now();\n\n    Podium.call(this, internals.Connection._events);\n\n    this.settings = options;                                                        // options cloned in server.connection()\n    this.server = server;\n\n    // Normalize settings\n\n    this.settings.labels = Hoek.unique(this.settings.labels || []);                 // Remove duplicates\n    if (this.settings.port === undefined) {\n        this.settings.port = 0;\n    }\n\n    this.type = (typeof this.settings.port === 'string' ? 'socket' : 'tcp');\n    if (this.type === 'socket') {\n        this.settings.port = (this.settings.port.indexOf('/') !== -1 ? Path.resolve(this.settings.port) : this.settings.port.toLowerCase());\n    }\n\n    if (this.settings.autoListen === undefined) {\n        this.settings.autoListen = true;\n    }\n\n    Hoek.assert(this.settings.autoListen || !this.settings.port, 'Cannot specify port when autoListen is false');\n    Hoek.assert(this.settings.autoListen || !this.settings.address, 'Cannot specify address when autoListen is false');\n\n    // Connection facilities\n\n    this._started = false;\n    this._connections = {};\n    this._onConnection = null;          // Used to remove event listener on stop\n    this.registrations = {};            // Tracks plugin for dependency validation { name -> { version } }\n\n    this._extensions = {\n        onRequest: new Ext('onRequest', this.server),\n        onPreAuth: new Ext('onPreAuth', this.server),\n        onPostAuth: new Ext('onPostAuth', this.server),\n        onPreHandler: new Ext('onPreHandler', this.server),\n        onPostHandler: new Ext('onPostHandler', this.server),\n        onPreResponse: new Ext('onPreResponse', this.server)\n    };\n\n    this._requestCounter = { value: internals.counter.min, min: internals.counter.min, max: internals.counter.max };\n    this._load = server._heavy.policy(this.settings.load);\n    this._compression = new Compression();\n    this.states = new Statehood.Definitions(this.settings.state);\n    this.auth = new Auth(this);\n    this._router = new Call.Router(this.settings.router);\n    this._defaultRoutes();\n\n    this.plugins = {};                  // Registered plugin APIs by plugin name\n    this.app = {};                      // Place for application-specific state without conflicts with hapi, should not be used by plugins\n\n    // Create listener\n\n    this.listener = this.settings.listener || (this.settings.tls ? Https.createServer(this.settings.tls) : Http.createServer());\n    this.listener.on('request', this._dispatch());\n    this._init();\n\n    this.listener.on('clientError', (err, socket) => {\n\n        this.server._log(['connection', 'client', 'error'], err);\n    });\n\n    // Connection information\n\n    this.info = {\n        created: now,\n        started: 0,\n        host: this.settings.host || Os.hostname() || 'localhost',\n        port: this.settings.port,\n        protocol: this.type === 'tcp' ? (this.settings.tls ? 'https' : 'http') : this.type,\n        id: Os.hostname() + ':' + process.pid + ':' + now.toString(36)\n    };\n\n    this.info.uri = (this.settings.uri || (this.info.protocol + ':' + (this.type === 'tcp' ? '//' + this.info.host + (this.info.port ? ':' + this.info.port : '') : this.info.port)));\n\n    this.on('route', Cors.options);\n};\n\nHoek.inherits(internals.Connection, Podium);\n\n\ninternals.Connection._events = [\n    { name: 'route', spread: true },\n    { name: 'request-internal', spread: true, tags: true },\n    { name: 'request', spread: true, tags: true },\n    { name: 'request-error', spread: true },\n    'response',\n    'tail'\n];\n\n\n\ninternals.Connection.prototype._init = function () {\n\n    // Setup listener\n\n    this.listener.once('listening', () => {\n\n        // Update the address, port, and uri with active values\n\n        if (this.type === 'tcp') {\n            const address = this.listener.address();\n            this.info.address = address.address;\n            this.info.port = address.port;\n            this.info.uri = (this.settings.uri || (this.info.protocol + '://' + this.info.host + ':' + this.info.port));\n        }\n\n        this._onConnection = (connection) => {\n\n            const key = connection.remoteAddress + ':' + connection.remotePort;\n            this._connections[key] = connection;\n\n            connection.once('close', () => {\n\n                delete this._connections[key];\n            });\n        };\n\n        this.listener.on(this.settings.tls ? 'secureConnection' : 'connection', this._onConnection);\n    });\n};\n\n\ninternals.Connection.prototype._start = function (callback) {\n\n    if (this._started) {\n        return process.nextTick(callback);\n    }\n\n    this._started = true;\n    this.info.started = Date.now();\n\n    if (!this.settings.autoListen) {\n        return process.nextTick(callback);\n    }\n\n    const onError = (err) => {\n\n        this._started = false;\n        return callback(err);\n    };\n\n    this.listener.once('error', onError);\n\n    const finalize = () => {\n\n        this.listener.removeListener('error', onError);\n        callback();\n    };\n\n    if (this.type !== 'tcp') {\n        this.listener.listen(this.settings.port, finalize);\n    }\n    else {\n        const address = this.settings.address || this.settings.host || '0.0.0.0';\n        this.listener.listen(this.settings.port, address, finalize);\n    }\n};\n\n\ninternals.Connection.prototype._stop = function (options, callback) {\n\n    if (!this._started) {\n        return process.nextTick(callback);\n    }\n\n    this._started = false;\n    this.info.started = 0;\n\n    const timeoutId = setTimeout(() => {\n\n        Object.keys(this._connections).forEach((key) => {\n\n            this._connections[key].destroy();\n        });\n\n\n        this._connections = {};\n    }, options.timeout);\n\n    this.listener.close(() => {\n\n        this.listener.removeListener(this.settings.tls ? 'secureConnection' : 'connection', this._onConnection);\n        clearTimeout(timeoutId);\n\n        this._init();\n        return callback();\n    });\n\n    // Tell idle keep-alive connections to close\n\n    Object.keys(this._connections).forEach((key) => {\n\n        const connection = this._connections[key];\n        if (!connection._isHapiProcessing) {\n            connection.end();\n        }\n    });\n};\n\n\ninternals.Connection.prototype._dispatch = function (options) {\n\n    options = options || {};\n\n    return (req, res) => {\n\n        // Track socket request processing state\n\n        if (req.socket) {\n            req.socket._isHapiProcessing = true;\n            res.on('finish', () => {\n\n                req.socket._isHapiProcessing = false;\n                if (!this._started) {\n                    req.socket.end();\n                }\n            });\n        }\n\n        // Create request\n\n        const request = this.server._requestor.request(this, req, res, options);\n\n        // Check load\n\n        const overload = this._load.check();\n        if (overload) {\n            this.server._log(['load'], this.server.load);\n            request._reply(overload);\n        }\n        else {\n\n            // Execute request lifecycle\n\n            request._protect.enter(() => {\n\n                request._execute();\n            });\n        }\n    };\n};\n\n\ninternals.Connection.prototype.inject = function (options, callback) {\n\n    if (!callback) {\n        return new Promise((resolve, reject) => this.inject(options, (res) => resolve(res)));\n    }\n\n    let settings = options;\n    if (typeof settings === 'string') {\n        settings = { url: settings };\n    }\n\n    if (!settings.authority ||\n        settings.credentials ||\n        settings.app ||\n        settings.plugins ||\n        settings.allowInternals !== undefined) {        // Can be false\n\n        settings = Hoek.shallow(settings);              // options can be reused\n        delete settings.credentials;\n        delete settings.artifacts;                      // Cannot appear without credentials\n        delete settings.app;\n        delete settings.plugins;\n        delete settings.allowInternals;\n\n        settings.authority = settings.authority || (this.info.host + ':' + this.info.port);\n    }\n\n    const needle = this._dispatch({\n        credentials: options.credentials,\n        artifacts: options.artifacts,\n        allowInternals: options.allowInternals,\n        app: options.app,\n        plugins: options.plugins\n    });\n\n    Shot.inject(needle, settings, (res) => {\n\n        if (res.raw.res._hapi) {\n            res.result = res.raw.res._hapi.result;\n            res.request = res.raw.res._hapi.request;\n            delete res.raw.res._hapi;\n        }\n\n        if (res.result === undefined) {\n            res.result = res.payload;\n        }\n\n        return callback(res);\n    });\n};\n\n\ninternals.Connection.prototype.table = function (host) {\n\n    return this._router.table(host);\n};\n\n\ninternals.Connection.prototype.lookup = function (id) {\n\n    Hoek.assert(id && typeof id === 'string', 'Invalid route id:', id);\n\n    const record = this._router.ids[id];\n    if (!record) {\n        return null;\n    }\n\n    return record.route.public;\n};\n\n\ninternals.Connection.prototype.match = function (method, path, host) {\n\n    Hoek.assert(method && typeof method === 'string', 'Invalid method:', method);\n    Hoek.assert(path && typeof path === 'string' && path[0] === '/', 'Invalid path:', path);\n    Hoek.assert(!host || typeof host === 'string', 'Invalid host:', host);\n\n    const match = this._router.route(method.toLowerCase(), path, host);\n    Hoek.assert(match !== this._router.specials.badRequest, 'Invalid path:', path);\n    if (match === this._router.specials.notFound) {\n        return null;\n    }\n\n    return match.route.public;\n};\n\n\ninternals.Connection.prototype.decoder = function (encoding, decoder) {\n\n    return this._compression.addDecoder(encoding, decoder);\n};\n\n\ninternals.Connection.prototype.encoder = function (encoding, encoder) {\n\n    return this._compression.addEncoder(encoding, encoder);\n};\n\n\ninternals.Connection.prototype._ext = function (event) {\n\n    const type = event.type;\n    Hoek.assert(this._extensions[type], 'Unknown event type', type);\n    this._extensions[type].add(event);\n};\n\n\ninternals.Connection.prototype._route = function (configs, plugin) {\n\n    configs = [].concat(configs);\n    for (let i = 0; i < configs.length; ++i) {\n        const config = configs[i];\n\n        if (Array.isArray(config.method)) {\n            for (let j = 0; j < config.method.length; ++j) {\n                const method = config.method[j];\n\n                const settings = Hoek.shallow(config);\n                settings.method = method;\n                this._addRoute(settings, plugin);\n            }\n        }\n        else {\n            this._addRoute(config, plugin);\n        }\n    }\n};\n\n\ninternals.Connection.prototype._addRoute = function (config, plugin) {\n\n    const route = new Route(config, this, plugin);                // Do no use config beyond this point, use route members\n    const vhosts = [].concat(route.settings.vhost || '*');\n\n    for (let i = 0; i < vhosts.length; ++i) {\n        const vhost = vhosts[i];\n        const record = this._router.add({ method: route.method, path: route.path, vhost, analysis: route._analysis, id: route.settings.id }, route);\n        route.fingerprint = record.fingerprint;\n        route.params = record.params;\n    }\n\n    this.emit('route', [route.public, this, plugin]);\n};\n\n\ninternals.Connection.prototype._defaultRoutes = function () {\n\n    this._router.special('notFound', new Route({ method: '_special', path: '/{p*}', handler: internals.notFound }, this, this.server, { special: true }));\n    this._router.special('badRequest', new Route({ method: '_special', path: '/{p*}', handler: internals.badRequest }, this, this.server, { special: true }));\n\n    if (this.settings.routes.cors) {\n        Cors.handler(this);\n    }\n};\n\n\ninternals.notFound = function (request, reply) {\n\n    return reply(Boom.notFound());\n};\n\n\ninternals.badRequest = function (request, reply) {\n\n    return reply(Boom.badRequest());\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/call/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Boom = require('boom');\nconst Regex = require('./regex');\nconst Segment = require('./segment');\n\n\n// Declare internals\n\nconst internals = {\n    pathRegex: Regex.generate(),\n    defaults: {\n        isCaseSensitive: true\n    }\n};\n\n\nexports.Router = internals.Router = function (options) {\n\n    this.settings = Hoek.applyToDefaults(internals.defaults, options || {});\n\n    this.routes = {};                               // Key: HTTP method or * for catch-all, value: sorted array of routes\n    this.ids = {};                                  // Key: route id, value: record\n    this.vhosts = null;                             // {} where Key: hostname, value: see this.routes\n\n    this.specials = {\n        badRequest: null,\n        notFound: null,\n        options: null\n    };\n};\n\n\ninternals.Router.prototype.add = function (config, route) {\n\n    const method = config.method.toLowerCase();\n\n    const vhost = config.vhost || '*';\n    if (vhost !== '*') {\n        this.vhosts = this.vhosts || {};\n        this.vhosts[vhost] = this.vhosts[vhost] || {};\n    }\n\n    const table = (vhost === '*' ? this.routes : this.vhosts[vhost]);\n    table[method] = table[method] || { routes: [], router: new Segment() };\n\n    const analysis = config.analysis || this.analyze(config.path);\n    const record = {\n        path: config.path,\n        route: route || config.path,\n        segments: analysis.segments,\n        params: analysis.params,\n        fingerprint: analysis.fingerprint,\n        settings: this.settings\n    };\n\n    // Add route\n\n    table[method].router.add(analysis.segments, record);\n    table[method].routes.push(record);\n    table[method].routes.sort(internals.sort);\n\n    const last = record.segments[record.segments.length - 1];\n    if (last.empty) {\n        table[method].router.add(analysis.segments.slice(0, -1), record);\n    }\n\n    if (config.id) {\n        Hoek.assert(!this.ids[config.id], 'Route id', config.id, 'for path', config.path, 'conflicts with existing path', this.ids[config.id] && this.ids[config.id].path);\n        this.ids[config.id] = record;\n    }\n\n    return record;\n};\n\n\ninternals.Router.prototype.special = function (type, route) {\n\n    Hoek.assert(Object.keys(this.specials).indexOf(type) !== -1, 'Unknown special route type:', type);\n\n    this.specials[type] = { route };\n};\n\n\ninternals.Router.prototype.route = function (method, path, hostname) {\n\n    const segments = path.split('/').slice(1);\n\n    const vhost = (this.vhosts && hostname && this.vhosts[hostname]);\n    const route = (vhost && this._lookup(path, segments, vhost, method)) ||\n                this._lookup(path, segments, this.routes, method) ||\n                (method === 'head' && vhost && this._lookup(path, segments, vhost, 'get')) ||\n                (method === 'head' && this._lookup(path, segments, this.routes, 'get')) ||\n                (method === 'options' && this.specials.options) ||\n                (vhost && this._lookup(path, segments, vhost, '*')) ||\n                this._lookup(path, segments, this.routes, '*') ||\n                this.specials.notFound || Boom.notFound();\n\n    return route;\n};\n\n\ninternals.Router.prototype._lookup = function (path, segments, table, method) {\n\n    const set = table[method];\n    if (!set) {\n        return null;\n    }\n\n    const match = set.router.lookup(path, segments, this.settings);\n    if (!match) {\n        return null;\n    }\n\n    const assignments = {};\n    const array = [];\n    for (let i = 0; i < match.array.length; ++i) {\n        const name = match.record.params[i];\n        const value = internals.decode(match.array[i]);\n        if (value.isBoom) {\n            return this.specials.badRequest || value;\n        }\n\n        if (assignments[name] !== undefined) {\n            assignments[name] = assignments[name] + '/' + value;\n        }\n        else {\n            assignments[name] = value;\n        }\n\n        if (i + 1 === match.array.length ||                 // Only include the last segment of a multi-segment param\n            name !== match.record.params[i + 1]) {\n\n            array.push(assignments[name]);\n        }\n    }\n\n    return { params: assignments, paramsArray: array, route: match.record.route };\n};\n\n\ninternals.decode = function (value) {\n\n    try {\n        return decodeURIComponent(value);\n    }\n    catch (err) {\n        return Boom.badRequest('Invalid request path');\n    }\n};\n\n\ninternals.Router.prototype.normalize = function (path) {\n\n    if (path &&\n        path.indexOf('%') !== -1) {\n\n        // Uppercase %encoded values\n\n        const uppercase = path.replace(/%[0-9a-fA-F][0-9a-fA-F]/g, (encoded) => encoded.toUpperCase());\n\n        // Decode non-reserved path characters: a-z A-Z 0-9 _!$&'()*+,;=:@-.~\n        // ! (%21) $ (%24) & (%26) ' (%27) ( (%28) ) (%29) * (%2A) + (%2B) , (%2C) - (%2D) . (%2E)\n        // 0-9 (%30-39) : (%3A) ; (%3B) = (%3D)\n        // @ (%40) A-Z (%41-5A) _ (%5F) a-z (%61-7A) ~ (%7E)\n\n        const decoded = uppercase.replace(/%(?:2[146-9A-E]|3[\\dABD]|4[\\dA-F]|5[\\dAF]|6[1-9A-F]|7[\\dAE])/g, (encoded) => String.fromCharCode(parseInt(encoded.substring(1), 16)));\n\n        path = decoded;\n    }\n\n    return path;\n};\n\n\ninternals.Router.prototype.analyze = function (path) {\n\n    Hoek.assert(internals.pathRegex.validatePath.test(path), 'Invalid path:', path);\n    Hoek.assert(!internals.pathRegex.validatePathEncoded.test(path), 'Path cannot contain encoded non-reserved path characters:', path);\n\n    const pathParts = path.split('/');\n    const segments = [];\n    const params = [];\n    const fingers = [];\n\n    for (let i = 1; i < pathParts.length; ++i) {                            // Skip first empty segment\n        let segment = pathParts[i];\n\n        // Literal\n\n        if (segment.indexOf('{') === -1) {\n            segment = this.settings.isCaseSensitive ? segment : segment.toLowerCase();\n            fingers.push(segment);\n            segments.push({ literal: segment });\n            continue;\n        }\n\n        // Parameter\n\n        const parts = internals.parseParams(segment);\n        if (parts.length === 1) {\n\n            // Simple parameter\n\n            const item = parts[0];\n            Hoek.assert(params.indexOf(item.name) === -1, 'Cannot repeat the same parameter name:', item.name, 'in:', path);\n            params.push(item.name);\n\n            if (item.wilcard) {\n                if (item.count) {\n                    for (let j = 0; j < item.count; ++j) {\n                        fingers.push('?');\n                        segments.push({});\n                        if (j) {\n                            params.push(item.name);\n                        }\n                    }\n                }\n                else {\n                    fingers.push('#');\n                    segments.push({ wildcard: true });\n                }\n            }\n            else {\n                fingers.push('?');\n                segments.push({ empty: item.empty });\n            }\n        }\n        else {\n\n            // Mixed parameter\n\n            const seg = {\n                length: parts.length,\n                first: typeof parts[0] !== 'string',\n                segments: []\n            };\n\n            let finger = '';\n            let regex = '^';\n            for (let j = 0; j < parts.length; ++j) {\n                const part = parts[j];\n                if (typeof part === 'string') {\n                    finger = finger + part;\n                    regex = regex + Hoek.escapeRegex(part);\n                    seg.segments.push(part);\n                }\n                else {\n                    Hoek.assert(params.indexOf(part.name) === -1, 'Cannot repeat the same parameter name:', part.name, 'in:', path);\n                    params.push(part.name);\n\n                    finger = finger + '?';\n                    regex = regex + '(.' + (part.empty ? '*' : '+') + ')';\n                }\n            }\n\n            seg.mixed = new RegExp(regex + '$', (!this.settings.isCaseSensitive ? 'i' : ''));\n            fingers.push(finger);\n            segments.push(seg);\n        }\n    }\n\n    return {\n        segments,\n        fingerprint: '/' + fingers.join('/'),\n        params\n    };\n};\n\n\ninternals.parseParams = function (segment) {\n\n    const parts = [];\n    segment.replace(internals.pathRegex.parseParam, (match, literal, name, wilcard, count, empty) => {\n\n        if (literal) {\n            parts.push(literal);\n        }\n        else {\n            parts.push({\n                name,\n                wilcard: !!wilcard,\n                count: count && parseInt(count, 10),\n                empty: !!empty\n            });\n        }\n\n        return '';\n    });\n\n    return parts;\n};\n\n\ninternals.Router.prototype.table = function (host) {\n\n    const result = [];\n    const collect = (table) => {\n\n        if (!table) {\n            return;\n        }\n\n        Object.keys(table).forEach((method) => {\n\n            table[method].routes.forEach((record) => {\n\n                result.push(record.route);\n            });\n        });\n    };\n\n    if (this.vhosts) {\n        const vhosts = host ? [].concat(host) : Object.keys(this.vhosts);\n        for (let i = 0; i < vhosts.length; ++i) {\n            collect(this.vhosts[vhosts[i]]);\n        }\n    }\n\n    collect(this.routes);\n\n    return result;\n};\n\n\ninternals.sort = function (a, b) {\n\n    const aFirst = -1;\n    const bFirst = 1;\n\n    const as = a.segments;\n    const bs = b.segments;\n\n    if (as.length !== bs.length) {\n        return (as.length > bs.length ? bFirst : aFirst);\n    }\n\n    for (let i = 0; ; ++i) {\n        if (as[i].literal) {\n            if (bs[i].literal) {\n                if (as[i].literal === bs[i].literal) {\n                    continue;\n                }\n\n                return (as[i].literal > bs[i].literal ? bFirst : aFirst);\n            }\n            return aFirst;\n        }\n        else if (bs[i].literal) {\n            return bFirst;\n        }\n\n        return (as[i].wildcard ? bFirst : aFirst);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/call/lib/regex.js":"'use strict';\n\n// Load modules\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.generate = function () {\n\n    /*\n        /path/{param}/path/{param?}\n        /path/{param*2}/path\n        /path/{param*2}\n        /path/x{param}x\n        /{param*}\n    */\n\n    const empty = '(?:^\\\\/$)';\n\n    const legalChars = '[\\\\w\\\\!\\\\$&\\'\\\\(\\\\)\\\\*\\\\+\\\\,;\\\\=\\\\:@\\\\-\\\\.~]';\n    const encoded = '%[A-F0-9]{2}';\n\n    const literalChar = '(?:' + legalChars + '|' + encoded + ')';\n    const literal = literalChar + '+';\n    const literalOptional = literalChar + '*';\n\n    const midParam = '(?:\\\\{\\\\w+(?:\\\\*[1-9]\\\\d*)?\\\\})';                               // {p}, {p*2}\n    const endParam = '(?:\\\\/(?:\\\\{\\\\w+(?:(?:\\\\*(?:[1-9]\\\\d*)?)|(?:\\\\?))?\\\\})?)?';     // {p}, {p*2}, {p*}, {p?}\n\n    const partialParam = '(?:\\\\{\\\\w+\\\\??\\\\})';                                        // {p}, {p?}\n    const mixedParam = '(?:(?:' + literal + partialParam + ')+' + literalOptional + ')|(?:' + partialParam + '(?:' + literal + partialParam + ')+' + literalOptional + ')|(?:' + partialParam + literal + ')';\n\n    const segmentContent = '(?:' + literal + '|' + midParam + '|' + mixedParam + ')';\n    const segment = '\\\\/' + segmentContent;\n    const segments = '(?:' + segment + ')*';\n\n    const path = '(?:^' + segments + endParam + '$)';\n\n    //                1:literal               2:name   3:*  4:count  5:?\n    const parseParam = '(' + literal + ')|(?:\\\\{(\\\\w+)(?:(\\\\*)(\\\\d+)?)?(\\\\?)?\\\\})';\n\n    const expressions = {\n        parseParam: new RegExp(parseParam, 'g'),\n        validatePath: new RegExp(empty + '|' + path),\n        validatePathEncoded: /%(?:2[146-9A-E]|3[\\dABD]|4[\\dA-F]|5[\\dAF]|6[1-9A-F]|7[\\dAE])/g\n    };\n\n    return expressions;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/call/lib/segment.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Segment = function () {\n\n    this._edge = null;              // { segment, record }\n    this._fulls = null;             // { path: { segment, record }\n    this._literals = null;          // { literal: { segment, <node> } }\n    this._param = null;             // <node>\n    this._mixed = null;             // [{ segment, <node> }]\n    this._wildcard = null;          // { segment, record }\n};\n\n\ninternals.Segment.prototype.add = function (segments, record) {\n\n    /*\n        { literal: 'x' }        -> x\n        { empty: false }        -> {p}\n        { wildcard: true }      -> {p*}\n        { mixed: /regex/ }      -> a{p}b\n    */\n\n    const current = segments[0];\n    const remaining = segments.slice(1);\n    const isEdge = !remaining.length;\n\n    const literals = [];\n    let isLiteral = true;\n    for (let i = 0; i < segments.length && isLiteral; ++i) {\n        isLiteral = segments[i].literal !== undefined;\n        literals.push(segments[i].literal);\n    }\n\n    if (isLiteral) {\n        this._fulls = this._fulls || {};\n        let literal = '/' + literals.join('/');\n        if (!record.settings.isCaseSensitive) {\n            literal = literal.toLowerCase();\n        }\n\n        Hoek.assert(!this._fulls[literal], 'New route', record.path, 'conflicts with existing', this._fulls[literal] && this._fulls[literal].record.path);\n        this._fulls[literal] = { segment: current, record };\n    }\n    else if (current.literal !== undefined) {               // Can be empty string\n\n        // Literal\n\n        this._literals = this._literals || {};\n        const currentLiteral = (record.settings.isCaseSensitive ? current.literal : current.literal.toLowerCase());\n        this._literals[currentLiteral] = this._literals[currentLiteral] || new internals.Segment();\n        this._literals[currentLiteral].add(remaining, record);\n    }\n    else if (current.wildcard) {\n\n        // Wildcard\n\n        Hoek.assert(!this._wildcard, 'New route', record.path, 'conflicts with existing', this._wildcard && this._wildcard.record.path);\n        Hoek.assert(!this._param || !this._param._wildcard, 'New route', record.path, 'conflicts with existing', this._param && this._param._wildcard && this._param._wildcard.record.path);\n        this._wildcard = { segment: current, record };\n    }\n    else if (current.mixed) {\n\n        // Mixed\n\n        this._mixed = this._mixed || [];\n\n        let mixed = this._mixedLookup(current);\n        if (!mixed) {\n            mixed = { segment: current, node: new internals.Segment() };\n            this._mixed.push(mixed);\n            this._mixed.sort(internals.mixed);\n        }\n\n        if (isEdge) {\n            Hoek.assert(!mixed.node._edge, 'New route', record.path, 'conflicts with existing', mixed.node._edge && mixed.node._edge.record.path);\n            mixed.node._edge = { segment: current, record };\n        }\n        else {\n            mixed.node.add(remaining, record);\n        }\n    }\n    else {\n\n        // Parameter\n\n        this._param = this._param || new internals.Segment();\n\n        if (isEdge) {\n            Hoek.assert(!this._param._edge, 'New route', record.path, 'conflicts with existing', this._param._edge && this._param._edge.record.path);\n            this._param._edge = { segment: current, record };\n        }\n        else {\n            Hoek.assert(!this._wildcard || !remaining[0].wildcard, 'New route', record.path, 'conflicts with existing', this._wildcard && this._wildcard.record.path);\n            this._param.add(remaining, record);\n        }\n    }\n};\n\n\ninternals.Segment.prototype._mixedLookup = function (segment) {\n\n    for (let i = 0; i < this._mixed.length; ++i) {\n        if (internals.mixed({ segment }, this._mixed[i]) === 0) {\n            return this._mixed[i];\n        }\n    }\n\n    return null;\n};\n\n\ninternals.mixed = function (a, b) {\n\n    const aFirst = -1;\n    const bFirst = 1;\n\n    const as = a.segment;\n    const bs = b.segment;\n\n    if (as.length !== bs.length) {\n        return (as.length > bs.length ? aFirst : bFirst);\n    }\n\n    if (as.first !== bs.first) {\n        return (as.first ? bFirst : aFirst);\n    }\n\n    for (let i = 0; i < as.segments.length; ++i) {\n        const am = as.segments[i];\n        const bm = bs.segments[i];\n\n        if (am === bm) {\n            continue;\n        }\n\n        if (am.length === bm.length) {\n            return (am > bm ? bFirst : aFirst);\n        }\n\n        return (am.length < bm.length ? bFirst : aFirst);\n    }\n\n    return 0;\n};\n\n\ninternals.Segment.prototype.lookup = function (path, segments, options) {\n\n    let match = null;\n\n    // Literal edge\n\n    if (this._fulls) {\n        match = this._fulls[options.isCaseSensitive ? path : path.toLowerCase()];\n        if (match) {\n            return { record: match.record, array: [] };\n        }\n    }\n\n    // Literal node\n\n    const current = segments[0];\n    const nextPath = path.slice(current.length + 1);\n    const remainder = (segments.length > 1 ? segments.slice(1) : null);\n\n    if (this._literals) {\n        const literal = options.isCaseSensitive ? current : current.toLowerCase();\n        match = this._literals.hasOwnProperty(literal) && this._literals[literal];\n        if (match) {\n            const record = internals.deeper(match, nextPath, remainder, [], options);\n            if (record) {\n                return record;\n            }\n        }\n    }\n\n    // Mixed\n\n    if (this._mixed) {\n        for (let i = 0; i < this._mixed.length; ++i) {\n            match = this._mixed[i];\n            const params = current.match(match.segment.mixed);\n            if (params) {\n                const array = [];\n                for (let j = 1; j < params.length; ++j) {\n                    array.push(params[j]);\n                }\n\n                const record = internals.deeper(match.node, nextPath, remainder, array, options);\n                if (record) {\n                    return record;\n                }\n            }\n        }\n    }\n\n    // Param\n\n    if (this._param) {\n        if (current ||\n            (this._param._edge && this._param._edge.segment.empty)) {\n\n            const record = internals.deeper(this._param, nextPath, remainder, [current], options);\n            if (record) {\n                return record;\n            }\n        }\n    }\n\n    // Wildcard\n\n    if (this._wildcard) {\n        return { record: this._wildcard.record, array: [path.slice(1)] };\n    }\n\n    return null;\n};\n\n\ninternals.deeper = function (match, path, segments, array, options) {\n\n    if (!segments) {\n        if (match._edge) {\n            return { record: match._edge.record, array };\n        }\n\n        if (match._wildcard) {\n            return { record: match._wildcard.record, array };\n        }\n    }\n    else {\n        const result = match.lookup(path, segments, options);\n        if (result) {\n            return { record: result.record, array: array.concat(result.array) };\n        }\n    }\n\n    return null;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/podium/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Items = require('items');\nconst Joi = require('joi');\n\n\n// Declare internals\n\nconst internals = {\n    schema: {\n        base: Joi.object({\n            name: Joi.string().required(),\n            clone: Joi.boolean(),\n            tags: Joi.boolean(),\n            spread: Joi.boolean(),\n            channels: Joi.array().items(Joi.string()).single().unique().min(1)\n        })\n    }\n};\n\n\ninternals.schema.event = internals.schema.base.keys({\n    shared: Joi.boolean()\n});\n\n\ninternals.schema.listener = internals.schema.event.keys({\n    listener: Joi.func().required(),\n    block: Joi.number().integer().min(1).allow(true),\n    count: Joi.number().integer().min(1),\n    filter: {\n        tags: Joi.array().items(Joi.string()).single().unique().min(1).required(),\n        all: Joi.boolean()\n    }\n});\n\n\nexports = module.exports = internals.Podium = function (events) {\n\n    // Use descriptive names to avoid conflict when inherited\n\n    this._eventListeners = Object.create(null);\n    this._notificationsQueue = [];\n    this._eventsProcessing = false;\n    this._sourcePodiums = [];\n\n    if (events) {\n        this.registerEvent(events);\n    }\n};\n\n\ninternals.Podium.prototype.registerEvent = function (events) {\n\n    events = Hoek.flatten([].concat(events));\n    events.forEach((event) => {\n\n        if (!event) {\n            return;\n        }\n\n        if (event instanceof internals.Podium) {\n            return this.registerPodium(event);\n        }\n\n        if (typeof event === 'string') {\n            event = { name: event };\n        }\n\n        event = Joi.attempt(event, internals.schema.event, 'Invalid event options');\n\n        const name = event.name;\n        if (this._eventListeners[name]) {\n            Hoek.assert(event.shared, `Event ${name} exists`);\n            return;\n        }\n\n        this._eventListeners[name] = { handlers: null, flags: event };\n        this._sourcePodiums.forEach((podium) => {\n\n            if (!podium._eventListeners[name]) {\n                podium._eventListeners[name] = { handlers: null, flags: event };\n            }\n        });\n    });\n};\n\n\ninternals.Podium.prototype.registerPodium = function (podiums) {\n\n    [].concat(podiums).forEach((podium) => {\n\n        if (podium._sourcePodiums.indexOf(this) !== -1) {\n            return;\n        }\n\n        podium._sourcePodiums.push(this);\n        Object.keys(podium._eventListeners).forEach((name) => {\n\n            if (!this._eventListeners[name]) {\n                this._eventListeners[name] = { handlers: null, flags: podium._eventListeners[name].flags };\n            }\n        });\n    });\n};\n\n\ninternals.Podium.prototype.emit = function (criteria, data, callback) {\n\n    return this._emit(criteria, data, false, callback);\n};\n\n\ninternals.Podium.prototype._emit = function (criteria, data, generated, callback) {\n\n    criteria = internals.criteria(criteria);\n\n    const name = criteria.name;\n    Hoek.assert(name, 'Criteria missing event name');\n\n    const event = this._eventListeners[name];\n    Hoek.assert(event, `Unknown event ${name}`);\n    Hoek.assert(!event.flags.spread || Array.isArray(data) || typeof data === 'function', 'Data must be an array for spread event');\n    Hoek.assert(!criteria.channel || typeof criteria.channel === 'string', 'Invalid channel name');\n    Hoek.assert(!criteria.channel || !event.flags.channels || event.flags.channels.indexOf(criteria.channel) !== -1, `Unknown ${criteria.channel} channel`);\n\n    if (typeof criteria.tags === 'string') {\n        criteria.tags = [criteria.tags];\n    }\n\n    if (criteria.tags &&\n        Array.isArray(criteria.tags)) {\n\n        criteria.tags = Hoek.mapToObject(criteria.tags);\n    }\n\n    internals.emit(this, { criteria, data, callback, generated });\n};\n\n\ninternals.emit = function (emitter, notification) {\n\n    if (notification) {\n        emitter._notificationsQueue.push(notification);\n    }\n\n    if (emitter._eventsProcessing ||\n        !emitter._notificationsQueue.length) {\n\n        return;\n    }\n\n    emitter._eventsProcessing = true;\n    const item = emitter._notificationsQueue.shift();\n\n    const event = emitter._eventListeners[item.criteria.name];\n    const handlers = event.handlers;\n\n    const finalize = () => {\n\n        if (item.callback) {\n            process.nextTick(internals.itemCallback, item);\n        }\n\n        emitter._eventsProcessing = false;\n        process.nextTick(internals.emitEmitter, emitter);\n    };\n\n    let data = item.data;\n    let generated = item.generated;\n\n    const relay = () => {\n\n        if (!emitter._sourcePodiums.length) {\n            return finalize();\n        }\n\n        const each = (podium, next) => podium._emit(item.criteria, data, generated, next);        // User _emit() in case emit() was modified\n        Items.parallel(emitter._sourcePodiums.slice(), each, finalize);\n    };\n\n    if (!handlers) {\n        return relay();\n    }\n\n    const each = (handler, next) => {\n\n        if (handler.count) {\n            --handler.count;\n            if (handler.count < 1) {\n                internals.removeHandler(emitter, item.criteria.name, handler);\n            }\n        }\n\n        const invoke = (func) => {\n\n            if (handler.channels &&\n                (!item.criteria.channel || handler.channels.indexOf(item.criteria.channel) === -1)) {\n\n                return;\n            }\n\n            if (handler.filter) {\n                if (!item.criteria.tags) {\n                    return;\n                }\n\n                const match = Hoek.intersect(item.criteria.tags, handler.filter.tags, !handler.filter.all);\n                if (!match ||\n                    (handler.filter.all && match.length !== handler.filter.tags.length)) {\n\n                    return;\n                }\n            }\n\n            if (!generated &&\n                typeof data === 'function') {\n\n                data = item.data();\n                generated = true;\n            }\n\n            const update = (internals.flag('clone', handler, event) ? Hoek.clone(data) : data);\n            const args = (internals.flag('spread', handler, event) && Array.isArray(update) ? update : [update]);\n\n            if (internals.flag('tags', handler, event) &&\n                item.criteria.tags) {\n\n                args.push(item.criteria.tags);\n            }\n\n            if (func) {\n                args.push(func);\n            }\n\n            handler.listener.apply(null, args);\n        };\n\n        if (!handler.block) {\n            invoke();\n            return next();\n        }\n\n        let timer = null;\n        if (handler.block !== true) {\n            next = Hoek.once(next);\n            timer = setTimeout(next, handler.block);\n        }\n\n        invoke(() => {\n\n            clearTimeout(timer);\n            return next();\n        });\n    };\n\n    return Items.parallel(handlers.slice(), each, relay);        // Clone in case handlers are changed by listeners\n};\n\n\ninternals.itemCallback = function (item) {\n\n    item.callback();\n};\n\n\ninternals.emitEmitter = function (emitter) {\n\n    internals.emit(emitter);\n};\n\n\ninternals.Podium.prototype.on = internals.Podium.prototype.addListener = function (criteria, listener) {\n\n    criteria = internals.criteria(criteria);\n    criteria.listener = listener;\n\n    if (criteria.filter &&\n        (typeof criteria.filter === 'string' || Array.isArray(criteria.filter))) {\n\n        criteria.filter = { tags: criteria.filter };\n    }\n\n    criteria = Joi.attempt(criteria, internals.schema.listener, 'Invalid event listener options');\n\n    const name = criteria.name;\n    const event = this._eventListeners[name];\n    Hoek.assert(event, `Unknown event ${name}`);\n    Hoek.assert(!criteria.channels || !event.flags.channels || Hoek.intersect(event.flags.channels, criteria.channels).length === criteria.channels.length, `Unknown event channels ${criteria.channels && criteria.channels.join(', ')}`);\n\n    this._eventListeners[name].handlers = this._eventListeners[name].handlers || [];\n    this._eventListeners[name].handlers.push(criteria);\n\n    return this;\n};\n\n\ninternals.Podium.prototype.once = function (criteria, listener) {\n\n    criteria = internals.criteria(criteria);\n    return this.on(Object.assign(criteria, { count: 1 }), listener);\n};\n\n\ninternals.Podium.prototype.removeListener = function (name, listener) {\n\n    Hoek.assert(this._eventListeners[name], `Unknown event ${name}`);\n    Hoek.assert(typeof listener === 'function', 'Listener must be a function');\n\n    const handlers = this._eventListeners[name].handlers;\n    if (!handlers) {\n        return this;\n    }\n\n    const filtered = handlers.filter((handler) => handler.listener !== listener);\n    this._eventListeners[name].handlers = (filtered.length ? filtered : null);\n    return this;\n};\n\n\ninternals.Podium.prototype.removeAllListeners = function (name) {\n\n    Hoek.assert(this._eventListeners[name], `Unknown event ${name}`);\n    this._eventListeners[name].handlers = null;\n    return this;\n};\n\n\ninternals.Podium.prototype.hasListeners = function (name) {\n\n    Hoek.assert(this._eventListeners[name], `Unknown event ${name}`);\n    return !!this._eventListeners[name].handlers;\n};\n\n\ninternals.removeHandler = function (emitter, name, handler) {\n\n    const handlers = emitter._eventListeners[name].handlers;\n    const filtered = handlers.filter((item) => item !== handler);\n    emitter._eventListeners[name].handlers = (filtered.length ? filtered : null);\n};\n\n\ninternals.criteria = function (criteria) {\n\n    return (typeof criteria === 'string' ? { name: criteria } : criteria);\n};\n\n\ninternals.flag = function (name, handler, event) {\n\n    return (handler[name] !== undefined ? handler[name] : event.flags[name]) || false;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/shot/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Joi = require('joi');\nconst Request = require('./request');\nconst Response = require('./response');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.options = Joi.object().keys({\n    url: Joi.alternatives([\n        Joi.string(),\n        Joi.object().keys({\n            protocol: Joi.string(),\n            hostname: Joi.string(),\n            port: Joi.any(),\n            pathname: Joi.string().required(),\n            query: Joi.any()\n        })\n    ])\n        .required(),\n    headers: Joi.object(),\n    payload: Joi.any(),\n    simulate: {\n        end: Joi.boolean(),\n        split: Joi.boolean(),\n        error: Joi.boolean(),\n        close: Joi.boolean()\n    },\n    authority: Joi.string(),\n    remoteAddress: Joi.string(),\n    method: Joi.string(),\n    validate: Joi.boolean()\n});\n\n\nexports.inject = function (dispatchFunc, options, callback) {\n\n    options = (typeof options === 'string' ? { url: options } : options);\n\n    if (options.validate !== false) {                                                           // Defaults to true\n        Hoek.assert(typeof dispatchFunc === 'function', 'Invalid dispatch function');\n        Joi.assert(options, internals.options);\n    }\n\n    const req = new Request(options);\n    const res = new Response(req, callback);\n\n    return req.prepare(() => dispatchFunc(req, res));\n};\n\n\nexports.isInjection = function (obj) {\n\n    return (obj instanceof Request || obj instanceof Response);\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/shot/lib/request.js":"'use strict';\n\n// Load modules\n\nconst Stream = require('stream');\nconst Url = require('url');\nconst Util = require('util');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Request = function (options) {\n\n    Stream.Readable.call(this);\n\n    // options: method, url, payload, headers, remoteAddress\n\n    let url = options.url;\n    if (typeof url === 'object') {\n        url = Url.format(url);\n    }\n\n    const uri = Url.parse(url);\n    this.url = uri.path;\n\n    this.httpVersion = '1.1';\n    this.method = (options.method ? options.method.toUpperCase() : 'GET');\n\n    this.headers = {};\n    const headers = options.headers || {};\n    const fields = Object.keys(headers);\n    fields.forEach((field) => {\n\n        this.headers[field.toLowerCase()] = headers[field];\n    });\n\n    this.headers['user-agent'] = this.headers['user-agent'] || 'shot';\n\n    const hostHeaderFromUri = function () {\n\n        if (uri.port) {\n            return uri.host;\n        }\n\n        if (uri.protocol) {\n            return uri.hostname + (uri.protocol === 'https:' ? ':443' : ':80');\n        }\n\n        return null;\n    };\n    this.headers.host = this.headers.host || hostHeaderFromUri() || options.authority || 'localhost:80';\n\n    this.connection = {\n        remoteAddress: options.remoteAddress || '127.0.0.1'\n    };\n\n    let payload = options.payload || null;\n    if (payload &&\n        typeof payload !== 'string' &&\n        !(payload instanceof Stream) &&\n        !Buffer.isBuffer(payload)) {\n\n        payload = JSON.stringify(payload);\n        this.headers['content-type'] = this.headers['content-type'] || 'application/json';\n    }\n\n    // Set the content-length for the corresponding payload if none set\n\n    if (payload &&\n        !(payload instanceof Stream) &&\n        !this.headers.hasOwnProperty('content-length')) {\n\n        this.headers['content-length'] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();\n    }\n\n    // Use _shot namespace to avoid collision with Node\n\n    this._shot = {\n        payload,\n        isDone: false,\n        simulate: options.simulate || {}\n    };\n\n    return this;\n};\n\nUtil.inherits(internals.Request, Stream.Readable);\n\n\ninternals.Request.prototype.prepare = function (next) {\n\n    if (this._shot.payload instanceof Stream === false) {\n        return next();\n    }\n\n    const chunks = [];\n\n    this._shot.payload.on('data', (chunk) => chunks.push(Buffer.from(chunk)));\n\n    this._shot.payload.on('end', () => {\n\n        const payload = Buffer.concat(chunks);\n        this.headers['content-length'] = this.headers['content-length'] || payload.length;\n        this._shot.payload = payload;\n        return next();\n    });\n};\n\n\ninternals.Request.prototype._read = function (size) {\n\n    setImmediate(() => {\n\n        if (this._shot.isDone) {\n            if (this._shot.simulate.end !== false) {        // 'end' defaults to true\n                this.push(null);\n            }\n\n            return;\n        }\n\n        this._shot.isDone = true;\n\n        if (this._shot.payload) {\n            if (this._shot.simulate.split) {\n                this.push(this._shot.payload.slice(0, 1));\n                this.push(this._shot.payload.slice(1));\n            }\n            else {\n                this.push(this._shot.payload);\n            }\n        }\n\n        if (this._shot.simulate.error) {\n            this.emit('error', new Error('Simulated'));\n        }\n\n        if (this._shot.simulate.close) {\n            this.emit('close');\n        }\n\n        if (this._shot.simulate.end !== false) {        // 'end' defaults to true\n            this.push(null);\n        }\n    });\n};\n\n\ninternals.Request.prototype.destroy = function () {\n\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/shot/lib/response.js":"'use strict';\n\n// Load modules\n\nconst Http = require('http');\nconst Stream = require('stream');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = class Response extends Http.ServerResponse {\n\n    constructor(req, onEnd) {\n\n        super({ method: req.method, httpVersionMajor: 1, httpVersionMinor: 1 });\n        this._shot = { trailers: {}, payloadChunks: [] };\n        this.assignSocket(internals.nullSocket());\n\n        this.once('finish', () => {\n\n            const res = internals.payload(this);\n            res.raw.req = req;\n            process.nextTick(() => onEnd(res));\n        });\n    }\n\n    writeHead() {\n\n        const headers = ((arguments.length === 2 && typeof arguments[1] === 'object') ? arguments[1] : (arguments.length === 3 ? arguments[2] : {}));\n        const result = super.writeHead.apply(this, arguments);\n\n        this._headers = Object.assign({}, this._headers, headers);\n\n        // Add raw headers\n\n        ['Date', 'Connection', 'Transfer-Encoding'].forEach((name) => {\n\n            const regex = new RegExp('\\\\r\\\\n' + name + ': ([^\\\\r]*)\\\\r\\\\n');\n            const field = this._header.match(regex);\n            if (field) {\n                this._headers[name.toLowerCase()] = field[1];\n            }\n        });\n\n        return result;\n    }\n\n    write(data, encoding) {\n\n        super.write(data, encoding);\n        this._shot.payloadChunks.push(new Buffer(data, encoding));\n        return true;                                                    // Write always returns false when disconnected\n    }\n\n    end(data, encoding) {\n\n        super.end(data, encoding);\n        this.emit('finish');\n    }\n\n    destroy() {\n\n    }\n\n    addTrailers(trailers) {\n\n        for (const key in trailers) {\n            this._shot.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();\n        }\n    }\n};\n\n\ninternals.payload = function (response) {\n\n    // Prepare response object\n\n    const res = {\n        raw: {\n            res: response\n        },\n        headers: response._headers,\n        statusCode: response.statusCode,\n        statusMessage: response.statusMessage,\n        trailers: {}\n    };\n\n    // Prepare payload and trailers\n\n    const rawBuffer = Buffer.concat(response._shot.payloadChunks);\n    res.rawPayload = rawBuffer;\n    res.payload = rawBuffer.toString();\n    res.trailers = response._shot.trailers;\n\n    return res;\n};\n\n\n// Throws away all written data to prevent response from buffering payload\n\ninternals.nullSocket = function () {\n\n    return new Stream.Writable({\n        write(chunk, encoding, callback) {\n\n            setImmediate(callback);\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/statehood/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Cryptiles = require('cryptiles');\nconst Hoek = require('hoek');\nconst Iron = require('iron');\nconst Items = require('items');\nconst Joi = require('joi');\nconst Querystring = require('querystring');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.schema = Joi.object({\n    strictHeader: Joi.boolean(),\n    ignoreErrors: Joi.boolean(),\n    isSecure: Joi.boolean(),\n    isHttpOnly: Joi.boolean(),\n    isSameSite: Joi.valid('Strict', 'Lax').allow(false),\n    path: Joi.string().allow(null),\n    domain: Joi.string().allow(null),\n    ttl: Joi.number().allow(null),\n    encoding: Joi.string().valid('base64json', 'base64', 'form', 'iron', 'none'),\n    sign: Joi.object({\n        password: [Joi.string(), Joi.binary(), Joi.object()],\n        integrity: Joi.object()\n    }),\n    iron: Joi.object(),\n    password: [Joi.string(), Joi.binary(), Joi.object()],\n\n    // Used by hapi\n\n    clearInvalid: Joi.boolean(),\n    autoValue: Joi.any(),\n    passThrough: Joi.boolean()\n});\n\n\ninternals.defaults = {\n    strictHeader: true,                             // Require an RFC 6265 compliant header format\n    ignoreErrors: false,\n    isSecure: true,\n    isHttpOnly: true,\n    isSameSite: 'Strict',\n    path: null,\n    domain: null,\n    ttl: null,                                      // MSecs, 0 means remove\n    encoding: 'none'                                // options: 'base64json', 'base64', 'form', 'iron', 'none'\n};\n\n\nexports.Definitions = internals.Definitions = function (options) {\n\n    this.settings = Hoek.applyToDefaults(internals.defaults, options || {});\n    Joi.assert(this.settings, internals.schema, 'Invalid state definition defaults');\n\n    this.cookies = {};\n    this.names = [];\n};\n\n\ninternals.Definitions.prototype.add = function (name, options) {\n\n    Hoek.assert(name && typeof name === 'string', 'Invalid name');\n    Hoek.assert(!this.cookies[name], 'State already defined:', name);\n\n    const settings = Hoek.applyToDefaults(this.settings, options || {}, true);\n    Joi.assert(settings, internals.schema, 'Invalid state definition: ' + name);\n\n    this.cookies[name] = settings;\n    this.names.push(name);\n};\n\n\ninternals.empty = new internals.Definitions();\n\n\n// Header format\n\n//                      1: name                2: quoted  3: value\ninternals.parseRx = /\\s*([^=\\s]*)\\s*=\\s*(?:(?:\"([^\\\"]*)\")|([^\\;]*))(?:(?:;\\s*)|$)/g;\n\ninternals.validateRx = {\n    nameRx: {\n        strict: /^[^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+$/,\n        loose: /^[^=\\s]*$/\n    },\n    valueRx: {\n        strict: /^[^\\x00-\\x20\\\"\\,\\;\\\\\\x7F]*$/,\n        loose: /^(?:\"([^\\\"]*)\")|(?:[^\\;]*)$/\n    },\n    domainRx: /^\\.?[a-z\\d]+(?:(?:[a-z\\d]*)|(?:[a-z\\d\\-]*[a-z\\d]))(?:\\.[a-z\\d]+(?:(?:[a-z\\d]*)|(?:[a-z\\d\\-]*[a-z\\d])))*$/,\n    domainLabelLenRx: /^\\.?[a-z\\d\\-]{1,63}(?:\\.[a-z\\d\\-]{1,63})*$/,\n    pathRx: /^\\/[^\\x00-\\x1F\\;]*$/\n};\n\n//                      1: name         2: value\ninternals.pairsRx = /\\s*([^=\\s]*)\\s*=\\s*([^\\;]*)(?:(?:;\\s*)|$)/g;\n\n\ninternals.Definitions.prototype.parse = function (cookies, next) {\n\n    const state = {};\n    const names = [];\n    const verify = cookies.replace(internals.parseRx, ($0, $1, $2, $3) => {\n\n        const name = $1;\n        const value = $2 || $3 || '';\n\n        if (state[name]) {\n            if (!Array.isArray(state[name])) {\n                state[name] = [state[name]];\n            }\n\n            state[name].push(value);\n        }\n        else {\n            state[name] = value;\n            names.push(name);\n        }\n\n        return '';\n    });\n\n    // Validate cookie header syntax\n\n    if (verify !== '') {\n        return next(Boom.badRequest('Invalid cookie header'), null, []);\n    }\n\n    // Collect errors\n\n    const failed = [];                                                // All errors\n    const errored = [];                                               // Unignored errors\n    const record = (reason, name, value, definition) => {\n\n        const details = {\n            name,\n            value,\n            settings: definition,\n            reason: typeof reason === 'string' ? reason : reason.message\n        };\n\n        failed.push(details);\n        if (!definition.ignoreErrors) {\n            errored.push(details);\n        }\n    };\n\n    // Parse cookies\n\n    const parsed = {};\n    Items.serial(names, (name, nextName) => {\n\n        const value = state[name];\n        const definition = this.cookies[name] || this.settings;\n\n        // Validate cookie\n\n        if (definition.strictHeader) {\n            if (!name.match(internals.validateRx.nameRx.strict)) {\n                record('Invalid cookie name', name, value, definition);\n                return nextName();\n            }\n\n            const values = [].concat(state[name]);\n            for (let i = 0; i < values.length; ++i) {\n                if (!values[i].match(internals.validateRx.valueRx.strict)) {\n                    record('Invalid cookie value', name, value, definition);\n                    return nextName();\n                }\n            }\n        }\n\n        // Check cookie format\n\n        if (definition.encoding === 'none') {\n            parsed[name] = value;\n            return nextName();\n        }\n\n        // Single value\n\n        if (!Array.isArray(value)) {\n            internals.unsign(name, value, definition, (err, unsigned) => {\n\n                if (err) {\n                    record(err, name, value, definition);\n                    return nextName();\n                }\n\n                internals.decode(unsigned, definition, (err, result) => {\n\n                    if (err) {\n                        record(err, name, value, definition);\n                        return nextName();\n                    }\n\n                    parsed[name] = result;\n                    return nextName();\n                });\n            });\n\n            return;\n        }\n\n        // Array\n\n        const arrayResult = [];\n        Items.serial(value, (arrayValue, nextArray) => {\n\n            internals.unsign(name, arrayValue, definition, (err, unsigned) => {\n\n                if (err) {\n                    record(err, name, value, definition);\n                    return nextName();\n                }\n\n                internals.decode(unsigned, definition, (err, result) => {\n\n                    if (err) {\n                        record(err, name, value, definition);\n                        return nextArray();\n                    }\n\n                    arrayResult.push(result);\n                    nextArray();\n                });\n            });\n        },\n        (ignoreErr) => {                // Error not possible\n\n            parsed[name] = arrayResult;\n            return nextName();\n        });\n    },\n    (ignoreErr) => {                    // Error not possible\n\n        return next(errored.length ? Boom.badRequest('Invalid cookie value', errored) : null, parsed, failed);\n    });\n};\n\n\ninternals.macPrefix = 'hapi.signed.cookie.1';\n\n\ninternals.unsign = function (name, value, definition, next) {\n\n    if (!definition.sign) {\n        return next(null, value);\n    }\n\n    const pos = value.lastIndexOf('.');\n    if (pos === -1) {\n        return next(Boom.badRequest('Missing signature separator'));\n    }\n\n    const unsigned = value.slice(0, pos);\n    const sig = value.slice(pos + 1);\n\n    if (!sig) {\n        return next(Boom.badRequest('Missing signature'));\n    }\n\n    const sigParts = sig.split('*');\n    if (sigParts.length !== 2) {\n        return next(Boom.badRequest('Invalid signature format'));\n    }\n\n    const hmacSalt = sigParts[0];\n    const hmac = sigParts[1];\n\n    const macOptions = Hoek.clone(definition.sign.integrity || Iron.defaults.integrity);\n    macOptions.salt = hmacSalt;\n    Iron.hmacWithPassword(definition.sign.password, macOptions, [internals.macPrefix, name, unsigned].join('\\n'), (err, mac) => {\n\n        if (err) {\n            return next(err);\n        }\n\n        if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {\n            return next(Boom.badRequest('Invalid hmac value'));\n        }\n\n        return next(null, unsigned);\n    });\n};\n\n\ninternals.decode = function (value, definition, next) {\n\n    if (!value &&\n        definition.encoding === 'form') {\n\n        return next(null, {});\n    }\n\n    Hoek.assert(typeof value === 'string', 'Invalid string');\n\n    // Encodings: 'base64json', 'base64', 'form', 'iron', 'none'\n\n    if (definition.encoding === 'iron') {\n        Iron.unseal(value, definition.password, definition.iron || Iron.defaults, (err, unsealed) => {\n\n            if (err) {\n                return next(err);\n            }\n\n            return next(null, unsealed);\n        });\n\n        return;\n    }\n\n    let result = value;\n\n    try {\n        if (definition.encoding === 'base64json') {\n            const decoded = (new Buffer(value, 'base64')).toString('binary');\n            result = JSON.parse(decoded);\n        }\n        else if (definition.encoding === 'base64') {\n            result = (new Buffer(value, 'base64')).toString('binary');\n        }\n        else {                                                                  // encoding: 'form'\n            result = Querystring.parse(value);\n        }\n    }\n    catch (err) {\n        return next(err);\n    }\n\n    return next(null, result);\n};\n\n\ninternals.Definitions.prototype.format = function (cookies, callback) {\n\n    if (!cookies ||\n        (Array.isArray(cookies) && !cookies.length)) {\n\n        return Hoek.nextTick(callback)(null, []);\n    }\n\n    if (!Array.isArray(cookies)) {\n        cookies = [cookies];\n    }\n\n    const header = [];\n    Items.serial(cookies, (cookie, next) => {\n\n        // Apply definition to local configuration\n\n        const base = this.cookies[cookie.name] || this.settings;\n        const definition = cookie.options ? Hoek.applyToDefaults(base, cookie.options, true) : base;\n\n        // Validate name\n\n        const nameRx = (definition.strictHeader ? internals.validateRx.nameRx.strict : internals.validateRx.nameRx.loose);\n        if (!nameRx.test(cookie.name)) {\n            return callback(Boom.badImplementation('Invalid cookie name: ' + cookie.name));\n        }\n\n        // Prepare value (encode, sign)\n\n        exports.prepareValue(cookie.name, cookie.value, definition, (err, value) => {\n\n            if (err) {\n                return callback(err);\n            }\n\n            // Validate prepared value\n\n            const valueRx = (definition.strictHeader ? internals.validateRx.valueRx.strict : internals.validateRx.valueRx.loose);\n            if (value &&\n                (typeof value !== 'string' || !value.match(valueRx))) {\n\n                return callback(Boom.badImplementation('Invalid cookie value: ' + cookie.value));\n            }\n\n            // Construct cookie\n\n            let segment = cookie.name + '=' + (value || '');\n\n            if (definition.ttl !== null &&\n                definition.ttl !== undefined) {            // Can be zero\n\n                const expires = new Date(definition.ttl ? Date.now() + definition.ttl : 0);\n                segment = segment + '; Max-Age=' + Math.floor(definition.ttl / 1000) + '; Expires=' + expires.toUTCString();\n            }\n\n            if (definition.isSecure) {\n                segment = segment + '; Secure';\n            }\n\n            if (definition.isHttpOnly) {\n                segment = segment + '; HttpOnly';\n            }\n\n            if (definition.isSameSite) {\n                segment = segment + `; SameSite=${definition.isSameSite}`;\n            }\n\n            if (definition.domain) {\n                const domain = definition.domain.toLowerCase();\n                if (!domain.match(internals.validateRx.domainLabelLenRx)) {\n                    return callback(Boom.badImplementation('Cookie domain too long: ' + definition.domain));\n                }\n\n                if (!domain.match(internals.validateRx.domainRx)) {\n                    return callback(Boom.badImplementation('Invalid cookie domain: ' + definition.domain));\n                }\n\n                segment = segment + '; Domain=' + domain;\n            }\n\n            if (definition.path) {\n                if (!definition.path.match(internals.validateRx.pathRx)) {\n                    return callback(Boom.badImplementation('Invalid cookie path: ' + definition.path));\n                }\n\n                segment = segment + '; Path=' + definition.path;\n            }\n\n            header.push(segment);\n            return next();\n        });\n    },\n    (ignoreErr) => {                // Error not possible\n\n        return callback(null, header);\n    });\n};\n\n\nexports.prepareValue = function (name, value, options, callback) {\n\n    Hoek.assert(options && typeof options === 'object', 'Missing or invalid options');\n\n    // Encode value\n\n    internals.encode(value, options, (err, encoded) => {\n\n        if (err) {\n            return callback(Boom.badImplementation('Failed to encode cookie (' + name + ') value: ' + err.message));\n        }\n\n        // Sign cookie\n\n        internals.sign(name, encoded, options.sign, (err, signed) => {\n\n            if (err) {\n                return callback(Boom.badImplementation('Failed to sign cookie (' + name + ') value: ' + err.message));\n            }\n\n            return callback(null, signed);\n        });\n    });\n};\n\n\ninternals.encode = function (value, options, callback) {\n\n    callback = Hoek.nextTick(callback);\n\n    // Encodings: 'base64json', 'base64', 'form', 'iron', 'none'\n\n    if (value === undefined) {\n        return callback(null, value);\n    }\n\n    if (options.encoding === 'none') {\n        return callback(null, value);\n    }\n\n    if (options.encoding === 'iron') {\n        Iron.seal(value, options.password, options.iron || Iron.defaults, (err, sealed) => {\n\n            if (err) {\n                return callback(err);\n            }\n\n            return callback(null, sealed);\n        });\n\n        return;\n    }\n\n    let result = value;\n\n    try {\n        if (options.encoding === 'base64') {\n            result = (new Buffer(value, 'binary')).toString('base64');\n        }\n        else if (options.encoding === 'base64json') {\n            const stringified = JSON.stringify(value);\n            result = (new Buffer(stringified, 'binary')).toString('base64');\n        }\n        else {                                                                  // encoding: 'form'\n            result = Querystring.stringify(value);\n        }\n    }\n    catch (err) {\n        return callback(err);\n    }\n\n    return callback(null, result);\n};\n\n\ninternals.sign = function (name, value, options, callback) {\n\n    if (value === undefined ||\n        !options) {\n\n        return Hoek.nextTick(callback)(null, value);\n    }\n\n    Iron.hmacWithPassword(options.password, options.integrity || Iron.defaults.integrity, [internals.macPrefix, name, value].join('\\n'), (err, mac) => {\n\n        if (err) {\n            return callback(err);\n        }\n\n        const signed = value + '.' + mac.salt + '*' + mac.digest;\n        return callback(null, signed);\n    });\n};\n\n\ninternals.Definitions.prototype.passThrough = function (header, fallback) {\n\n    if (!this.names.length) {\n        return header;\n    }\n\n    const exclude = [];\n    for (let i = 0; i < this.names.length; ++i) {\n        const name = this.names[i];\n        const definition = this.cookies[name];\n        const passCookie = definition.passThrough !== undefined ? definition.passThrough : fallback;\n        if (!passCookie) {\n            exclude.push(name);\n        }\n    }\n\n    return exports.exclude(header, exclude);\n};\n\n\nexports.exclude = function (cookies, excludes) {\n\n    let result = '';\n    const verify = cookies.replace(internals.pairsRx, ($0, $1, $2) => {\n\n        if (excludes.indexOf($1) === -1) {\n            result = result + (result ? ';' : '') + $1 + '=' + $2;\n        }\n\n        return '';\n    });\n\n    return verify === '' ? result : Boom.badRequest('Invalid cookie header');\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/cryptiles/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Crypto = require('crypto');\nconst Boom = require('boom');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Generate a cryptographically strong pseudo-random data\n\nexports.randomString = function (size) {\n\n    const buffer = exports.randomBits((size + 1) * 6);\n    if (buffer instanceof Error) {\n        return buffer;\n    }\n\n    const string = buffer.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n    return string.slice(0, size);\n};\n\n\n// Return a random string of digits\n\nexports.randomDigits = function (size) {\n\n    const buffer = exports.randomBits(size * 8);\n    if (buffer instanceof Error) {\n        return buffer;\n    }\n\n    const digits = [];\n    for (let i = 0; i < buffer.length; ++i) {\n        digits.push(Math.floor(buffer[i] / 25.6));\n    }\n\n    return digits.join('');\n};\n\n\n// Generate a buffer of random bits\n\nexports.randomBits = function (bits) {\n\n    if (!bits ||\n        bits < 0) {\n\n        return Boom.internal('Invalid random bits count');\n    }\n\n    const bytes = Math.ceil(bits / 8);\n    try {\n        return Crypto.randomBytes(bytes);\n    }\n    catch (err) {\n        return Boom.internal('Failed generating random bits: ' + err.message);\n    }\n};\n\n\n// Compare two strings using fixed time algorithm (to prevent time-based analysis of MAC digest match)\n\nexports.fixedTimeComparison = function (a, b) {\n\n    if (typeof a !== 'string' ||\n        typeof b !== 'string') {\n\n        return false;\n    }\n\n    let mismatch = (a.length === b.length ? 0 : 1);\n    if (mismatch) {\n        b = a;\n    }\n\n    for (let i = 0; i < a.length; ++i) {\n        const ac = a.charCodeAt(i);\n        const bc = b.charCodeAt(i);\n        mismatch |= (ac ^ bc);\n    }\n\n    return (mismatch === 0);\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/iron/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Crypto = require('crypto');\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Cryptiles = require('cryptiles');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Common defaults\n\nexports.defaults = {\n    encryption: {\n        saltBits: 256,\n        algorithm: 'aes-256-cbc',\n        iterations: 1,\n        minPasswordlength: 32\n    },\n\n    integrity: {\n        saltBits: 256,\n        algorithm: 'sha256',\n        iterations: 1,\n        minPasswordlength: 32\n    },\n\n    ttl: 0,                                             // Milliseconds, 0 means forever\n    timestampSkewSec: 60,                               // Seconds of permitted clock skew for incoming expirations\n    localtimeOffsetMsec: 0                              // Local clock time offset express in a number of milliseconds (positive or negative)\n};\n\n\n// Algorithm configuration\n\nexports.algorithms = {\n    'aes-128-ctr': { keyBits: 128, ivBits: 128 },       // Requires node 0.10.x\n    'aes-256-cbc': { keyBits: 256, ivBits: 128 },\n    'sha256': { keyBits: 256 }\n};\n\n\n// MAC normalization format version\n\nexports.macFormatVersion = '2';                         // Prevent comparison of mac values generated with different normalized string formats\nexports.macPrefix = 'Fe26.' + exports.macFormatVersion;\n\n\n// Generate a unique encryption key\n\n/*\n    const options =  {\n        saltBits: 256,                                  // Ignored if salt is set\n        salt: '4d8nr9q384nr9q384nr93q8nruq9348run',\n        algorithm: 'aes-128-ctr',\n        iterations: 10000,\n        iv: 'sdfsdfsdfsdfscdrgercgesrcgsercg',          // Optional\n        minPasswordlength: 32\n    };\n*/\n\nexports.generateKey = function (password, options, callback) {\n\n    const callbackTick = Hoek.nextTick(callback);\n\n    if (!password) {\n        return callbackTick(Boom.internal('Empty password'));\n    }\n\n    if (!options ||\n        typeof options !== 'object') {\n\n        return callbackTick(Boom.internal('Bad options'));\n    }\n\n    const algorithm = exports.algorithms[options.algorithm];\n    if (!algorithm) {\n        return callbackTick(Boom.internal('Unknown algorithm: ' + options.algorithm));\n    }\n\n    const generate = () => {\n\n        if (Buffer.isBuffer(password)) {\n            if (password.length < algorithm.keyBits / 8) {\n                return callbackTick(Boom.internal('Key buffer (password) too small'));\n            }\n\n            const result = {\n                key: password,\n                salt: ''\n            };\n\n            return generateIv(result);\n        }\n\n        if (password.length < options.minPasswordlength) {\n            return callbackTick(Boom.internal('Password string too short (min ' + options.minPasswordlength + ' characters required)'));\n        }\n\n        if (options.salt) {\n            return generateKey(options.salt);\n        }\n\n        if (options.saltBits) {\n            return generateSalt();\n        }\n\n        return callbackTick(Boom.internal('Missing salt or saltBits options'));\n    };\n\n    const generateSalt = () => {\n\n        const randomSalt = Cryptiles.randomBits(options.saltBits);\n        if (randomSalt instanceof Error) {\n            return callbackTick(Boom.wrap(randomSalt));\n        }\n\n        const salt = randomSalt.toString('hex');\n        return generateKey(salt);\n    };\n\n    const generateKey = (salt) => {\n\n        Crypto.pbkdf2(password, salt, options.iterations, algorithm.keyBits / 8, 'sha1', (err, derivedKey) => {\n\n            if (err) {\n                return callback(Boom.wrap(err));\n            }\n\n            const result = {\n                key: derivedKey,\n                salt\n            };\n\n            return generateIv(result);\n        });\n    };\n\n    const generateIv = (result) => {\n\n        if (algorithm.ivBits &&\n            !options.iv) {\n\n            const randomIv = Cryptiles.randomBits(algorithm.ivBits);\n            if (randomIv instanceof Error) {\n                return callbackTick(Boom.wrap(randomIv));\n            }\n\n            result.iv = randomIv;\n            return callbackTick(null, result);\n        }\n\n        if (options.iv) {\n            result.iv = options.iv;\n        }\n\n        return callbackTick(null, result);\n    };\n\n    generate();\n};\n\n\n// Encrypt data\n// options: see exports.generateKey()\n\nexports.encrypt = function (password, options, data, callback) {\n\n    exports.generateKey(password, options, (err, key) => {\n\n        if (err) {\n            return callback(err);\n        }\n\n        const cipher = Crypto.createCipheriv(options.algorithm, key.key, key.iv);\n        const enc = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()]);\n\n        callback(null, enc, key);\n    });\n};\n\n\n// Decrypt data\n// options: see exports.generateKey()\n\nexports.decrypt = function (password, options, data, callback) {\n\n    exports.generateKey(password, options, (err, key) => {\n\n        if (err) {\n            return callback(err);\n        }\n\n        const decipher = Crypto.createDecipheriv(options.algorithm, key.key, key.iv);\n        let dec = decipher.update(data, null, 'utf8');\n        dec = dec + decipher.final('utf8');\n\n        callback(null, dec);\n    });\n};\n\n\n// HMAC using a password\n// options: see exports.generateKey()\n\nexports.hmacWithPassword = function (password, options, data, callback) {\n\n    exports.generateKey(password, options, (err, key) => {\n\n        if (err) {\n            return callback(err);\n        }\n\n        const hmac = Crypto.createHmac(options.algorithm, key.key).update(data);\n        const digest = hmac.digest('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n\n        const result = {\n            digest,\n            salt: key.salt\n        };\n\n        return callback(null, result);\n    });\n};\n\n\n// Normalizes a password parameter into a { id, encryption, integrity } object\n// password: string, buffer or object with { id, secret } or { id, encryption, integrity }\n\ninternals.normalizePassword = function (password) {\n\n    const obj = {};\n\n    if (password instanceof Object &&\n        !Buffer.isBuffer(password)) {\n\n        obj.id = password.id;\n        obj.encryption = password.secret || password.encryption;\n        obj.integrity = password.secret || password.integrity;\n    }\n    else {\n        obj.encryption = password;\n        obj.integrity = password;\n    }\n\n    return obj;\n};\n\n\n// Encrypt and HMAC an object\n// password: string, buffer or object with { id, secret } or { id, encryption, integrity }\n// options: see exports.defaults\n\nexports.seal = function (object, password, options, callback) {\n\n    const now = Date.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing\n\n    const callbackTick = Hoek.nextTick(callback);\n\n    // Serialize object\n\n    const objectString = internals.stringify(object);\n    if (objectString instanceof Error) {\n        return callbackTick(objectString);\n    }\n\n    // Obtain password\n\n    let passwordId = '';\n    password = internals.normalizePassword(password);\n    if (password.id) {\n        if (!/^\\w+$/.test(password.id)) {\n            return callbackTick(Boom.internal('Invalid password id'));\n        }\n\n        passwordId = password.id;\n    }\n\n    // Encrypt object string\n\n    exports.encrypt(password.encryption, options.encryption, objectString, (err, encrypted, key) => {\n\n        if (err) {\n            return callback(err);\n        }\n\n        // Base64url the encrypted value\n\n        const encryptedB64 = Hoek.base64urlEncode(encrypted);\n        const iv = Hoek.base64urlEncode(key.iv);\n        const expiration = (options.ttl ? now + options.ttl : '');\n        const macBaseString = exports.macPrefix + '*' + passwordId + '*' + key.salt + '*' + iv + '*' + encryptedB64 + '*' + expiration;\n\n        // Mac the combined values\n\n        exports.hmacWithPassword(password.integrity, options.integrity, macBaseString, (err, mac) => {\n\n            if (err) {\n                return callback(err);\n            }\n\n            // Put it all together\n\n            // prefix*[password-id]*encryption-salt*encryption-iv*encrypted*[expiration]*hmac-salt*hmac\n            // Allowed URI query name/value characters: *-. \\d \\w\n\n            const sealed = macBaseString + '*' + mac.salt + '*' + mac.digest;\n            return callback(null, sealed);\n        });\n    });\n};\n\n\n// Decrypt and validate sealed string\n// password: string, buffer or object with { id: secret } or { id: { encryption, integrity } }\n// options: see exports.defaults\n\nexports.unseal = function (sealed, password, options, callback) {\n\n    const now = Date.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing\n\n    const callbackTick = Hoek.nextTick(callback);\n\n    // Break string into components\n\n    const parts = sealed.split('*');\n    if (parts.length !== 8) {\n        return callbackTick(Boom.internal('Incorrect number of sealed components'));\n    }\n\n    const macPrefix = parts[0];\n    const passwordId = parts[1];\n    const encryptionSalt = parts[2];\n    const encryptionIv = parts[3];\n    const encryptedB64 = parts[4];\n    const expiration = parts[5];\n    const hmacSalt = parts[6];\n    const hmac = parts[7];\n    const macBaseString = macPrefix + '*' + passwordId + '*' + encryptionSalt + '*' + encryptionIv + '*' + encryptedB64 + '*' + expiration;\n\n    // Check prefix\n\n    if (macPrefix !== exports.macPrefix) {\n        return callbackTick(Boom.internal('Wrong mac prefix'));\n    }\n\n    // Check expiration\n\n    if (expiration) {\n        if (!expiration.match(/^\\d+$/)) {\n            return callbackTick(Boom.internal('Invalid expiration'));\n        }\n\n        const exp = parseInt(expiration, 10);\n        if (exp <= (now - (options.timestampSkewSec * 1000))) {\n            return callbackTick(Boom.internal('Expired seal'));\n        }\n    }\n\n    // Obtain password\n\n    if (password instanceof Object &&\n        !(Buffer.isBuffer(password))) {\n\n        password = password[passwordId || 'default'];\n        if (!password) {\n            return callbackTick(Boom.internal('Cannot find password: ' + passwordId));\n        }\n    }\n    password = internals.normalizePassword(password);\n\n    // Check hmac\n\n    const macOptions = Hoek.clone(options.integrity);\n    macOptions.salt = hmacSalt;\n    exports.hmacWithPassword(password.integrity, macOptions, macBaseString, (err, mac) => {\n\n        if (err) {\n            return callback(err);\n        }\n\n        if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {\n            return callback(Boom.internal('Bad hmac value'));\n        }\n\n        // Decrypt\n\n        const encrypted = Hoek.base64urlDecode(encryptedB64, 'buffer');\n        if (encrypted instanceof Error) {\n            return callback(Boom.wrap(encrypted));\n        }\n\n        const decryptOptions = Hoek.clone(options.encryption);\n        decryptOptions.salt = encryptionSalt;\n\n        decryptOptions.iv = Hoek.base64urlDecode(encryptionIv, 'buffer');\n        if (decryptOptions.iv instanceof Error) {\n            return callback(Boom.wrap(decryptOptions.iv));\n        }\n\n        exports.decrypt(password.encryption, decryptOptions, encrypted, (ignoreErr, decrypted) => {         // Cannot fail since all errors covered by hmacWithPassword()\n\n            // Parse JSON\n\n            let object = null;\n            try {\n                object = JSON.parse(decrypted);\n            }\n            catch (err) {\n                return callback(Boom.internal('Failed parsing sealed object JSON: ' + err.message));\n            }\n\n            return callback(null, object);\n        });\n    });\n};\n\n\ninternals.stringify = function (object) {\n\n    try {\n        return JSON.stringify(object);\n    }\n    catch (err) {\n        return Boom.internal('Failed to stringify object: ' + err.message);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/joi/lib/schemas.js":"'use strict';\n\n// Load modules\n\nconst Joi = require('../');\n\n\n// Declare internals\n\nconst internals = {};\n\nexports.options = Joi.object({\n    abortEarly: Joi.boolean(),\n    convert: Joi.boolean(),\n    allowUnknown: Joi.boolean(),\n    skipFunctions: Joi.boolean(),\n    stripUnknown: [Joi.boolean(), Joi.object({ arrays: Joi.boolean(), objects: Joi.boolean() }).or('arrays', 'objects')],\n    language: Joi.object(),\n    presence: Joi.string().only('required', 'optional', 'forbidden', 'ignore'),\n    raw: Joi.boolean(),\n    context: Joi.object(),\n    strip: Joi.boolean(),\n    noDefaults: Joi.boolean()\n}).strict();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/auth.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Schema = require('./schema');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Auth = function (connection) {\n\n    this.connection = connection;\n    this._schemes = {};\n    this._strategies = {};\n    this.settings = {\n        default: null           // Strategy used as default if route has no auth settings\n    };\n\n    this.api = {};\n};\n\n\ninternals.Auth.prototype.scheme = function (name, scheme) {\n\n    Hoek.assert(name, 'Authentication scheme must have a name');\n    Hoek.assert(!this._schemes[name], 'Authentication scheme name already exists:', name);\n    Hoek.assert(typeof scheme === 'function', 'scheme must be a function:', name);\n\n    this._schemes[name] = scheme;\n};\n\n\ninternals.Auth.prototype.strategy = function (name, scheme /*, mode, options */) {\n\n    const hasMode = (typeof arguments[2] === 'string' || typeof arguments[2] === 'boolean');\n    const mode = (hasMode ? arguments[2] : false);\n    const options = (hasMode ? arguments[3] : arguments[2]) || null;\n\n    Hoek.assert(name, 'Authentication strategy must have a name');\n    Hoek.assert(name !== 'bypass', 'Cannot use reserved strategy name: bypass');\n    Hoek.assert(!this._strategies[name], 'Authentication strategy name already exists');\n    Hoek.assert(scheme, 'Authentication strategy', name, 'missing scheme');\n    Hoek.assert(this._schemes[scheme], 'Authentication strategy', name, 'uses unknown scheme:', scheme);\n\n    const server = this.connection.server._clone([this.connection], '');\n    const strategy = this._schemes[scheme](server, options);\n\n    Hoek.assert(strategy.authenticate, 'Invalid scheme:', name, 'missing authenticate() method');\n    Hoek.assert(typeof strategy.authenticate === 'function', 'Invalid scheme:', name, 'invalid authenticate() method');\n    Hoek.assert(!strategy.payload || typeof strategy.payload === 'function', 'Invalid scheme:', name, 'invalid payload() method');\n    Hoek.assert(!strategy.response || typeof strategy.response === 'function', 'Invalid scheme:', name, 'invalid response() method');\n    strategy.options = strategy.options || {};\n    Hoek.assert(strategy.payload || !strategy.options.payload, 'Cannot require payload validation without a payload method');\n\n    this._strategies[name] = {\n        methods: strategy,\n        realm: server.realm\n    };\n\n    if (strategy.api) {\n        this.api[name] = strategy.api;\n    }\n\n    if (mode) {\n        this.default({ strategies: [name], mode: mode === true ? 'required' : mode });\n    }\n};\n\n\ninternals.Auth.prototype.default = function (options) {\n\n    Hoek.assert(!this.settings.default, 'Cannot set default strategy more than once');\n    options = Schema.apply('auth', options, 'default strategy');\n\n    this.settings.default = this._setupRoute(Hoek.clone(options));      // Can change options\n};\n\n\ninternals.Auth.prototype.test = function (name, request, next) {\n\n    Hoek.assert(name, 'Missing authentication strategy name');\n    const strategy = this._strategies[name];\n    Hoek.assert(strategy, 'Unknown authentication strategy:', name);\n\n    const reply = request.server._replier.interface(request, strategy.realm, { data: true }, (response) => next(response, reply._data && reply._data.credentials));\n    strategy.methods.authenticate(request, reply);\n};\n\n\ninternals.Auth.prototype._setupRoute = function (options, path) {\n\n    if (!options) {\n        return options;         // Preserve the difference between undefined and false\n    }\n\n    if (typeof options === 'string') {\n        options = { strategies: [options] };\n    }\n    else if (options.strategy) {\n        options.strategies = [options.strategy];\n        delete options.strategy;\n    }\n\n    if (path &&\n        !options.strategies) {\n\n        Hoek.assert(this.settings.default, 'Route missing authentication strategy and no default defined:', path);\n        options = Hoek.applyToDefaults(this.settings.default, options);\n    }\n\n    path = path || 'default strategy';\n    Hoek.assert(options.strategies && options.strategies.length, 'Missing authentication strategy:', path);\n\n    options.mode = options.mode || 'required';\n\n    if (options.entity !== undefined ||                                             // Backwards compatibility with <= 11.x.x\n        options.scope !== undefined) {\n\n        options.access = [{ entity: options.entity, scope: options.scope }];\n        delete options.entity;\n        delete options.scope;\n    }\n\n    if (options.access) {\n        for (let i = 0; i < options.access.length; ++i) {\n            const access = options.access[i];\n            access.scope = internals.setupScope(access);\n        }\n    }\n\n    if (options.payload === true) {\n        options.payload = 'required';\n    }\n\n    let hasAuthenticatePayload = false;\n    for (let i = 0; i < options.strategies.length; ++i) {\n        const name = options.strategies[i];\n        const strategy = this._strategies[name];\n        Hoek.assert(strategy, 'Unknown authentication strategy', name, 'in', path);\n\n        Hoek.assert(strategy.methods.payload || options.payload !== 'required', 'Payload validation can only be required when all strategies support it in', path);\n        hasAuthenticatePayload = hasAuthenticatePayload || strategy.methods.payload;\n        Hoek.assert(!strategy.methods.options.payload || options.payload === undefined || options.payload === 'required', 'Cannot set authentication payload to', options.payload, 'when a strategy requires payload validation in', path);\n    }\n\n    Hoek.assert(!options.payload || hasAuthenticatePayload, 'Payload authentication requires at least one strategy with payload support in', path);\n\n    return options;\n};\n\n\ninternals.setupScope = function (access) {\n\n    if (!access.scope) {\n        return false;\n    }\n\n    const scope = {};\n    for (let i = 0; i < access.scope.length; ++i) {\n        const value = access.scope[i];\n        const prefix = value[0];\n        const type = (prefix === '+' ? 'required' : (prefix === '!' ? 'forbidden' : 'selection'));\n        const clean = (type === 'selection' ? value : value.slice(1));\n        scope[type] = scope[type] || [];\n        scope[type].push(clean);\n\n        if ((!scope._parameters || !scope._parameters[type]) &&\n            /{([^}]+)}/.test(clean)) {\n\n            scope._parameters = scope._parameters || {};\n            scope._parameters[type] = true;\n        }\n    }\n\n    return scope;\n};\n\n\ninternals.Auth.prototype.lookup = function (route) {\n\n    if (route.settings.auth === false) {\n        return false;\n    }\n\n    return route.settings.auth || this.settings.default;\n};\n\n\ninternals.Auth.authenticate = function (request, next) {\n\n    const auth = request.connection.auth;\n    return auth._authenticate(request, next);\n};\n\n\ninternals.Auth.access = function (request, route) {\n\n    const auth = request.connection.auth;\n    const config = auth.lookup(route);\n    if (!config) {\n        return true;\n    }\n\n    const credentials = request.auth.credentials;\n    if (!credentials) {\n        return false;\n    }\n\n    return !internals.access(request, config, credentials, 'bypass');\n};\n\n\ninternals.Auth.prototype._authenticate = function (request, next) {\n\n    const config = this.lookup(request.route);\n    if (!config) {\n        return next();\n    }\n\n    const authenticator = new internals.Authenticator(config, request, this);\n    authenticator.authenticate(next);\n};\n\n\ninternals.Auth.payload = function (request, next) {\n\n    if (!request.auth.isAuthenticated ||\n        request.auth.strategy === 'bypass') {\n\n        return next();\n    }\n\n    const auth = request.connection.auth;\n    const strategy = auth._strategies[request.auth.strategy];\n\n    if (!strategy.methods.payload) {\n        return next();\n    }\n\n    const config = auth.lookup(request.route);\n    const setting = config.payload || (strategy.methods.options.payload ? 'required' : false);\n    if (!setting) {\n        return next();\n    }\n\n    const finalize = (response) => {\n\n        if (response &&\n            response.isBoom &&\n            response.isMissing) {\n\n            return next(setting === 'optional' ? null : Boom.unauthorized('Missing payload authentication'));\n        }\n\n        return next(response);\n    };\n\n    request._protect.run(finalize, (exit) => {\n\n        const reply = request.server._replier.interface(request, strategy.realm, {}, exit);\n        strategy.methods.payload(request, reply);\n    });\n};\n\n\ninternals.Auth.response = function (request, next) {\n\n    const auth = request.connection.auth;\n    const config = auth.lookup(request.route);\n    if (!config ||\n        !request.auth.isAuthenticated ||\n        request.auth.strategy === 'bypass') {\n\n        return next();\n    }\n\n    const strategy = auth._strategies[request.auth.strategy];\n    if (!strategy.methods.response) {\n        return next();\n    }\n\n    request._protect.run(next, (exit) => {\n\n        const reply = request.server._replier.interface(request, strategy.realm, {}, exit);\n        strategy.methods.response(request, reply);\n    });\n};\n\n\ninternals.Authenticator = class {\n    constructor(config, request, manager) {\n\n        this.config = config;\n        this.request = request;\n        this.manager = manager;\n\n        this.errors = [];\n        this.current = -1;\n    }\n\n    authenticate(next) {\n\n        this.request.auth.mode = this.config.mode;\n\n        // Injection bypass\n\n        if (this.request.auth.credentials) {\n            return this.validate(null, { credentials: this.request.auth.credentials, artifacts: this.request.auth.artifacts }, next);\n        }\n\n        // Authenticate\n\n        return this.execute(next);\n    }\n\n    execute(next) {\n\n        const config = this.config;\n        const request = this.request;\n\n        // Find next strategy\n\n        ++this.current;\n        if (this.current < config.strategies.length) {\n            const name = config.strategies[this.current];\n            const after = (err, data) => this.validate(err, data, next);\n            request._protect.run(after, (exit) => {\n\n                const strategy = this.manager._strategies[name];\n                const reply = request.server._replier.interface(request, strategy.realm, { data: true }, (err) => exit(err, reply._data));\n                strategy.methods.authenticate(request, reply);\n            });\n\n            return;\n        }\n\n        // No more strategies\n\n        const err = Boom.unauthorized('Missing authentication', this.errors);\n\n        if (config.mode === 'optional' ||\n            config.mode === 'try') {\n\n            request.auth.isAuthenticated = false;\n            request.auth.credentials = null;\n            request.auth.error = err;\n            request._log(['auth', 'unauthenticated']);\n            return next();\n        }\n\n        return next(err);\n    }\n\n    validate(err, result, next) {                 // err can be Boom, Error, or a valid response object\n\n        const config = this.config;\n        const request = this.request;\n        const name = config.strategies[this.current] || 'bypass';\n\n        result = result || {};\n\n        // Invalid\n\n        if (!err &&\n            !result.credentials) {\n\n            return next(Boom.badImplementation('Authentication response missing both error and credentials'));\n        }\n\n        // Unauthenticated\n\n        if (err) {\n            if (err instanceof Error === false) {\n                request._log(['auth', 'unauthenticated', 'response', name], err.statusCode);\n                return next(err);\n            }\n\n            if (err.isMissing) {\n\n                // Try next name\n\n                request._log(['auth', 'unauthenticated', 'missing', name], err);\n                this.errors.push(err.output.headers['WWW-Authenticate']);\n                return this.execute(next);\n            }\n\n            if (config.mode === 'try') {\n                request.auth.isAuthenticated = false;\n                request.auth.strategy = name;\n                request.auth.credentials = result.credentials;\n                request.auth.artifacts = result.artifacts;\n                request.auth.error = err;\n                request._log(['auth', 'unauthenticated', 'try', name], err);\n                return next();\n            }\n\n            request._log(['auth', 'unauthenticated', 'error', name], err);\n            return next(err);\n        }\n\n        // Authenticated\n\n        const credentials = result.credentials;\n        request.auth.strategy = name;\n        request.auth.credentials = credentials;\n        request.auth.artifacts = result.artifacts;\n\n        const authenticated = () => {\n\n            request._log(['auth', name]);\n            request.auth.isAuthenticated = true;\n            return next();\n        };\n\n        // Check access rules\n\n        const error = internals.access(request, config, credentials, name);\n        if (!error) {\n            return authenticated();\n        }\n\n        request._log(error.tags, error.data);\n        return next(error.err);\n    }\n};\n\n\ninternals.access = function (request, config, credentials, name) {\n\n    if (!config.access) {\n        return null;\n    }\n\n    const requestEntity = (credentials.user ? 'user' : 'app');\n\n    const scopeErrors = [];\n    for (let i = 0; i < config.access.length; ++i) {\n        const access = config.access[i];\n\n        // Check entity\n\n        const entity = access.entity;\n        if (entity &&\n            entity !== 'any' &&\n            entity !== requestEntity) {\n\n            continue;\n        }\n\n        // Check scope\n\n        let scope = access.scope;\n        if (scope) {\n            if (!credentials.scope) {\n                scopeErrors.push(scope);\n                continue;\n            }\n\n            scope = internals.expandScope(request, scope);\n            if (!internals.validateScope(credentials, scope, 'required') ||\n                !internals.validateScope(credentials, scope, 'selection') ||\n                !internals.validateScope(credentials, scope, 'forbidden')) {\n\n                scopeErrors.push(scope);\n                continue;\n            }\n        }\n\n        return null;\n    }\n\n    // Scope error\n\n    if (scopeErrors.length) {\n        const data = { got: credentials.scope, need: scopeErrors };\n        return { err: Boom.forbidden('Insufficient scope', data), tags: ['auth', 'scope', 'error', name], data };\n    }\n\n    // Entity error\n\n    if (requestEntity === 'app') {\n        return { err: Boom.forbidden('Application credentials cannot be used on a user endpoint'), tags: ['auth', 'entity', 'user', 'error', name] };\n    }\n\n    return { err: Boom.forbidden('User credentials cannot be used on an application endpoint'), tags: ['auth', 'entity', 'app', 'error', name] };\n};\n\n\ninternals.expandScope = function (request, scope) {\n\n    if (!scope._parameters) {\n        return scope;\n    }\n\n    const expanded = {\n        required: internals.expandScopeType(request, scope, 'required'),\n        selection: internals.expandScopeType(request, scope, 'selection'),\n        forbidden: internals.expandScopeType(request, scope, 'forbidden')\n    };\n\n    return expanded;\n};\n\n\ninternals.expandScopeType = function (request, scope, type) {\n\n    if (!scope[type] ||\n        !scope._parameters[type]) {\n\n        return scope[type];\n    }\n\n    const expanded = [];\n    const context = {\n        params: request.params,\n        query: request.query\n    };\n\n    for (let i = 0; i < scope[type].length; ++i) {\n        expanded.push(Hoek.reachTemplate(context, scope[type][i]));\n    }\n\n    return expanded;\n};\n\n\ninternals.validateScope = function (credentials, scope, type) {\n\n    if (!scope[type]) {\n        return true;\n    }\n\n    const count = (typeof credentials.scope === 'string' ? (scope[type].indexOf(credentials.scope) !== -1 ? 1 : 0)\n                                                         : Hoek.intersect(scope[type], credentials.scope).length);\n\n    if (type === 'forbidden') {\n        return count === 0;\n    }\n\n    if (type === 'required') {\n        return count === scope.required.length;\n    }\n\n    return !!count;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/schema.js":"'use strict';\n\n// Load modules\n\nconst Joi = require('joi');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.apply = function (type, options, message) {\n\n    const result = Joi.validate(options, internals[type]);\n    Hoek.assert(!result.error, 'Invalid', type, 'options', message ? '(' + message + ')' : '', result.error && result.error.annotate());\n    return result.value;\n};\n\n\ninternals.access = Joi.object({\n    entity: Joi.string().valid('user', 'app', 'any'),\n    scope: [false, Joi.array().items(Joi.string()).single().min(1)]\n});\n\n\ninternals.auth = Joi.alternatives([\n    Joi.string(),\n    internals.access.keys({\n        mode: Joi.string().valid('required', 'optional', 'try'),\n        strategy: Joi.string(),\n        strategies: Joi.array().items(Joi.string()).min(1),\n        access: Joi.array().items(internals.access.min(1)).single().min(1),\n        payload: [\n            Joi.string().valid('required', 'optional'),\n            Joi.boolean()\n        ]\n    })\n        .without('strategy', 'strategies')\n        .without('access', ['scope', 'entity'])\n]);\n\n\ninternals.event = Joi.object({\n    method: Joi.array().items(Joi.func()).single(),\n    options: Joi.object({\n        before: Joi.array().items(Joi.string()).single(),\n        after: Joi.array().items(Joi.string()).single(),\n        bind: Joi.any(),\n        sandbox: Joi.string().valid('connection', 'plugin')\n    })\n        .default({})\n});\n\n\ninternals.exts = Joi.array().items(internals.event.keys({ type: Joi.string().required() })).single();\n\n\ninternals.routeBase = Joi.object({\n    app: Joi.object().allow(null),\n    auth: internals.auth.allow(false),\n    bind: Joi.object().allow(null),\n    cache: Joi.object({\n        expiresIn: Joi.number(),\n        expiresAt: Joi.string(),\n        privacy: Joi.string().valid('default', 'public', 'private'),\n        statuses: Joi.array().items(Joi.number().integer().min(200)).min(1).single(),\n        otherwise: Joi.string().required()\n    })\n        .allow(false),\n    compression: Joi.object().pattern(/.+/, Joi.object()),\n    cors: Joi.object({\n        origin: Joi.array().min(1),\n        maxAge: Joi.number(),\n        headers: Joi.array().items(Joi.string()),\n        additionalHeaders: Joi.array().items(Joi.string()),\n        exposedHeaders: Joi.array().items(Joi.string()),\n        additionalExposedHeaders: Joi.array().items(Joi.string()),\n        credentials: Joi.boolean()\n    })\n        .allow(false, true),\n    ext: Joi.object({\n        onPreAuth: Joi.array().items(internals.event).single(),\n        onPostAuth: Joi.array().items(internals.event).single(),\n        onPreHandler: Joi.array().items(internals.event).single(),\n        onPostHandler: Joi.array().items(internals.event).single(),\n        onPreResponse: Joi.array().items(internals.event).single()\n    })\n        .default({}),\n    files: Joi.object({\n        relativeTo: Joi.string().regex(/^([\\/\\.])|([A-Za-z]:\\\\)|(\\\\\\\\)/).required()\n    }),\n    json: Joi.object({\n        replacer: Joi.alternatives(Joi.func(), Joi.array()).allow(null),\n        space: Joi.number().allow(null),\n        suffix: Joi.string().allow(null)\n    }),\n    jsonp: Joi.string(),\n    log: Joi.boolean(),\n    payload: Joi.object({\n        output: Joi.string().valid('data', 'stream', 'file'),\n        parse: Joi.boolean().allow('gunzip'),\n        multipart: Joi.object({\n            output: Joi.string().valid('data', 'stream', 'file', 'annotated').required()\n        })\n            .allow(false),\n        allow: [\n            Joi.string(),\n            Joi.array()\n        ],\n        override: Joi.string(),\n        maxBytes: Joi.number().integer().positive(),\n        uploads: Joi.string(),\n        failAction: Joi.string().valid('error', 'log', 'ignore'),\n        timeout: Joi.number().integer().positive().allow(false),\n        defaultContentType: Joi.string(),\n        compression: Joi.object().pattern(/.+/, Joi.object())\n    }),\n    plugins: Joi.object(),\n    response: Joi.object({\n        emptyStatusCode: Joi.number().valid(200, 204),\n        failAction: [\n            Joi.string().valid('error', 'log'),\n            Joi.func()\n        ],\n        modify: Joi.boolean(),\n        options: Joi.object(),\n        ranges: Joi.boolean(),\n        sample: Joi.number().min(0).max(100),\n        schema: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(true, false),\n        status: Joi.object().pattern(/\\d\\d\\d/, Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(true, false))\n    })\n        .without('modify', 'sample')\n        .assert('options.stripUnknown', Joi.ref('modify'), 'meet requirement of having peer modify set to true'),\n    security: Joi.object({\n        hsts: [\n            Joi.object({\n                maxAge: Joi.number(),\n                includeSubdomains: Joi.boolean(),\n                includeSubDomains: Joi.boolean(),\n                preload: Joi.boolean()\n            }),\n            Joi.boolean(),\n            Joi.number()\n        ],\n        xframe: [\n            Joi.boolean(),\n            Joi.string().valid('sameorigin', 'deny'),\n            Joi.object({\n                rule: Joi.string().valid('sameorigin', 'deny', 'allow-from'),\n                source: Joi.string()\n            })\n        ],\n        xss: Joi.boolean(),\n        noOpen: Joi.boolean(),\n        noSniff: Joi.boolean()\n    })\n        .allow(null, false, true),\n    state: Joi.object({\n        parse: Joi.boolean(),\n        failAction: Joi.string().valid('error', 'log', 'ignore')\n    }),\n    timeout: Joi.object({\n        socket: Joi.number().integer().positive().allow(false),\n        server: Joi.number().integer().positive().allow(false).required()\n    }),\n    validate: Joi.object({\n        headers: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, false, true),\n        params: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, false, true),\n        query: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, false, true),\n        payload: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, false, true),\n        failAction: [\n            Joi.string().valid('error', 'log', 'ignore'),\n            Joi.func()\n        ],\n        errorFields: Joi.object(),\n        options: Joi.object()\n    })\n});\n\n\ninternals.connectionBase = Joi.object({\n    app: Joi.object().allow(null),\n    compression: Joi.boolean(),\n    load: Joi.object(),\n    plugins: Joi.object(),\n    router: Joi.object({\n        isCaseSensitive: Joi.boolean(),\n        stripTrailingSlash: Joi.boolean()\n    }),\n    routes: internals.routeBase,\n    state: Joi.object()                                     // Cookie defaults\n});\n\n\ninternals.server = Joi.object({\n    app: Joi.object().allow(null),\n    cache: Joi.allow(null),                                 // Validated elsewhere\n    connections: internals.connectionBase,\n    debug: Joi.object({\n        request: Joi.array().items(Joi.string()).single().allow(false),\n        log: Joi.array().items(Joi.string()).single().allow(false)\n    }).allow(false),\n    load: Joi.object(),\n    mime: Joi.object(),\n    plugins: Joi.object(),\n    useDomains: Joi.boolean()\n});\n\n\ninternals.connection = internals.connectionBase.keys({\n    autoListen: Joi.boolean(),\n    host: Joi.string().hostname(),\n    address: Joi.string().hostname(),\n    labels: Joi.array().items(Joi.string()).single(),\n    listener: Joi.any(),\n    port: Joi.alternatives([\n        Joi.number().integer().min(0),          // TCP port\n        Joi.string().regex(/\\//),               // Unix domain socket\n        Joi.string().regex(/^\\\\\\\\\\.\\\\pipe\\\\/)   // Windows named pipe\n    ])\n        .allow(null),\n    tls: Joi.alternatives([\n        Joi.object().allow(null),\n        Joi.boolean()\n    ]),\n    uri: Joi.string().regex(/[^/]$/)\n});\n\n\ninternals.vhost = Joi.alternatives([\n    Joi.string().hostname(),\n    Joi.array().items(Joi.string().hostname()).min(1)\n]);\n\n\ninternals.route = Joi.object({\n    method: Joi.string().regex(/^[a-zA-Z0-9!#\\$%&'\\*\\+\\-\\.^_`\\|~]+$/).required(),\n    path: Joi.string().required(),\n    vhost: internals.vhost,\n    handler: Joi.any(),                         // Validated in routeConfig\n    config: Joi.alternatives([\n        Joi.object(),\n        Joi.func()\n    ]).allow(null)\n});\n\n\ninternals.pre = [\n    Joi.string(),\n    Joi.func(),\n    Joi.object({\n        method: Joi.alternatives(Joi.string(), Joi.func()).required(),\n        assign: Joi.string(),\n        mode: Joi.string().valid('serial', 'parallel'),\n        failAction: Joi.string().valid('error', 'log', 'ignore')\n    })\n];\n\n\ninternals.routeConfig = internals.routeBase.keys({\n    id: Joi.string(),\n    isInternal: Joi.boolean(),\n    pre: Joi.array().items(internals.pre.concat(Joi.array().items(internals.pre).min(1))),\n    handler: [\n        Joi.func(),\n        Joi.string(),\n        Joi.object().length(1)\n    ],\n    description: Joi.string(),\n    notes: [\n        Joi.string(),\n        Joi.array().items(Joi.string())\n    ],\n    tags: [\n        Joi.string(),\n        Joi.array().items(Joi.string())\n    ]\n});\n\n\ninternals.cacheConfig = Joi.object({\n    name: Joi.string().invalid('_default'),\n    partition: Joi.string(),\n    shared: Joi.boolean(),\n    engine: Joi.alternatives([\n        Joi.object(),\n        Joi.func()\n    ])\n        .required()\n}).unknown();\n\n\ninternals.cache = Joi.array().items(internals.cacheConfig, Joi.func()).min(1).single();\n\n\ninternals.cachePolicy = Joi.object({\n    cache: Joi.string().allow(null).allow(''),\n    segment: Joi.string(),\n    shared: Joi.boolean()\n})\n    .options({ allowUnknown: true });               // Catbox validates other keys\n\n\ninternals.method = Joi.object({\n    bind: Joi.object().allow(null),\n    generateKey: Joi.func(),\n    cache: internals.cachePolicy,\n    callback: Joi.boolean()\n});\n\n\ninternals.methodObject = Joi.object({\n    name: Joi.string().required(),\n    method: Joi.func().required(),\n    options: Joi.object()\n});\n\n\ninternals.register = Joi.object({\n    once: Joi.boolean(),\n    routes: Joi.object({\n        prefix: Joi.string().regex(/^\\/.+/),\n        vhost: internals.vhost\n    })\n        .default({}),\n    select: Joi.array().items(Joi.string()).single()\n});\n\n\ninternals.plugin = internals.register.keys({\n    register: Joi.func().keys({\n        attributes: Joi.object({\n            pkg: Joi.object({\n                name: Joi.string(),\n                version: Joi.string().default('0.0.0')\n            })\n                .unknown()\n                .default({\n                    version: '0.0.0'\n                }),\n            name: Joi.string()\n                .when('pkg.name', { is: Joi.exist(), otherwise: Joi.required() }),\n            version: Joi.string(),\n            multiple: Joi.boolean().default(false),\n            dependencies: Joi.array().items(Joi.string()).single(),\n            connections: Joi.boolean().allow('conditional').default(true),\n            once: Joi.boolean().valid(true)\n        })\n            .required()\n            .unknown()\n    })\n        .required(),\n    options: Joi.any()\n})\n    .without('once', 'options')\n    .unknown();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/compression.js":"'use strict';\n\n// Load modules\n\nconst Zlib = require('zlib');\nconst Accept = require('accept');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Compression = function () {\n\n    this.encodings = ['identity', 'gzip', 'deflate'];\n    this._encoders = {\n        identity: null,\n        gzip: (options) => Zlib.createGzip(options),\n        deflate: (options) => Zlib.createDeflate(options)\n    };\n\n    this._decoders = {\n        gzip: (options) => Zlib.createGunzip(options),\n        deflate: (options) => Zlib.createInflate(options)\n    };\n};\n\n\ninternals.Compression.prototype.addEncoder = function (encoding, encoder) {\n\n    Hoek.assert(this._encoders[encoding] === undefined, `Cannot override existing encoder for ${encoding}`);\n    Hoek.assert(typeof encoder === 'function', `Invalid encoder function for ${encoding}`);\n    this._encoders[encoding] = encoder;\n    this.encodings.push(encoding);\n};\n\n\ninternals.Compression.prototype.addDecoder = function (encoding, decoder) {\n\n    Hoek.assert(this._decoders[encoding] === undefined, `Cannot override existing decoder for ${encoding}`);\n    Hoek.assert(typeof decoder === 'function', `Invalid decoder function for ${encoding}`);\n    this._decoders[encoding] = decoder;\n};\n\n\ninternals.Compression.prototype.accept = function (request) {\n\n    const header = request.headers['accept-encoding'];\n    const accept = Accept.encoding(header, this.encodings);\n    if (accept instanceof Error) {\n        request.log(['accept-encoding', 'error'], { header, error: accept });\n        return 'identity';\n    }\n\n    return accept;\n};\n\n\ninternals.Compression.prototype.encoding = function (response) {\n\n    const request = response.request;\n    if (!request.connection.settings.compression) {\n        return null;\n    }\n\n    const mime = request.server.mime.type(response.headers['content-type'] || 'application/octet-stream');\n    if (!mime.compressible) {\n        return null;\n    }\n\n    response.vary('accept-encoding');\n\n    if (response.headers['content-encoding']) {\n        return null;\n    }\n\n    return (request.info.acceptEncoding === 'identity' ? null : request.info.acceptEncoding);\n};\n\n\ninternals.Compression.prototype.encoder = function (request, encoding) {\n\n    const encoder = this._encoders[encoding];\n    Hoek.assert(encoder !== undefined, `Unknown encoding ${encoding}`);\n    return encoder(request.route.settings.compression[encoding]);\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/accept/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Charset = require('./charset');\nconst Encoding = require('./encoding');\nconst Language = require('./language');\nconst MediaType = require('./mediatype');\n\nexports.charset = Charset.charset;\nexports.charsets = Charset.charsets;\n\nexports.encoding = Encoding.encoding;\nexports.encodings = Encoding.encodings;\n\nexports.language = Language.language;\nexports.languages = Language.languages;\n\nexports.mediaTypes = MediaType.mediaTypes;\n\nexports.parseAll = function (requestHeaders) {\n\n    return {\n        charsets: Charset.charsets(requestHeaders['accept-charset']),\n        encodings: Encoding.encodings(requestHeaders['accept-encoding']),\n        languages: Language.languages(requestHeaders['accept-language']),\n        mediaTypes: MediaType.mediaTypes(requestHeaders.accept)\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/accept/lib/charset.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// From https://tools.ietf.org/html/rfc7231#section-5.3.3\n// Accept-Charset: iso-8859-5, unicode-1-1;q=0.8\n\nexports.charset = function (header, preferences) {\n\n    Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');\n    const charsets = header\n        .split(',')\n        .map(internals.getParts)\n        .filter(internals.removeEmpty)\n        .sort(internals.compareByWeight);\n\n    // Tack on a default return\n\n    charsets.push({\n        weight: 0.001,\n        charset: ''\n    });\n\n    // No preferences.  Take the first non-disallowed charset\n\n    if (!preferences || preferences.length === 0) {\n        return charsets.filter(internals.removeDisallowed)[0].charset;\n    }\n\n    // Lower case all preferences\n\n    preferences = preferences.map(internals.lowerCase);\n\n    // Remove any disallowed preferences\n\n    internals.removeDisallowedPreferences(charsets, preferences);\n\n    // If charsets includes * (that isn't disallowed *;q=0) return first preference\n\n    const splatLocation = internals.findCharsetItem(charsets, '*');\n    if (splatLocation !== -1 && charsets[splatLocation].weight > 0) {\n        return preferences[0];\n    }\n\n    // Try to find the first match in the array of preferences, ignoring case\n\n    for (let i = 0; i < charsets.length; ++i) {\n        if (preferences.indexOf(charsets[i].charset.toLowerCase()) !== -1 && charsets[i].weight > 0) {\n            return charsets[i].charset;\n        }\n    }\n\n    return '';\n};\n\n\nexports.charsets = function (header) {\n\n    if (header === undefined || typeof header !== 'string') {\n        return [];\n    }\n\n    header = header.toLowerCase();\n\n    return header\n        .split(',')\n        .map(internals.getParts)\n        .filter(internals.removeEmptyAndDisallowed)\n        .sort(internals.compareByWeight)\n        .map(internals.partToCharset);\n};\n\n\ninternals.getParts = function (item) {\n\n    const result = {\n        weight: 1,\n        charset: ''\n    };\n\n    const match = item.match(internals.partsRegex);\n    if (!match) {\n        return result;\n    }\n\n    result.charset = match[1];\n    if (match[2] && internals.isNumber(match[2])) {\n        const weight = parseFloat(match[2]);\n        if (weight === 0 || (weight >= 0.001 && weight <= 1)) {\n            result.weight = weight;\n        }\n    }\n    return result;\n};\n\n//                         1: token               2: qvalue\ninternals.partsRegex = /\\s*([^;]+)(?:\\s*;\\s*[qQ]\\=([01](?:\\.\\d*)?))?\\s*/;\n\n\ninternals.removeEmpty = function (item) {\n\n    return item.charset !== '';\n};\n\n\ninternals.removeDisallowed = function (item) {\n\n    return item.weight !== 0;\n};\n\n\ninternals.removeEmptyAndDisallowed = function (item) {\n\n    return item.charset !== '' && item.weight !== 0;\n};\n\n\ninternals.removeDisallowedPreferences = function (charsets, preferences) {\n\n    for (let i = 0; i < charsets.length; ++i) {\n        let location;\n        if (charsets[i].weight === 0) {\n            location = preferences.indexOf(charsets[i].charset.toLowerCase());\n            if (location !== -1) {\n                preferences.splice(location, 1);\n            }\n        }\n    }\n};\n\n\ninternals.compareByWeight = function (a, b) {\n\n    return a.weight < b.weight;\n};\n\n\ninternals.partToCharset = function (item) {\n\n    return item.charset;\n};\n\n\ninternals.isNumber = function (n) {\n\n    return !isNaN(parseFloat(n));\n};\n\n\ninternals.lowerCase = function (str) {\n\n    return str.toLowerCase();\n};\n\n\ninternals.findCharsetItem = function (charsets, charset) {\n\n    for (let i = 0; i < charsets.length; ++i) {\n        if (charsets[i].charset === charset) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/accept/lib/encoding.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n/*\n    RFC 7231 Section 5.3.4 (https://tools.ietf.org/html/rfc7231#section-5.3.4)\n\n    Accept-Encoding  = #( codings [ weight ] )\n    codings          = content-coding / \"identity\" / \"*\"\n\n    Accept-Encoding: compress, gzip\n    Accept-Encoding:\n    Accept-Encoding: *\n    Accept-Encoding: compress;q=0.5, gzip;q=1.0\n    Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0\n*/\n\nexports.encoding = function (header, preferences) {\n\n    const encodings = exports.encodings(header, preferences);\n    if (encodings.isBoom) {\n        return encodings;\n    }\n\n    return encodings.length ? encodings[0] : '';\n};\n\n\nexports.encodings = function (header, preferences) {\n\n    Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');\n\n    const scores = internals.parse(header, 'encoding');\n    if (scores.isBoom) {\n        return scores;\n    }\n\n    if (!preferences) {\n        preferences = Object.keys(scores.accept);\n        preferences.push('*');\n    }\n\n    return internals.map(preferences, scores);\n};\n\n\n/*\n    RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)\n\n   The weight is normalized to a real number in the range 0 through 1,\n   where 0.001 is the least preferred and 1 is the most preferred; a\n   value of 0 means \"not acceptable\".  If no \"q\" parameter is present,\n   the default weight is 1.\n\n     weight = OWS \";\" OWS \"q=\" qvalue\n     qvalue = ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] )\n*/\n\n//                              1: token               2: qvalue\ninternals.preferenceRegex = /\\s*([^;\\,]+)(?:\\s*;\\s*[qQ]\\=([01](?:\\.\\d{0,3})?))?\\s*(?:\\,|$)/g;\n\n\ninternals.equivalents = {\n    encoding: {\n        'x-compress': 'compress',\n        'x-gzip': 'gzip'\n    }\n};\n\ninternals.parse = function (header, type) {\n\n    const scores = {\n        accept: {},\n        reject: {},\n        any: 0.0\n    };\n\n    if (header) {\n        const leftovers = header.replace(internals.preferenceRegex, ($0, $1, $2) => {\n\n            $1 = $1.toLowerCase();\n            const key = internals.equivalents[type][$1] || $1;\n            const score = $2 ? parseFloat($2) : 1.0;\n            if (key === '*') {\n                scores.any = score;\n            }\n            else if (score > 0) {\n                scores.accept[key] = score;\n            }\n            else {\n                scores.reject[key] = true;\n            }\n\n            return '';\n        });\n\n        if (leftovers) {\n            return Boom.badRequest('Invalid accept-' + type + ' header');\n        }\n    }\n\n    // Add identity at the lowest score if not explicitly set\n\n    if (!scores.reject.identity &&\n        !scores.accept.identity) {\n\n        scores.accept.identity = scores.any || 0.001;\n    }\n\n    return scores;\n};\n\n\ninternals.map = function (preferences, scores) {\n\n    const scored = [];\n    for (let i = 0; i < preferences.length; ++i) {\n        const key = preferences[i].toLowerCase();\n        if (!scores.reject[key]) {\n            const score = scores.accept[key] || scores.any;\n            if (score > 0) {\n                scored.push({ key, score });\n            }\n        }\n    }\n\n    scored.sort(internals.sort);\n\n    const result = [];\n    for (let i = 0; i < scored.length; ++i) {\n        result.push(scored[i].key);\n    }\n\n    return result;\n};\n\n\ninternals.sort = function (a, b) {\n\n    return (a.score === b.score ? 0 : (a.score < b.score ? 1 : -1));\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/accept/lib/language.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// https://tools.ietf.org/html/rfc7231#section-5.3.5\n// Accept-Language: da, en-gb;q=0.8, en;q=0.7\n\n\nexports.language = function (header, preferences) {\n\n    Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');\n    const languages = exports.languages(header);\n\n    if (languages.length === 0) {\n        languages.push('');\n    }\n\n    // No preferences.  Take the first charset.\n\n    if (!preferences || preferences.length === 0) {\n        return languages[0];\n    }\n\n    // If languages includes * return first preference\n\n    if (languages.indexOf('*') !== -1) {\n        return preferences[0];\n    }\n\n    // Try to find the first match in the array of preferences\n\n    preferences = preferences.map((str) => str.toLowerCase());\n\n    for (let i = 0; i < languages.length; ++i) {\n        if (preferences.indexOf(languages[i].toLowerCase()) !== -1) {\n            return languages[i];\n        }\n    }\n\n    return '';\n};\n\n\nexports.languages = function (header) {\n\n    if (header === undefined || typeof header !== 'string') {\n        return [];\n    }\n\n    return header\n        .split(',')\n        .map(internals.getParts)\n        .filter(internals.removeUnwanted)\n        .sort(internals.compareByWeight)\n        .map(internals.partToLanguage);\n};\n\n\ninternals.getParts = function (item) {\n\n    const result = {\n        weight: 1,\n        language: ''\n    };\n\n    const match = item.match(internals.partsRegex);\n\n    if (!match) {\n        return result;\n    }\n\n    result.language = match[1];\n    if (match[2] && internals.isNumber(match[2])) {\n        const weight = parseFloat(match[2]);\n        if (weight === 0 || (weight >= 0.001 && weight <= 1)) {\n            result.weight = weight;\n        }\n    }\n    return result;\n};\n\n\n//                         1: token               2: qvalue\ninternals.partsRegex = /\\s*([^;]+)(?:\\s*;\\s*[qQ]\\=([01](?:\\.\\d*)?))?\\s*/;\n\n\ninternals.removeUnwanted = function (item) {\n\n    return item.weight !== 0 && item.language !== '';\n};\n\n\ninternals.compareByWeight = function (a, b) {\n\n    return a.weight < b.weight;\n};\n\n\ninternals.partToLanguage = function (item) {\n\n    return item.language;\n};\n\n\ninternals.isNumber = function (n) {\n\n    return !isNaN(parseFloat(n));\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/accept/lib/mediatype.js":"'use strict';\n\n// Declare internals\n\nconst internals = {};\n\n// Accept: audio/*; q=0.2, audio/basic\n// text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c\n// text/plain, application/json;q=0.5, text/html, */*;q=0.1\n// text/plain, application/json;q=0.5, text/html, text/drop;q=0\n// text/*, text/plain, text/plain;format=flowed, */*\n// text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5\n\nexports.mediaTypes = function (header) {\n\n    if (header === undefined || typeof header !== 'string') {\n        return ['*/*'];\n    }\n\n    return header\n        .split(',')\n        .map(internals.getParts)\n        .filter(internals.removeEmptyAndDisallowed)\n        .sort(internals.compareByWeightAndSpecificity)\n        .map(internals.partToMediaType);\n};\n\n\ninternals.getParts = function (item) {\n\n    const result = {\n        weight: 1,\n        mediaType: ''\n    };\n\n    const match = item.match(internals.partsRegex);\n\n    if (!match) {\n        return result;\n    }\n\n    result.mediaType = match[1];\n    if (match[2] && internals.isNumber(match[2])) {\n        const weight = parseFloat(match[2]);\n        if (weight === 0 || (weight >= 0.001 && weight <= 1)) {\n            result.weight = weight;\n        }\n    }\n    return result;\n};\n\n//                         1: token              2: qvalue\ninternals.partsRegex = /\\s*(.+\\/.+?)(?:\\s*;\\s*[qQ]\\=([01](?:\\.\\d*)?))?\\s*$/;\n\ninternals.removeEmptyAndDisallowed = function (item) {\n\n    return item.mediaType !== '' && item.weight !== 0;\n};\n\ninternals.compareByWeightAndSpecificity = function (a, b) {\n\n    if (a.weight !== b.weight) {\n        return a.weight < b.weight;\n    }\n\n    // We have the same weight, so now look for specificity\n    const aSlashParts = a.mediaType.split('/');\n    const bSlashParts = b.mediaType.split('/');\n\n    if (aSlashParts[0] !== bSlashParts[0]) {\n        // First part of items are different so no\n        // further specificity is implied.\n        // Don't change order.\n        return 0;\n    }\n\n    if (aSlashParts[1] !== '*' && bSlashParts[1] === '*') {\n        return -1;\n    }\n    if (aSlashParts[1] === '*' && bSlashParts[1] !== '*') {\n        return 1;\n    }\n\n    // look for items with extensions\n    const aHasExtension = aSlashParts[1].indexOf(';') !== -1;\n    const bHasExtension = bSlashParts[1].indexOf(';') !== -1;\n    if (aHasExtension) {\n        return -1;\n    }\n    else if (bHasExtension) {\n        return 1;\n    }\n\n    return 0;\n};\n\ninternals.partToMediaType = function (item) {\n\n    return item.mediaType;\n};\n\ninternals.isNumber = function (n) {\n\n    return !isNaN(parseFloat(n));\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/cors.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Defaults = require('./defaults');\nlet Route = null;                           // Delayed load due to circular dependency\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.route = function (options) {\n\n    const settings = Hoek.applyToDefaults(Defaults.cors, options);\n    if (!settings) {\n        return false;\n    }\n\n    settings._headers = settings.headers.concat(settings.additionalHeaders);\n    settings._headersString = settings._headers.join(',');\n    for (let i = 0; i < settings._headers.length; ++i) {\n        settings._headers[i] = settings._headers[i].toLowerCase();\n    }\n\n    if (settings._headers.indexOf('origin') === -1) {\n        settings._headers.push('origin');\n    }\n\n    settings._exposedHeaders = settings.exposedHeaders.concat(settings.additionalExposedHeaders).join(',');\n\n    if (settings.origin.indexOf('*') !== -1) {\n        Hoek.assert(settings.origin.length === 1, 'Cannot specify cors.origin * together with other values');\n        settings._origin = true;\n    }\n    else {\n        settings._origin = {\n            qualified: [],\n            wildcards: []\n        };\n\n        for (let i = 0; i < settings.origin.length; ++i) {\n            const origin = settings.origin[i];\n            if (origin.indexOf('*') !== -1) {\n                settings._origin.wildcards.push(new RegExp('^' + Hoek.escapeRegex(origin).replace(/\\\\\\*/g, '.*').replace(/\\\\\\?/g, '.') + '$'));\n            }\n            else {\n                settings._origin.qualified.push(origin);\n            }\n        }\n    }\n\n    return settings;\n};\n\n\nexports.options = function (route, connection, server) {\n\n    if (route.method === 'options' ||\n        !route.settings.cors) {\n\n        return;\n    }\n\n    exports.handler(connection);\n};\n\n\nexports.handler = function (connection) {\n\n    Route = Route || require('./route');\n\n    if (connection._router.specials.options) {\n        return;\n    }\n\n    const route = new Route({ method: '_special', path: '/{p*}', handler: internals.handler }, connection, connection.server, { special: true });\n    connection._router.special('options', route);\n};\n\n\ninternals.handler = function (request, reply) {\n\n    // Validate CORS preflight request\n\n    const origin = request.headers.origin;\n    if (!origin) {\n        return reply(Boom.notFound('CORS error: Missing Origin header'));\n    }\n\n    const method = request.headers['access-control-request-method'];\n    if (!method) {\n        return reply(Boom.notFound('CORS error: Missing Access-Control-Request-Method header'));\n    }\n\n    // Lookup route\n\n    const route = request.connection.match(method, request.path, request.info.hostname);\n    if (!route) {\n        return reply(Boom.notFound());\n    }\n\n    const settings = route.settings.cors;\n    if (!settings) {\n        return reply({ message: 'CORS is disabled for this route' });\n    }\n\n    // Validate Origin header\n\n    if (!exports.matchOrigin(origin, settings)) {\n        return reply({ message: 'CORS error: Origin not allowed' });\n    }\n\n    // Validate allowed headers\n\n    let headers = request.headers['access-control-request-headers'];\n    if (headers) {\n        headers = headers.toLowerCase().split(/\\s*,\\s*/);\n        if (Hoek.intersect(headers, settings._headers).length !== headers.length) {\n            return reply({ message: 'CORS error: Some headers are not allowed' });\n        }\n    }\n\n    // Reply with the route CORS headers\n\n    const response = reply();\n    response._header('access-control-allow-origin', request.headers.origin);\n    response._header('access-control-allow-methods', method);\n    response._header('access-control-allow-headers', settings._headersString);\n    response._header('access-control-max-age', settings.maxAge);\n\n    if (settings.credentials) {\n        response._header('access-control-allow-credentials', 'true');\n    }\n\n    if (settings._exposedHeaders) {\n        response._header('access-control-expose-headers', settings._exposedHeaders);\n    }\n};\n\n\nexports.headers = function (response) {\n\n    const request = response.request;\n    if (request._route._special) {\n        return;\n    }\n\n    const settings = request.route.settings.cors;\n    if (!settings) {\n        return;\n    }\n\n    response.vary('origin');\n\n    if (!request.info.cors.isOriginMatch) {\n        return;\n    }\n\n    response._header('access-control-allow-origin', request.headers.origin);\n\n    if (settings.credentials) {\n        response._header('access-control-allow-credentials', 'true');\n    }\n\n    if (settings._exposedHeaders) {\n        response._header('access-control-expose-headers', settings._exposedHeaders, { append: true });\n    }\n};\n\n\nexports.matchOrigin = function (origin, settings) {\n\n    if (!origin) {\n        return false;\n    }\n\n    if (settings._origin === true) {\n        return true;\n    }\n\n    if (settings._origin.qualified.indexOf(origin) !== -1) {\n        return true;\n    }\n\n    for (let i = 0; i < settings._origin.wildcards.length; ++i) {\n        if (origin.match(settings._origin.wildcards[i])) {\n            return true;\n        }\n    }\n\n    return false;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/defaults.js":"'use strict';\n\n// Load modules\n\nconst Os = require('os');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.server = {\n    debug: {\n        request: ['implementation'],\n        log: ['implementation']\n    },\n    load: {\n        sampleInterval: 0\n    },\n    mime: null,                                     // Mimos options\n    useDomains: true\n};\n\n\nexports.connection = {\n    compression: true,                              // Enable response compression\n    router: {\n        isCaseSensitive: true,                      // Case-sensitive paths\n        stripTrailingSlash: false                   // Remove trailing slash from incoming paths\n    },\n    routes: {\n        cache: {\n            statuses: [200, 204],                   // Array of HTTP status codes for which cache-control header is set\n            otherwise: 'no-cache'\n        },\n        compression: {},\n        cors: false,                                // CORS headers\n        files: {\n            relativeTo: '.'                         // Determines what file and directory handlers use to base relative paths off\n        },\n        json: {\n            replacer: null,\n            space: null,\n            suffix: null\n        },\n        log: false,                                 // Enables request level log collection\n        payload: {\n            failAction: 'error',\n            maxBytes: 1024 * 1024,\n            output: 'data',\n            parse: true,\n            timeout: 10 * 1000,                     // Determines how long to wait for receiving client payload. Defaults to 10 seconds\n            uploads: Os.tmpdir(),\n            defaultContentType: 'application/json',\n            compression: {}\n        },\n        response: {\n            ranges: true,\n            emptyStatusCode: 200,                   // HTTP status code when payload is empty (200, 204)\n            options: {}                             // Joi validation options\n        },\n        security: false,                            // Security headers on responses: false -> null, true -> defaults, {} -> override defaults\n        state: {\n            parse: true,                            // Parse content of req.headers.cookie\n            failAction: 'error'                     // Action on bad cookie - 'error': return 400, 'log': log and continue, 'ignore': continue\n        },\n        timeout: {\n            socket: undefined,                      // Determines how long before closing request socket. Defaults to node (2 minutes)\n            server: false                           // Determines how long to wait for server request processing. Disabled by default\n        },\n        validate: {\n            options: {}                             // Joi validation options\n        }\n    }\n};\n\n\nexports.security = {\n    hsts: 15768000,\n    xframe: 'deny',\n    xss: true,\n    noOpen: true,\n    noSniff: true\n};\n\n\nexports.cors = {\n    origin: ['*'],\n    maxAge: 86400,                                  // One day\n    headers: [\n        'Accept',\n        'Authorization',\n        'Content-Type',\n        'If-None-Match'\n    ],\n    additionalHeaders: [],\n    exposedHeaders: [\n        'WWW-Authenticate',\n        'Server-Authorization'\n    ],\n    additionalExposedHeaders: [],\n    credentials: false\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/ext.js":"'use strict';\n\n// Load modules\n\nconst Topo = require('topo');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Ext = function (type, server) {\n\n    this._topo = new Topo();\n    this._server = server;\n    this._routes = [];\n\n    this.type = type;\n    this.nodes = null;\n};\n\n\ninternals.Ext.prototype.add = function (event) {\n\n    const methods = [].concat(event.method);\n    const options = event.options;\n\n    for (let i = 0; i < methods.length; ++i) {\n        const settings = {\n            before: options.before,\n            after: options.after,\n            group: event.plugin.realm.plugin,\n            sort: this._server._extensionsSeq++\n        };\n\n        const node = {\n            func: methods[i],                 // Connection: function (request, next), Server: function (server, next)\n            bind: options.bind,\n            plugin: event.plugin\n        };\n\n        this._topo.add(node, settings);\n    }\n\n    this.nodes = this._topo.nodes;\n\n    // Notify routes\n\n    for (let i = 0; i < this._routes.length; ++i) {\n        this._routes[i].rebuild(event);\n    }\n};\n\n\ninternals.Ext.prototype.merge = function (others) {\n\n    const merge = [];\n    for (let i = 0; i < others.length; ++i) {\n        merge.push(others[i]._topo);\n    }\n\n    this._topo.merge(merge);\n    this.nodes = (this._topo.nodes.length ? this._topo.nodes : null);\n};\n\n\ninternals.Ext.prototype.subscribe = function (route) {\n\n    this._routes.push(route);\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/route.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Catbox = require('catbox');\nconst Hoek = require('hoek');\nconst Subtext = require('subtext');\nconst Auth = require('./auth');\nconst Cors = require('./cors');\nconst Defaults = require('./defaults');\nconst Ext = require('./ext');\nconst Handler = require('./handler');\nconst Validation = require('./validation');\nconst Schema = require('./schema');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Route = function (route, connection, plugin, options) {\n\n    options = options || {};\n\n    // Apply plugin environment (before schema validation)\n\n    const realm = plugin.realm;\n    if (realm.modifiers.route.vhost ||\n        realm.modifiers.route.prefix) {\n\n        route = Hoek.cloneWithShallow(route, ['config']);       // config is left unchanged\n        route.path = (realm.modifiers.route.prefix ? realm.modifiers.route.prefix + (route.path !== '/' ? route.path : '') : route.path);\n        route.vhost = realm.modifiers.route.vhost || route.vhost;\n    }\n\n    // Setup and validate route configuration\n\n    Hoek.assert(route.path, 'Route missing path');\n    const routeDisplay = route.method + ' ' + route.path;\n\n    let config = route.config;\n    if (typeof config === 'function') {\n        config = config.call(realm.settings.bind, connection.server);\n    }\n\n    Hoek.assert(route.handler || (config && config.handler), 'Missing or undefined handler:', routeDisplay);\n    Hoek.assert(!!route.handler ^ !!(config && config.handler), 'Handler must only appear once:', routeDisplay);            // XOR\n    Hoek.assert(route.path === '/' || route.path[route.path.length - 1] !== '/' || !connection.settings.router.stripTrailingSlash, 'Path cannot end with a trailing slash when connection configured to strip:', routeDisplay);\n\n    route = Schema.apply('route', route, routeDisplay);\n\n    const handler = route.handler || config.handler;\n    const method = route.method.toLowerCase();\n    Hoek.assert(method !== 'head', 'Method name not allowed:', routeDisplay);\n\n    // Apply settings in order: {connection} <- {handler} <- {realm} <- {route}\n\n    const handlerDefaults = Handler.defaults(method, handler, connection.server);\n    let base = Hoek.applyToDefaultsWithShallow(connection.settings.routes, handlerDefaults, ['bind']);\n    base = Hoek.applyToDefaultsWithShallow(base, realm.settings, ['bind']);\n    this.settings = Hoek.applyToDefaultsWithShallow(base, config || {}, ['bind', 'validate.headers', 'validate.payload', 'validate.params', 'validate.query']);\n    this.settings.handler = handler;\n    this.settings = Schema.apply('routeConfig', this.settings, routeDisplay);\n\n    const socketTimeout = (this.settings.timeout.socket === undefined ? 2 * 60 * 1000 : this.settings.timeout.socket);\n    Hoek.assert(!this.settings.timeout.server || !socketTimeout || this.settings.timeout.server < socketTimeout, 'Server timeout must be shorter than socket timeout:', routeDisplay);\n    Hoek.assert(!this.settings.payload.timeout || !socketTimeout || this.settings.payload.timeout < socketTimeout, 'Payload timeout must be shorter than socket timeout:', routeDisplay);\n\n    this.connection = connection;\n    this.server = connection.server;\n    this.path = route.path;\n    this.method = method;\n    this.plugin = plugin;\n\n    this.settings.vhost = route.vhost;\n    this.settings.plugins = this.settings.plugins || {};            // Route-specific plugins settings, namespaced using plugin name\n    this.settings.app = this.settings.app || {};                    // Route-specific application settings\n\n    // Path parsing\n\n    this._special = !!options.special;\n    this._analysis = this.connection._router.analyze(this.path);\n    this.params = this._analysis.params;\n    this.fingerprint = this._analysis.fingerprint;\n\n    this.public = {\n        method: this.method,\n        path: this.path,\n        vhost: this.vhost,\n        realm: this.plugin.realm,\n        settings: this.settings,\n        fingerprint: this.fingerprint,\n        auth: {\n            access: (request) => Auth.access(request, this.public)\n        }\n    };\n\n    // Validation\n\n    const validation = this.settings.validate;\n    if (this.method === 'get') {\n\n        // Assert on config, not on merged settings\n\n        Hoek.assert(!config || !config.payload, 'Cannot set payload settings on HEAD or GET request:', routeDisplay);\n        Hoek.assert(!config || !config.validate || !config.validate.payload, 'Cannot validate HEAD or GET requests:', routeDisplay);\n\n        validation.payload = null;\n    }\n\n    ['headers', 'params', 'query', 'payload'].forEach((type) => {\n\n        validation[type] = Validation.compile(validation[type]);\n    });\n\n    if (this.settings.response.schema !== undefined ||\n        this.settings.response.status) {\n\n        this.settings.response._validate = true;\n\n        const rule = this.settings.response.schema;\n        this.settings.response.status = this.settings.response.status || {};\n        const statuses = Object.keys(this.settings.response.status);\n\n        if (rule === true &&\n            !statuses.length) {\n\n            this.settings.response._validate = false;\n        }\n        else {\n            this.settings.response.schema = Validation.compile(rule);\n            for (let i = 0; i < statuses.length; ++i) {\n                const code = statuses[i];\n                this.settings.response.status[code] = Validation.compile(this.settings.response.status[code]);\n            }\n        }\n    }\n\n    // Payload parsing\n\n    if (this.method === 'get') {\n        this.settings.payload = null;\n    }\n    else {\n        if (this.settings.payload.allow) {\n            this.settings.payload.allow = [].concat(this.settings.payload.allow);\n        }\n\n        this.settings.payload.decoders = this.connection._compression._decoders;        // Reference the shared object to keep up to date\n    }\n\n    Hoek.assert(!this.settings.validate.payload || this.settings.payload.parse, 'Route payload must be set to \\'parse\\' when payload validation enabled:', routeDisplay);\n    Hoek.assert(!this.settings.jsonp || typeof this.settings.jsonp === 'string', 'Bad route JSONP parameter name:', routeDisplay);\n\n    // Authentication configuration\n\n    this.settings.auth = (this._special ? false : this.connection.auth._setupRoute(this.settings.auth, route.path));\n\n    // Cache\n\n    if (this.method === 'get' &&\n        typeof this.settings.cache === 'object' &&\n        (this.settings.cache.expiresIn || this.settings.cache.expiresAt)) {\n\n        this.settings.cache._statuses = Hoek.mapToObject(this.settings.cache.statuses);\n        this._cache = new Catbox.Policy({ expiresIn: this.settings.cache.expiresIn, expiresAt: this.settings.cache.expiresAt });\n    }\n\n    // CORS\n\n    this.settings.cors = Cors.route(this.settings.cors);\n\n    // Security\n\n    if (this.settings.security) {\n        this.settings.security = Hoek.applyToDefaults(Defaults.security, this.settings.security);\n\n        const security = this.settings.security;\n        if (security.hsts) {\n            if (security.hsts === true) {\n                security._hsts = 'max-age=15768000';\n            }\n            else if (typeof security.hsts === 'number') {\n                security._hsts = 'max-age=' + security.hsts;\n            }\n            else {\n                security._hsts = 'max-age=' + (security.hsts.maxAge || 15768000);\n                if (security.hsts.includeSubdomains || security.hsts.includeSubDomains) {\n                    security._hsts = security._hsts + '; includeSubDomains';\n                }\n                if (security.hsts.preload) {\n                    security._hsts = security._hsts + '; preload';\n                }\n            }\n        }\n\n        if (security.xframe) {\n            if (security.xframe === true) {\n                security._xframe = 'DENY';\n            }\n            else if (typeof security.xframe === 'string') {\n                security._xframe = security.xframe.toUpperCase();\n            }\n            else if (security.xframe.rule === 'allow-from') {\n                if (!security.xframe.source) {\n                    security._xframe = 'SAMEORIGIN';\n                }\n                else {\n                    security._xframe = 'ALLOW-FROM ' + security.xframe.source;\n                }\n            }\n            else {\n                security._xframe = security.xframe.rule.toUpperCase();\n            }\n        }\n    }\n\n    // Handler\n\n    this.settings.handler = Handler.configure(this.settings.handler, this);\n    this._prerequisites = Handler.prerequisitesConfig(this.settings.pre, this.server);\n\n    // Route lifecycle\n\n    this._extensions = {\n        onPreResponse: this._combineExtensions('onPreResponse')\n    };\n\n    if (this._special) {\n        this._cycle = [Handler.execute];\n        return;\n    }\n\n    this._extensions.onPreAuth = this._combineExtensions('onPreAuth');\n    this._extensions.onPostAuth = this._combineExtensions('onPostAuth');\n    this._extensions.onPreHandler = this._combineExtensions('onPreHandler');\n    this._extensions.onPostHandler = this._combineExtensions('onPostHandler');\n\n    this.rebuild();\n};\n\n\ninternals.Route.prototype._combineExtensions = function (type, subscribe) {\n\n    const ext = new Ext(type, this.server);\n\n    const events = this.settings.ext[type];\n    if (events) {\n        for (let i = 0; i < events.length; ++i) {\n            const event = Hoek.shallow(events[i]);\n            Hoek.assert(!event.options.sandbox, 'Cannot specify sandbox option for route extension');\n            event.plugin = this.plugin;\n            ext.add(event);\n        }\n    }\n\n    const connection = this.connection._extensions[type];\n    const realm = this.plugin.realm._extensions[type];\n\n    ext.merge([connection, realm]);\n\n    connection.subscribe(this);\n    realm.subscribe(this);\n\n    return ext;\n};\n\n\ninternals.Route.prototype.rebuild = function (event) {\n\n    if (event) {\n        this._extensions[event.type].add(event);\n        if (event.type === 'onPreResponse') {\n            return;\n        }\n    }\n\n    // Build lifecycle array\n\n    const cycle = [];\n\n    // 'onRequest'\n\n    if (this.settings.jsonp) {\n        cycle.push(internals.parseJSONP);\n    }\n\n    if (this.settings.state.parse) {\n        cycle.push(internals.state);\n    }\n\n    if (this._extensions.onPreAuth.nodes) {\n        cycle.push(this._extensions.onPreAuth);\n    }\n\n    const authenticate = (this.settings.auth !== false);                          // Anything other than 'false' can still require authentication\n    if (authenticate) {\n        cycle.push(Auth.authenticate);\n    }\n\n    if (this.method !== 'get') {\n        cycle.push(internals.payload);\n\n        if (authenticate) {\n            cycle.push(Auth.payload);\n        }\n    }\n\n    if (this._extensions.onPostAuth.nodes) {\n        cycle.push(this._extensions.onPostAuth);\n    }\n\n    if (this.settings.validate.headers) {\n        cycle.push(Validation.headers);\n    }\n\n    if (this.settings.validate.params) {\n        cycle.push(Validation.params);\n    }\n\n    if (this.settings.jsonp) {\n        cycle.push(internals.cleanupJSONP);\n    }\n\n    if (this.settings.validate.query) {\n        cycle.push(Validation.query);\n    }\n\n    if (this.settings.validate.payload) {\n        cycle.push(Validation.payload);\n    }\n\n    if (this._extensions.onPreHandler.nodes) {\n        cycle.push(this._extensions.onPreHandler);\n    }\n\n    cycle.push(Handler.execute);                                     // Must not call next() with an Error\n\n    if (this._extensions.onPostHandler.nodes) {\n        cycle.push(this._extensions.onPostHandler);                 // An error from here on will override any result set in handler()\n    }\n\n    if (this.settings.response._validate &&\n        this.settings.response.sample !== 0) {\n\n        cycle.push(Validation.response);\n    }\n\n    this._cycle = cycle;\n};\n\n\ninternals.state = function (request, next) {\n\n    request.state = {};\n\n    const req = request.raw.req;\n    const cookies = req.headers.cookie;\n    if (!cookies) {\n        return next();\n    }\n\n    request.connection.states.parse(cookies, (err, state, failed) => {\n\n        request.state = state || {};\n\n        // Clear cookies\n\n        for (let i = 0; i < failed.length; ++i) {\n            const item = failed[i];\n\n            if (item.settings.clearInvalid) {\n                request._clearState(item.name);\n            }\n        }\n\n        // failAction: 'error', 'log', 'ignore'\n\n        if (!err ||\n            request.route.settings.state.failAction === 'ignore') {\n\n            return next();\n        }\n\n        request._log(['state', 'error'], { header: cookies, errors: err.data });\n        return next(request.route.settings.state.failAction === 'error' ? err : null);\n    });\n};\n\n\ninternals.payload = function (request, next) {\n\n    if (request.method === 'get' ||\n        request.method === 'head') {            // When route.method is '*'\n\n        return next();\n    }\n\n    const onParsed = (err, parsed) => {\n\n        request.mime = parsed.mime;\n        request.payload = (parsed.payload === undefined ? null : parsed.payload);\n\n        if (!err) {\n            return next();\n        }\n\n        const failAction = request.route.settings.payload.failAction;         // failAction: 'error', 'log', 'ignore'\n        if (failAction !== 'ignore') {\n            request._log(['payload', 'error'], err);\n        }\n\n        if (failAction === 'error') {\n            return next(err);\n        }\n\n        return next();\n    };\n\n    Subtext.parse(request.raw.req, request._tap(), request.route.settings.payload, (err, parsed) => {\n\n        if (!err ||\n            !request._isPayloadPending) {\n\n            request._isPayloadPending = false;\n            return onParsed(err, parsed);\n        }\n\n        // Flush out any pending request payload not consumed due to errors\n\n        const stream = request.raw.req;\n\n        const read = () => {\n\n            stream.read();\n        };\n\n        const end = () => {\n\n            stream.removeListener('readable', read);\n            stream.removeListener('error', end);\n            stream.removeListener('end', end);\n\n            request._isPayloadPending = false;\n            return onParsed(err, parsed);\n        };\n\n        stream.on('readable', read);\n        stream.once('error', end);\n        stream.once('end', end);\n    });\n};\n\n\ninternals.jsonpRegex = /^[\\w\\$\\[\\]\\.]+$/;\n\n\ninternals.parseJSONP = function (request, next) {\n\n    const jsonp = request.query[request.route.settings.jsonp];\n    if (jsonp) {\n        if (internals.jsonpRegex.test(jsonp) === false) {\n            return next(Boom.badRequest('Invalid JSONP parameter value'));\n        }\n\n        request.jsonp = jsonp;\n    }\n\n    return next();\n};\n\n\ninternals.cleanupJSONP = function (request, next) {\n\n    if (request.jsonp) {\n        delete request.query[request.route.settings.jsonp];\n    }\n\n    return next();\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/subtext/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Fs = require('fs');\nconst Os = require('os');\nconst Querystring = require('querystring');\nconst Stream = require('stream');\nconst Zlib = require('zlib');\nconst Boom = require('boom');\nconst Content = require('content');\nconst Hoek = require('hoek');\nconst Pez = require('pez');\nconst Wreck = require('wreck');\n\n\n// Declare internals\n\nconst internals = {\n    decoders: {\n        gzip: (options) => Zlib.createGunzip(options),\n        deflate: (options) => Zlib.createInflate(options)\n    }\n};\n\n\nexports.parse = function (req, tap, options, next) {\n\n    Hoek.assert(options, 'Missing options');\n    Hoek.assert(options.parse !== undefined, 'Missing parse option setting');\n    Hoek.assert(options.output !== undefined, 'Missing output option setting');\n\n    const parser = new internals.Parser(req, tap, options, next);\n    return parser.read();\n};\n\n\ninternals.Parser = function (req, tap, options, next) {\n\n    this.req = req;\n    this.settings = options;\n    this.tap = tap;\n\n    this.result = {};\n    this.next = (err) => next(err, this.result);\n};\n\n\ninternals.Parser.prototype.read = function () {\n\n    const next = this.next;\n\n    // Content size\n\n    const req = this.req;\n    const contentLength = req.headers['content-length'];\n    if (this.settings.maxBytes !== undefined &&\n        contentLength &&\n        parseInt(contentLength, 10) > this.settings.maxBytes) {\n\n        return next(Boom.badRequest('Payload content length greater than maximum allowed: ' + this.settings.maxBytes));\n    }\n\n    // Content type\n\n    const contentType = Content.type(this.settings.override || req.headers['content-type'] || this.settings.defaultContentType || 'application/octet-stream');\n    if (contentType.isBoom) {\n        return next(contentType);\n    }\n\n    this.result.contentType = contentType;\n    this.result.mime = contentType.mime;\n\n    if (this.settings.allow &&\n        this.settings.allow.indexOf(contentType.mime) === -1) {\n\n        return next(Boom.unsupportedMediaType());\n    }\n\n    // Parse: true\n\n    if (this.settings.parse === true) {\n        return this.parse(contentType);\n    }\n\n    // Parse: false, 'gunzip'\n\n    return this.raw();\n};\n\n\ninternals.Parser.prototype.parse = function (contentType) {\n\n    let next = this.next;\n\n    const output = this.settings.output;        // Output: 'data', 'stream', 'file'\n    let source = this.req;\n\n    // Content-encoding\n\n    const contentEncoding = source.headers['content-encoding'];\n    const decoder = (this.settings.decoders || internals.decoders)[contentEncoding];\n    if (decoder) {\n        const decoderOptions = (this.settings.compression && this.settings.compression[contentEncoding]) || null;\n        const stream = decoder(decoderOptions);\n        next = Hoek.once(next);                 // Modify next() for async events\n        this.next = next;\n        stream.once('error', (err) => {\n\n            return next(Boom.badRequest('Invalid compressed payload', err));\n        });\n\n        source = source.pipe(stream);\n    }\n\n    // Tap request\n\n    if (this.tap) {\n        source = source.pipe(this.tap);\n    }\n\n    // Multipart\n\n    if (this.result.contentType.mime === 'multipart/form-data') {\n        if (this.settings.multipart === false) {                            // Defaults to true\n            return next(Boom.unsupportedMediaType());\n        }\n\n        return this.multipart(source, contentType);\n    }\n\n    // Output: 'stream'\n\n    if (output === 'stream') {\n        this.result.payload = source;\n        return next();\n    }\n\n    // Output: 'file'\n\n    if (output === 'file') {\n        this.writeFile(source, (err, path, bytes) => {\n\n            if (err) {\n                return next(err);\n            }\n\n            this.result.payload = { path, bytes };\n            return next();\n        });\n\n        return;\n    }\n\n    // Output: 'data'\n\n    return Wreck.read(source, { timeout: this.settings.timeout, maxBytes: this.settings.maxBytes }, (err, payload) => {\n\n        if (err) {\n            return next(err);\n        }\n\n        internals.object(payload, this.result.contentType.mime, (err, result) => {\n\n            if (err) {\n                this.result.payload = null;\n                return next(err);\n            }\n\n            this.result.payload = result;\n            return next();\n        });\n    });\n};\n\n\ninternals.Parser.prototype.raw = function () {\n\n    let next = this.next;\n\n    const output = this.settings.output;      // Output: 'data', 'stream', 'file'\n    let source = this.req;\n\n    // Content-encoding\n\n    if (this.settings.parse === 'gunzip') {\n        const contentEncoding = source.headers['content-encoding'];\n        const decoder = (this.settings.decoders || internals.decoders)[contentEncoding];\n        if (decoder) {\n            const decoderOptions = (this.settings.compression && this.settings.compression[contentEncoding]) || null;\n            const stream = decoder(decoderOptions);\n            next = Hoek.once(next);                                                                     // Modify next() for async events\n\n            stream.once('error', (err) => {\n\n                return next(Boom.badRequest('Invalid compressed payload', err));\n            });\n\n            source = source.pipe(stream);\n        }\n    }\n\n    // Setup source\n\n    if (this.tap) {\n        source = source.pipe(this.tap);\n    }\n\n    // Output: 'stream'\n\n    if (output === 'stream') {\n        this.result.payload = source;\n        return next();\n    }\n\n    // Output: 'file'\n\n    if (output === 'file') {\n        this.writeFile(source, (err, path, bytes) => {\n\n            if (err) {\n                return next(err);\n            }\n\n            this.result.payload = { path, bytes };\n            return next();\n        });\n\n        return;\n    }\n\n    // Output: 'data'\n\n    return Wreck.read(source, { timeout: this.settings.timeout, maxBytes: this.settings.maxBytes }, (err, payload) => {\n\n        if (err) {\n            return next(err);\n        }\n\n        this.result.payload = payload;\n        return next();\n    });\n};\n\n\ninternals.object = function (payload, mime, next) {\n\n    // Binary\n\n    if (mime === 'application/octet-stream') {\n        return next(null, payload.length ? payload : null);\n    }\n\n    // Text\n\n    if (mime.match(/^text\\/.+$/)) {\n        return next(null, payload.toString('utf8'));\n    }\n\n    // JSON\n\n    if (/^application\\/(?:.+\\+)?json$/.test(mime)) {\n        return internals.jsonParse(payload, next);                      // Isolate try...catch for V8 optimization\n    }\n\n    // Form-encoded\n\n    if (mime === 'application/x-www-form-urlencoded') {\n        return next(null, payload.length ? Querystring.parse(payload.toString('utf8')) : {});\n    }\n\n    return next(Boom.unsupportedMediaType());\n};\n\n\ninternals.jsonParse = function (payload, next) {\n\n    if (!payload.length) {\n        return next(null, null);\n    }\n\n    let parsed;\n    try {\n        parsed = JSON.parse(payload.toString('utf8'));\n    }\n    catch (err) {\n        return next(Boom.badRequest('Invalid request payload JSON format', err));\n    }\n\n    return next(null, parsed);\n};\n\n\ninternals.Parser.prototype.multipart = function (source, contentType) {\n\n    let next = this.next;\n    next = Hoek.once(next);                                            // Modify next() for async events\n    this.next = next;\n\n    // Set stream timeout\n\n    const clientTimeout = this.settings.timeout;\n    let clientTimeoutId = null;\n\n    const dispenserOptions = Hoek.applyToDefaults(contentType, { maxBytes: this.settings.maxBytes });\n    const dispenser = new Pez.Dispenser(dispenserOptions);\n\n    const onError = (err) => {\n\n        return next(Boom.badRequest('Invalid multipart payload format', err));\n    };\n\n    dispenser.once('error', onError);\n\n    const data = {};\n    const finalize = () => {\n\n        clearTimeout(clientTimeoutId);\n        dispenser.removeListener('error', onError);\n        dispenser.removeListener('part', onPart);\n        dispenser.removeListener('field', onField);\n        dispenser.removeListener('close', onClose);\n\n        this.result.payload = data;\n        return next();\n    };\n\n    if (clientTimeout &&\n        clientTimeout > 0) {\n\n        clientTimeoutId = setTimeout(() => {\n\n            return next(Boom.clientTimeout());\n        }, clientTimeout);\n    }\n\n    const set = (name, value) => {\n\n        if (!data.hasOwnProperty(name)) {\n            data[name] = value;\n        }\n        else if (Array.isArray(data[name])) {\n            data[name].push(value);\n        }\n        else {\n            data[name] = [data[name], value];\n        }\n    };\n\n    const pendingFiles = {};\n    let nextId = 0;\n    let closed = false;\n\n    const output = (this.settings.multipart ? this.settings.multipart.output : this.settings.output);\n\n    const onPart = (part) => {\n\n        if (output === 'file') {                                                                // Output: 'file'\n            const id = nextId++;\n            pendingFiles[id] = true;\n            this.writeFile(part, (err, path, bytes) => {\n\n                delete pendingFiles[id];\n\n                if (err) {\n                    return next(err);\n                }\n\n                const item = {\n                    filename: part.filename,\n                    path,\n                    headers: part.headers,\n                    bytes\n                };\n\n                set(part.name, item);\n\n                if (closed &&\n                    !Object.keys(pendingFiles).length) {\n\n                    return finalize(data);\n                }\n            });\n        }\n        else {                                                                                  // Output: 'data'\n            Wreck.read(part, {}, (ignoreErr, payload) => {\n\n                // Error handled by dispenser.once('error')\n\n                if (output === 'stream') {                                                      // Output: 'stream'\n                    const item = Wreck.toReadableStream(payload);\n\n                    item.hapi = {\n                        filename: part.filename,\n                        headers: part.headers\n                    };\n\n                    return set(part.name, item);\n                }\n\n                const ct = part.headers['content-type'] || '';\n                const mime = ct.split(';')[0].trim().toLowerCase();\n                const annotate = (value) => set(part.name, output === 'annotated' ? { filename: part.filename, headers: part.headers, payload: value } : value);\n\n                if (!mime) {\n                    return annotate(payload);\n                }\n\n                if (!payload.length) {\n                    return annotate({});\n                }\n\n                internals.object(payload, mime, (err, result) => annotate(err ? payload : result));\n            });\n        }\n    };\n\n    dispenser.on('part', onPart);\n\n    const onField = (name, value) => set(name, value);\n\n    dispenser.on('field', onField);\n\n    const onClose = () => {\n\n        if (Object.keys(pendingFiles).length) {\n            closed = true;\n            return;\n        }\n\n        return finalize(data);\n    };\n\n    dispenser.once('close', onClose);\n\n    source.pipe(dispenser);\n};\n\n\ninternals.Parser.prototype.writeFile = function (stream, callback) {\n\n    const path = Hoek.uniqueFilename(this.settings.uploads || Os.tmpDir());\n    const file = Fs.createWriteStream(path, { flags: 'wx' });\n    const counter = new internals.Counter();\n\n    const finalize = Hoek.once((err) => {\n\n        this.req.removeListener('aborted', onAbort);\n        file.removeListener('close', finalize);\n        file.removeListener('error', finalize);\n\n        if (!err) {\n            return callback(null, path, counter.bytes);\n        }\n\n        file.destroy();\n        Fs.unlink(path, (/* fsErr */) => {      // Ignore unlink errors\n\n            return callback(err);\n        });\n    });\n\n    file.once('close', finalize);\n    file.once('error', finalize);\n\n    const onAbort = () => {\n\n        return finalize(Boom.badRequest('Client connection aborted'));\n    };\n\n    this.req.once('aborted', onAbort);\n\n    stream.pipe(counter).pipe(file);\n};\n\n\ninternals.Counter = function () {\n\n    Stream.Transform.call(this);\n    this.bytes = 0;\n};\n\nHoek.inherits(internals.Counter, Stream.Transform);\n\n\ninternals.Counter.prototype._transform = function (chunk, encoding, next) {\n\n    this.bytes = this.bytes + chunk.length;\n    return next(null, chunk);\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/content/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n/*\n    RFC 7231 Section 3.1.1.1\n\n    media-type = type \"/\" subtype *( OWS \";\" OWS parameter )\n    type       = token\n    subtype    = token\n    parameter  = token \"=\" ( token / quoted-string )\n*/\n\n//                             1: type/subtype                    2: \"b\"   3: b\ninternals.contentTypeRegex = /^([^\\/]+\\/[^\\s;]+)(?:(?:\\s*;\\s*boundary=(?:\"([^\"]+)\"|([^;\"]+)))|(?:\\s*;\\s*[^=]+=(?:(?:\"(?:[^\"]+)\")|(?:[^;\"]+))))*$/i;\n\n\nexports.type = function (header) {\n\n    const match = header.match(internals.contentTypeRegex);\n    if (!match) {\n        return Boom.badRequest('Invalid content-type header');\n    }\n\n    const mime = match[1].toLowerCase();\n    const boundary = match[2] || match[3];\n    if (mime.indexOf('multipart/') === 0 &&\n        !boundary) {\n\n        return Boom.badRequest('Invalid content-type header: multipart missing boundary');\n    }\n\n    return { mime, boundary };\n};\n\n\n/*\n    RFC 6266 Section 4.1 (http://tools.ietf.org/html/rfc6266#section-4.1)\n\n    content-disposition = \"Content-Disposition\" \":\" disposition-type *( \";\" disposition-parm )\n    disposition-type    = \"inline\" | \"attachment\" | token                                           ; case-insensitive\n    disposition-parm    = filename-parm | token [ \"*\" ] \"=\" ( token | quoted-string | ext-value)    ; ext-value defined in [RFC5987], Section 3.2\n\n    Content-Disposition header field values with multiple instances of the same parameter name are invalid.\n\n    Note that due to the rules for implied linear whitespace (Section 2.1 of [RFC2616]), OPTIONAL whitespace\n    can appear between words (token or quoted-string) and separator characters.\n\n    Furthermore, note that the format used for ext-value allows specifying a natural language (e.g., \"en\"); this is of limited use\n    for filenames and is likely to be ignored by recipients.\n*/\n\n\ninternals.contentDispositionRegex = /^\\s*form-data\\s*(?:;\\s*(.+))?$/i;\n\n//                                        1: name   2: *            3: ext-value                  4: quoted  5: token\ninternals.contentDispositionParamRegex = /([^\\=\\*]+)(\\*)?\\s*\\=\\s*(?:([^;']+\\'[\\w-]*\\'[^;\\s]+)|(?:\\\"([^\"]*)\\\")|([^;\\s]*))(?:(?:\\s*;\\s*)|(?:\\s*$))/g;\n\nexports.disposition = function (header) {\n\n    if (!header) {\n        return Boom.badRequest('Missing content-disposition header');\n    }\n\n    const match = header.match(internals.contentDispositionRegex);\n    if (!match) {\n        return Boom.badRequest('Invalid content-disposition header format');\n    }\n\n    const parameters = match[1];\n    if (!parameters) {\n        return Boom.badRequest('Invalid content-disposition header missing parameters');\n    }\n\n    const result = {};\n    const leftovers = parameters.replace(internals.contentDispositionParamRegex, ($0, $1, $2, $3, $4, $5) => {\n\n        if ($2) {\n            if (!$3) {\n                return 'error';         // Generate leftovers\n            }\n\n            try {\n                result[$1] = decodeURIComponent($3.split('\\'')[2]);\n            }\n            catch (err) {\n                return 'error';          // Generate leftover\n            }\n        }\n        else {\n            result[$1] = $4 || $5 || '';\n        }\n\n        return '';\n    });\n\n    if (leftovers) {\n        return Boom.badRequest('Invalid content-disposition header format includes invalid parameters');\n    }\n\n    if (!result.name) {\n        return Boom.badRequest('Invalid content-disposition header missing name parameter');\n    }\n\n    return result;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/pez/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Stream = require('stream');\nconst B64 = require('b64');\nconst Boom = require('boom');\nconst Content = require('content');\nconst Hoek = require('hoek');\nconst Nigel = require('nigel');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n/*\n    RFC 2046 (http://tools.ietf.org/html/rfc2046)\n\n    multipart-body = [preamble CRLF]\n                    dash-boundary *( SPACE / HTAB ) CRLF body-part\n                    *( CRLF dash-boundary *( SPACE / HTAB ) CRLF body-part )\n                    CRLF dash-boundary \"--\" *( SPACE / HTAB )\n                    [CRLF epilogue]\n\n    boundary       = 0*69<bchars> bcharsnospace\n    bchars         = bcharsnospace / \" \"\n    bcharsnospace  = DIGIT / ALPHA / \"'\" / \"(\" / \")\" / \"+\" / \"_\" / \",\" / \"-\" / \".\" / \"/\" / \":\" / \"=\" / \"?\"\n    dash-boundary  = \"--\" boundary\n\n    preamble       = discard-text\n    epilogue       = discard-text\n    discard-text   = *(*text CRLF) *text\n\n    body-part      = MIME-part-headers [CRLF *OCTET]\n    OCTET          = <any 0-255 octet value>\n\n    SPACE          = 32\n    HTAB           = 9\n    CRLF           = 13 10\n*/\n\n\ninternals.state = {\n    preamble: 0,                // Until the first boundary is received\n    boundary: 1,                // After a boundary, waiting for first line with optional linear-whitespace\n    header: 2,                  // Receiving part headers\n    payload: 3,                 // Receiving part payload\n    epilogue: 4\n};\n\n\ninternals.defaults = {\n    maxBytes: Infinity\n};\n\n\nexports.Dispenser = internals.Dispenser = function (options) {\n\n    Stream.Writable.call(this);\n\n    Hoek.assert(options !== null && typeof options === 'object',\n                'options must be an object');\n    const settings = Hoek.applyToDefaults(internals.defaults, options);\n\n    this._boundary = settings.boundary;\n    this._state = internals.state.preamble;\n    this._held = '';\n\n    this._stream = null;\n    this._headers = {};\n    this._name = '';\n    this._pendingHeader = '';\n    this._error = null;\n    this._bytes = 0;\n    this._maxBytes = settings.maxBytes;\n\n    this._parts = new Nigel.Stream(new Buffer('--' + settings.boundary));\n    this._lines = new Nigel.Stream(new Buffer('\\r\\n'));\n\n    this._parts.on('needle', () => {\n\n        this._onPartEnd();\n    });\n\n    this._parts.on('haystack', (chunk) => {\n\n        this._onPart(chunk);\n    });\n\n    this._lines.on('needle', () => {\n\n        this._onLineEnd();\n    });\n\n    this._lines.on('haystack', (chunk) => {\n\n        this._onLine(chunk);\n    });\n\n    this.once('finish', () => {\n\n        this._parts.end();\n    });\n\n    this._parts.once('close', () => {\n\n        this._lines.end();\n    });\n\n    let piper = null;\n    let finish = (err) => {\n\n        if (piper) {\n            piper.removeListener('data', onReqData);\n            piper.removeListener('error', finish);\n            piper.removeListener('aborted', onReqAborted);\n        }\n\n        if (err) {\n            return this._abort(err);\n        }\n\n        this._emit('close');\n    };\n\n    finish = Hoek.once(finish);\n\n    this._lines.once('close', () => {\n\n        if (this._state === internals.state.epilogue) {\n            if (this._held) {\n                this._emit('epilogue', this._held);\n                this._held = '';\n            }\n        }\n        else if (this._state === internals.state.boundary) {\n            if (!this._held) {\n                this._abort(Boom.badRequest('Missing end boundary'));\n            }\n            else if (this._held !== '--') {\n                this._abort(Boom.badRequest('Only white space allowed after boundary at end'));\n            }\n        }\n        else {\n            this._abort(Boom.badRequest('Incomplete multipart payload'));\n        }\n\n        setImmediate(finish);                  // Give pending events a chance to fire\n    });\n\n    const onReqAborted = () => {\n\n        finish(Boom.badRequest('Client request aborted'));\n    };\n\n    const onReqData = (data) => {\n\n        this._bytes += Buffer.byteLength(data);\n\n        if (this._bytes > this._maxBytes) {\n            finish(Boom.badRequest('Maximum size exceeded'));\n        }\n    };\n\n    this.once('pipe', (req) => {\n\n        piper = req;\n        req.on('data', onReqData);\n        req.once('error', finish);\n        req.once('aborted', onReqAborted);\n    });\n};\n\nHoek.inherits(internals.Dispenser, Stream.Writable);\n\n\ninternals.Dispenser.prototype._write = function (buffer, encoding, next) {\n\n    if (this._error) {\n        return next();\n    }\n\n    this._parts.write(buffer);\n    return next();\n};\n\n\ninternals.Dispenser.prototype._emit = function () {\n\n    if (this._error) {\n        return;\n    }\n\n    this.emit.apply(this, arguments);\n};\n\n\ninternals.Dispenser.prototype._abort = function (err) {\n\n    this._emit('error', err);\n    this._error = err;\n};\n\n\ninternals.Dispenser.prototype._onPartEnd = function () {\n\n    this._lines.flush();\n\n    if (this._state === internals.state.preamble) {\n        if (this._held) {\n            const last = this._held.length - 1;\n\n            if (this._held[last] !== '\\n' ||\n                this._held[last - 1] !== '\\r') {\n\n                return this._abort(Boom.badRequest('Preamble missing CRLF terminator'));\n            }\n\n            this._emit('preamble', this._held.slice(0, -2));\n            this._held = '';\n        }\n\n        this._parts.needle(new Buffer('\\r\\n--' + this._boundary));                      // CRLF no longer optional\n    }\n\n    this._state = internals.state.boundary;\n\n    if (this._stream) {\n        this._stream.end();\n        this._stream = null;\n    }\n    else if (this._name) {\n        this._emit('field', this._name, this._held);\n        this._name = '';\n        this._held = '';\n    }\n};\n\n\ninternals.Dispenser.prototype._onPart = function (chunk) {\n\n    if (this._state === internals.state.preamble) {\n        this._held = this._held + chunk.toString();\n    }\n    else if (this._state === internals.state.payload) {\n        if (this._stream) {\n            this._stream.write(chunk);                                                 // Stream payload\n        }\n        else {\n            this._held = this._held + chunk.toString();\n        }\n    }\n    else {\n        this._lines.write(chunk);                                                       // Look for boundary\n    }\n};\n\n\ninternals.Dispenser.prototype._onLineEnd = function () {\n\n    // Boundary whitespace\n\n    if (this._state === internals.state.boundary) {\n        if (this._held) {\n            this._held = this._held.replace(/[\\t ]/g, '');                                // trim() removes new lines\n            if (this._held) {\n                if (this._held === '--') {\n                    this._state = internals.state.epilogue;\n                    this._held = '';\n\n                    return;\n                }\n\n                return this._abort(Boom.badRequest('Only white space allowed after boundary'));\n            }\n        }\n\n        this._state = internals.state.header;\n\n        return;\n    }\n\n    // Part headers\n\n    if (this._state === internals.state.header) {\n\n        // Header\n\n        if (this._held) {\n\n            // Header continuation\n\n            if (this._held[0] === ' ' ||\n                this._held[0] === '\\t') {\n\n                if (!this._pendingHeader) {\n                    return this._abort(Boom.badRequest('Invalid header continuation without valid declaration on previous line'));\n                }\n\n                this._pendingHeader = this._pendingHeader + ' ' + this._held.slice(1);                       // Drop tab\n                this._held = '';\n                return;\n            }\n\n            // Start of new header\n\n            this._flushHeader();\n            this._pendingHeader = this._held;\n            this._held = '';\n\n            return;\n        }\n\n        // End of headers\n\n        this._flushHeader();\n\n        this._state = internals.state.payload;\n\n        const disposition = Content.disposition(this._headers['content-disposition']);\n\n        if (disposition.isBoom) {\n            return this._abort(disposition);\n        }\n\n        if (disposition.filename !== undefined) {\n            const stream = new Stream.PassThrough();\n            const transferEncoding = this._headers['content-transfer-encoding'];\n\n            if (transferEncoding &&\n                transferEncoding.toLowerCase() === 'base64') {\n\n                this._stream = new B64.Decoder();\n                this._stream.pipe(stream);\n            }\n            else {\n                this._stream = stream;\n            }\n\n            stream.name = disposition.name;\n            stream.filename = disposition.filename;\n            stream.headers = this._headers;\n            this._headers = {};\n            this._emit('part', stream);\n        }\n        else {\n            this._name = disposition.name;\n        }\n\n        this._lines.flush();\n        return;\n    }\n\n    // Epilogue\n\n    this._held = this._held + '\\r\\n';                               // Put the new line back\n};\n\n\ninternals.Dispenser.prototype._onLine = function (chunk) {\n\n    if (this._stream) {\n        this._stream.write(chunk);                      // Stream payload\n    }\n    else {\n        this._held = this._held + chunk.toString();                 // Reading header or field\n    }\n};\n\n\ninternals.Dispenser.prototype._flushHeader = function () {\n\n    if (!this._pendingHeader) {\n        return;\n    }\n\n    const sep = this._pendingHeader.indexOf(':');\n\n    if (sep === -1) {\n        return this._abort(Boom.badRequest('Invalid header missing colon separator'));\n    }\n\n    if (!sep) {\n        return this._abort(Boom.badRequest('Invalid header missing field name'));\n    }\n\n    this._headers[this._pendingHeader.slice(0, sep).toLowerCase()] = this._pendingHeader.slice(sep + 1).trim();\n    this._pendingHeader = '';\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/b64/lib/index.js":"'use strict';\r\n\r\n// Load modules\r\n\r\nconst Decoder = require('./decoder');\r\nconst Encoder = require('./encoder');\r\n\r\n\r\nexports.decode = Decoder.decode;\r\nexports.encode = Encoder.encode;\r\n\r\nexports.Decoder = Decoder.Decoder;\r\nexports.Encoder = Encoder.Encoder;\r\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/b64/lib/decoder.js":"'use strict';\r\n\r\n/*\r\n    Decode functions adapted from:\r\n    Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\r\n    http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt\r\n*/\r\n\r\n// Load modules\r\n\r\nconst Stream = require('stream');\r\n\r\n\r\n// Declare internals\r\n\r\nconst internals = {\r\n    blank: new Buffer(''),\r\n    decodeChars: [\r\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\r\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\r\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,\r\n        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,\r\n        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\r\n        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,\r\n        -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\r\n        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1\r\n    ]\r\n};\r\n\r\n\r\nexports.decode = function (buffer) {\r\n\r\n    const decodeChars = internals.decodeChars;\r\n    const len = buffer.length;\r\n    const allocated = Math.ceil(len / 4) * 3;\r\n    const result = new Buffer(allocated);\r\n\r\n    let c1;\r\n    let c2;\r\n    let c3;\r\n    let c4;\r\n    let j = 0;\r\n\r\n    for (let i = 0; i < len; ) {\r\n        do {\r\n            c1 = decodeChars[buffer[i++] & 0xff];\r\n        }\r\n        while (i < len && c1 === -1);\r\n\r\n        if (c1 === -1) {\r\n            break;\r\n        }\r\n\r\n        do {\r\n            c2 = decodeChars[buffer[i++] & 0xff];\r\n        }\r\n        while (i < len && c2 === -1);\r\n\r\n        if (c2 === -1) {\r\n            break;\r\n        }\r\n\r\n        result[j++] = (c1 << 2) | ((c2 & 0x30) >> 4);\r\n\r\n        do {\r\n            c3 = buffer[i++] & 0xff;\r\n            if (c3 === 61) {                        // =\r\n                return result.slice(0, j);\r\n            }\r\n\r\n            c3 = decodeChars[c3];\r\n        }\r\n        while (i < len && c3 === -1);\r\n\r\n        if (c3 === -1) {\r\n            break;\r\n        }\r\n\r\n        result[j++] = ((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2);\r\n\r\n        do {\r\n            c4 = buffer[i++] & 0xff;\r\n            if (c4 === 61) {                        // =\r\n                return result.slice(0, j);\r\n            }\r\n\r\n            c4 = decodeChars[c4];\r\n        }\r\n        while (i < len && c4 === -1);\r\n\r\n        if (c4 !== -1) {\r\n            result[j++] = ((c3 & 0x03) << 6) | c4;\r\n        }\r\n    }\r\n\r\n    return (j === allocated ? result : result.slice(0, j));\r\n};\r\n\r\n\r\nexports.Decoder = class Decoder extends Stream.Transform {\r\n    constructor() {\r\n\r\n        super();\r\n        this._reminder = null;\r\n    }\r\n    _transform(chunk, encoding, callback) {\r\n\r\n        let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;\r\n        const remaining = part.length % 4;\r\n        if (remaining) {\r\n            this._reminder = part.slice(part.length - remaining);\r\n            part = part.slice(0, part.length - remaining);\r\n        }\r\n        else {\r\n            this._reminder = null;\r\n        }\r\n\r\n        this.push(exports.decode(part));\r\n        return callback();\r\n    }\r\n    _flush(callback) {\r\n\r\n        if (this._reminder) {\r\n            this.push(exports.decode(this._reminder));\r\n        }\r\n\r\n        return callback();\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/b64/lib/encoder.js":"'use strict';\r\n\r\n/*\r\n    Encode functions adapted from:\r\n    Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\r\n    http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt\r\n*/\r\n\r\n// Load modules\r\n\r\nconst Stream = require('stream');\r\n\r\n\r\n// Declare internals\r\n\r\nconst internals = {};\r\n\r\n\r\nexports.encode = function (buffer) {\r\n\r\n    return new Buffer(buffer.toString('base64'));\r\n};\r\n\r\n\r\nexports.Encoder = class Encoder extends Stream.Transform {\r\n    constructor() {\r\n\r\n        super();\r\n        this._reminder = null;\r\n    }\r\n    _transform(chunk, encoding, callback) {\r\n\r\n        let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;\r\n        const remaining = part.length % 3;\r\n        if (remaining) {\r\n            this._reminder = part.slice(part.length - remaining);\r\n            part = part.slice(0, part.length - remaining);\r\n        }\r\n        else {\r\n            this._reminder = null;\r\n        }\r\n\r\n        this.push(exports.encode(part));\r\n        return callback();\r\n    }\r\n    _flush(callback) {\r\n\r\n        if (this._reminder) {\r\n            this.push(exports.encode(this._reminder));\r\n        }\r\n\r\n        return callback();\r\n    }\r\n};\r\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/nigel/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Stream = require('stream');\nconst Hoek = require('hoek');\nconst Vise = require('vise');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.compile = function (needle) {\n\n    Hoek.assert(needle && needle.length, 'Missing needle');\n    Hoek.assert(Buffer.isBuffer(needle), 'Needle must be a buffer');\n\n    const profile = {\n        value: needle,\n        lastPos: needle.length - 1,\n        last: needle[needle.length - 1],\n        length: needle.length,\n        badCharShift: new Buffer(256)                  // Lookup table of how many characters can be skipped for each match\n    };\n\n    for (let i = 0; i < 256; ++i) {\n        profile.badCharShift[i] = profile.length;       // Defaults to the full length of the needle\n    }\n\n    const last = profile.length - 1;\n    for (let i = 0; i < last; ++i) {                    // For each character in the needle (skip last since its position is already the default)\n        profile.badCharShift[profile.value[i]] = last - i;\n    }\n\n    return profile;\n};\n\n\nexports.horspool = function (haystack, needle, start) {\n\n    Hoek.assert(haystack, 'Missing haystack');\n\n    needle = (needle.badCharShift ? needle : exports.compile(needle));\n    start = start || 0;\n\n    for (let i = start; i <= haystack.length - needle.length;) {       // Has enough room to fit the entire needle\n        const lastChar = haystack.readUInt8(i + needle.lastPos, true);\n        if (lastChar === needle.last &&\n            internals.startsWith(haystack, needle, i)) {\n\n            return i;\n        }\n\n        i += needle.badCharShift[lastChar];           // Jump to the next possible position based on last character location in needle\n    }\n\n    return -1;\n};\n\n\ninternals.startsWith = function (haystack, needle, pos) {\n\n    if (haystack.startsWith) {\n        return haystack.startsWith(needle.value, pos, needle.lastPos);\n    }\n\n    for (let i = 0; i < needle.lastPos; ++i) {\n        if (needle.value[i] !== haystack.readUInt8(pos + i, true)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\nexports.all = function (haystack, needle, start) {\n\n    needle = exports.compile(needle);\n    start = start || 0;\n\n    const matches = [];\n    for (let i = start; i !== -1 && i < haystack.length;) {\n\n        i = exports.horspool(haystack, needle, i);\n        if (i !== -1) {\n            matches.push(i);\n            i += needle.length;\n        }\n    }\n\n    return matches;\n};\n\n\ninternals._indexOf = function (haystack, needle) {\n\n    Hoek.assert(haystack, 'Missing haystack');\n\n    for (let i = 0; i <= haystack.length - needle.length; ++i) {       // Has enough room to fit the entire needle\n        if (haystack.startsWith(needle.value, i)) {\n            return i;\n        }\n    }\n\n    return -1;\n};\n\n\nexports.Stream = internals.Stream = function (needle) {\n\n    const self = this;\n\n    Stream.Writable.call(this);\n\n    this.needle(needle);\n    this._haystack = new Vise();\n    this._indexOf = this._needle.length > 2 ? exports.horspool : internals._indexOf;\n\n    this.on('finish', () => {\n\n        // Flush out the remainder\n\n        const chunks = self._haystack.chunks();\n        for (let i = 0; i < chunks.length; ++i) {\n            self.emit('haystack', chunks[i]);\n        }\n\n        setImmediate(() => {                  // Give pending events a chance to fire\n\n            self.emit('close');\n        });\n    });\n};\n\nHoek.inherits(internals.Stream, Stream.Writable);\n\n\ninternals.Stream.prototype.needle = function (needle) {\n\n    this._needle = exports.compile(needle);\n};\n\n\ninternals.Stream.prototype._write = function (chunk, encoding, next) {\n\n    this._haystack.push(chunk);\n\n    let match = this._indexOf(this._haystack, this._needle);\n    if (match === -1 &&\n        chunk.length >= this._needle.length) {\n\n        this._flush(this._haystack.length - chunk.length);\n    }\n\n    while (match !== -1) {\n        this._flush(match);\n        this._haystack.shift(this._needle.length);\n        this.emit('needle');\n\n        match = this._indexOf(this._haystack, this._needle);\n    }\n\n    if (this._haystack.length) {\n        const notChecked = this._haystack.length - this._needle.length + 1;       // Not enough space for Horspool\n        let i = notChecked;\n        for (; i < this._haystack.length; ++i) {\n            if (this._haystack.startsWith(this._needle.value, i, this._haystack.length - i)) {\n                break;\n            }\n        }\n\n        this._flush(i);\n    }\n\n    return next();\n};\n\n\ninternals.Stream.prototype._flush = function (pos) {\n\n    const chunks = this._haystack.shift(pos);\n    for (let i = 0; i < chunks.length; ++i) {\n        this.emit('haystack', chunks[i]);\n    }\n};\n\n\ninternals.Stream.prototype.flush = function () {\n\n    const chunks = this._haystack.shift(this._haystack.length);\n    for (let i = 0; i < chunks.length; ++i) {\n        this.emit('haystack', chunks[i]);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/vise/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Vise = function (chunks) {\n\n    this.length = 0;\n    this._chunks = [];\n    this._offset = 0;\n\n    if (chunks) {\n        chunks = [].concat(chunks);\n        for (let i = 0; i < chunks.length; ++i) {\n            this.push(chunks[i]);\n        }\n    }\n};\n\n\ninternals.Vise.prototype.push = function (chunk) {\n\n    Hoek.assert(Buffer.isBuffer(chunk), 'Chunk must be a buffer');\n\n    const item = {\n        data: chunk,\n        length: chunk.length,\n        offset: this.length + this._offset,\n        index: this._chunks.length\n    };\n\n    this._chunks.push(item);\n    this.length += chunk.length;\n};\n\n\ninternals.Vise.prototype.shift = function (length) {\n\n    if (!length) {\n        return [];\n    }\n\n    const prevOffset = this._offset;\n    const item = this._chunkAt(length);\n\n    let dropTo = this._chunks.length;\n    this._offset = 0;\n\n    if (item) {\n        dropTo = item.chunk.index;\n        this._offset = item.offset;\n    }\n\n    // Drop lower chunks\n\n    const chunks = [];\n    for (let i = 0; i < dropTo; ++i) {\n        const chunk = this._chunks.shift();\n        if (i === 0 &&\n            prevOffset) {\n\n            chunks.push(chunk.data.slice(prevOffset));\n        }\n        else {\n            chunks.push(chunk.data);\n        }\n    }\n\n    if (this._offset) {\n        chunks.push(item.chunk.data.slice(dropTo ? 0 : prevOffset, this._offset));\n    }\n\n    // Recalculate existing chunks\n\n    this.length = 0;\n    for (let i = 0; i < this._chunks.length; ++i) {\n        const chunk = this._chunks[i];\n        chunk.offset = this.length,\n        chunk.index = i;\n\n        this.length += chunk.length;\n    }\n\n    this.length -= this._offset;\n\n    return chunks;\n};\n\n\ninternals.Vise.prototype.at = internals.Vise.prototype.readUInt8 = function (pos) {\n\n    const item = this._chunkAt(pos);\n    return item ? item.chunk.data[item.offset] : undefined;\n};\n\n\ninternals.Vise.prototype._chunkAt = function (pos) {\n\n    if (pos < 0) {\n        return null;\n    }\n\n    pos = pos + this._offset;\n\n    for (let i = 0; i < this._chunks.length; ++i) {\n        const chunk = this._chunks[i];\n        const offset = pos - chunk.offset;\n        if (offset < chunk.length) {\n            return { chunk: chunk, offset: offset };\n        }\n    }\n\n    return null;\n};\n\n\ninternals.Vise.prototype.chunks = function () {\n\n    const chunks = [];\n\n    for (let i = 0; i < this._chunks.length; ++i) {\n        const chunk = this._chunks[i];\n        if (i === 0 &&\n            this._offset) {\n\n            chunks.push(chunk.data.slice(this._offset));\n        }\n        else {\n            chunks.push(chunk.data);\n        }\n    }\n\n    return chunks;\n};\n\n\ninternals.Vise.prototype.startsWith = function (value, pos, length) {\n\n    pos = pos || 0;\n\n    length = length ? Math.min(value.length, length) : value.length;\n    if (pos + length > this.length) {                                   // Not enough length to fit value\n        return false;\n    }\n\n    const start = this._chunkAt(pos);\n    if (!start) {\n        return false;\n    }\n\n    let j = start.chunk.index;\n    for (let i = 0; j < this._chunks.length && i < length; ++j) {\n        const chunk = this._chunks[j];\n\n        let k = (j === start.chunk.index ? start.offset : 0);\n        for (; k < chunk.length && i < length; ++k, ++i) {\n            if (chunk.data[k] !== value[i]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/wreck/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Events = require('events');\nconst Url = require('url');\nconst Http = require('http');\nconst Https = require('https');\nconst Stream = require('stream');\nconst Hoek = require('hoek');\nconst Boom = require('boom');\nconst Payload = require('./payload');\nconst Recorder = require('./recorder');\nconst Tap = require('./tap');\n\n\n// Declare internals\n\nconst internals = {\n    jsonRegex: /^application\\/[a-z.+-]*json$/,\n    shallowOptions: ['agent', 'payload', 'downstreamRes', 'beforeRedirect', 'redirected'],\n    emitSymbol: Symbol.for('wreck')\n};\n\nprocess[internals.emitSymbol] = process[internals.emitSymbol] || new Events.EventEmitter();\n\n\n// new instance is exported as module.exports\n\ninternals.Client = function (defaults) {\n\n    this.agents = {\n        https: new Https.Agent({ maxSockets: Infinity }),\n        http: new Http.Agent({ maxSockets: Infinity }),\n        httpsAllowUnauthorized: new Https.Agent({ maxSockets: Infinity, rejectUnauthorized: false })\n    };\n\n    this._defaults = defaults || {};\n\n    Events.EventEmitter.call(this);\n\n    // replay request/response events to process[Symbol.for('wreck')]\n    const self = this;\n    const selfEmit = this.emit;\n    this.emit = function () {\n\n        const processEmitter = process[internals.emitSymbol];\n        selfEmit.apply(self, arguments);\n        processEmitter.emit.apply(processEmitter, arguments);\n    };\n};\n\nHoek.inherits(internals.Client, Events.EventEmitter);\n\n\ninternals.Client.prototype.defaults = function (options) {\n\n    options = Hoek.applyToDefaultsWithShallow(options, this._defaults, internals.shallowOptions);\n    return new internals.Client(options);\n};\n\n\ninternals.resolveUrl = function (baseUrl, path) {\n\n    if (!path) {\n        return baseUrl;\n    }\n\n    const parsedPath = Url.parse(path);\n    if (parsedPath.host && parsedPath.protocol) {\n        return Url.format(parsedPath);\n    }\n\n    const parsedBase = Url.parse(baseUrl);\n    parsedBase.pathname = parsedBase.pathname + parsedPath.pathname;\n    parsedBase.pathname = parsedBase.pathname.replace(/[/]{2,}/g, '/');\n    parsedBase.search = parsedPath.search;      // Always use the querystring from the path argument\n\n    return Url.format(parsedBase);\n};\n\n\ninternals.Client.prototype.request = function (method, url, options, callback, _trace) {\n\n    options = Hoek.applyToDefaultsWithShallow(this._defaults, options || {}, internals.shallowOptions);\n\n    Hoek.assert(options.payload === undefined || typeof options.payload === 'string' || typeof options.payload === 'object',\n        'options.payload must be a string, a Buffer, a Stream, or an Object');\n\n    Hoek.assert((options.agent === undefined || options.agent === null) || (typeof options.rejectUnauthorized !== 'boolean'),\n        'options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set');\n\n    Hoek.assert(options.beforeRedirect === undefined || options.beforeRedirect === null || typeof options.beforeRedirect === 'function',\n        'options.beforeRedirect must be a function');\n\n    Hoek.assert(options.redirected === undefined || options.redirected === null || typeof options.redirected === 'function',\n        'options.redirected must be a function');\n\n    options.beforeRedirect = options.beforeRedirect || ((redirectMethod, statusCode, location, resHeaders, redirectOptions, next) => next());\n\n    if (options.baseUrl) {\n        url = internals.resolveUrl(options.baseUrl, url);\n        delete options.baseUrl;\n    }\n\n    const uri = Url.parse(url);\n\n    if (options.socketPath) {\n        uri.socketPath = options.socketPath;\n        delete options.socketPath;\n    }\n\n    uri.method = method.toUpperCase();\n    uri.headers = options.headers || {};\n    const hasContentLength = Object.keys(uri.headers).some((key) => {\n\n        return key.toLowerCase() === 'content-length';\n    });\n\n    if (options.payload && typeof options.payload === 'object' && !(options.payload instanceof Stream) && !Buffer.isBuffer(options.payload)) {\n        options.payload = JSON.stringify(options.payload);\n        uri.headers['content-type'] = uri.headers['content-type'] || 'application/json';\n    }\n\n    const payloadSupported = (uri.method !== 'GET' && uri.method !== 'HEAD' && options.payload !== null && options.payload !== undefined);\n    if (payloadSupported &&\n        (typeof options.payload === 'string' || Buffer.isBuffer(options.payload)) &&\n        (!hasContentLength)) {\n\n        uri.headers = Hoek.clone(uri.headers);\n        uri.headers['content-length'] = Buffer.isBuffer(options.payload) ? options.payload.length : Buffer.byteLength(options.payload);\n    }\n\n    let redirects = (options.hasOwnProperty('redirects') ? options.redirects : false);      // Needed to allow 0 as valid value when passed recursively\n\n    _trace = (_trace || []);\n    _trace.push({ method: uri.method, url });\n\n    const client = (uri.protocol === 'https:' ? Https : Http);\n\n    if (options.rejectUnauthorized !== undefined && uri.protocol === 'https:') {\n        uri.agent = options.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;\n    }\n    else if (options.agent || options.agent === false) {\n        uri.agent = options.agent;\n    }\n    else {\n        uri.agent = uri.protocol === 'https:' ? this.agents.https : this.agents.http;\n    }\n\n    if (options.secureProtocol !== undefined) {\n        uri.secureProtocol = options.secureProtocol;\n    }\n\n    this.emit('request', uri, options);\n\n    const start = Date.now();\n    const req = client.request(uri);\n\n    let shadow = null;                                                                      // A copy of the streamed request payload when redirects are enabled\n    let timeoutId;\n\n    const onError = (err) => {\n\n        err.trace = _trace;\n        return finishOnce(Boom.badGateway('Client request error', err));\n    };\n    req.once('error', onError);\n\n    const onResponse = (res) => {\n\n        // Pass-through response\n\n        const statusCode = res.statusCode;\n        const redirectMethod = internals.redirectMethod(statusCode, uri.method, options);\n\n        if (redirects === false ||\n            !redirectMethod) {\n\n            return finishOnce(null, res);\n        }\n\n        // Redirection\n\n        res.destroy();\n\n        if (redirects === 0) {\n            return finishOnce(Boom.badGateway('Maximum redirections reached', _trace));\n        }\n\n        let location = res.headers.location;\n        if (!location) {\n            return finishOnce(Boom.badGateway('Received redirection without location', _trace));\n        }\n\n        if (!/^https?:/i.test(location)) {\n            location = Url.resolve(uri.href, location);\n        }\n\n        const redirectOptions = Hoek.cloneWithShallow(options, internals.shallowOptions);\n        redirectOptions.payload = shadow || options.payload;                                    // shadow must be ready at this point if set\n        redirectOptions.redirects = --redirects;\n\n        return options.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, () => {\n\n            const redirectReq = this.request(redirectMethod, location, redirectOptions, finishOnce, _trace);\n\n            if (options.redirected) {\n                options.redirected(statusCode, location, redirectReq);\n            }\n        });\n    };\n\n    // Register handlers\n\n    const finish = (err, res) => {\n\n        if (err) {\n            req.abort();\n        }\n\n        req.removeListener('response', onResponse);\n        req.removeListener('error', onError);\n        req.on('error', Hoek.ignore);\n        clearTimeout(timeoutId);\n        this.emit('response', err, req, res, start, uri);\n\n        if (callback) {\n            return callback(err, res);\n        }\n    };\n\n    const finishOnce = Hoek.once(finish);\n\n    req.once('response', onResponse);\n\n    if (options.timeout) {\n        timeoutId = setTimeout(() => {\n\n            return finishOnce(Boom.gatewayTimeout('Client request timeout'));\n        }, options.timeout);\n        delete options.timeout;\n    }\n\n    // Custom abort method to detect early aborts\n\n    const _abort = req.abort;\n    let aborted = false;\n    req.abort = () => {\n\n        if (!aborted && !req.res && !req.socket) {\n            process.nextTick(() => {\n\n                // Fake an ECONNRESET error\n\n                const error = new Error('socket hang up');\n                error.code = 'ECONNRESET';\n                finishOnce(error);\n            });\n        }\n\n        aborted = true;\n        return _abort.call(req);\n    };\n\n    // Write payload\n\n    if (payloadSupported) {\n        if (options.payload instanceof Stream) {\n            let stream = options.payload;\n\n            if (redirects) {\n                const collector = new Tap();\n                collector.once('finish', () => {\n\n                    shadow = collector.collect();\n                });\n\n                stream = options.payload.pipe(collector);\n            }\n\n            stream.pipe(req);\n            return req;\n        }\n\n        req.write(options.payload);\n    }\n\n    // Finalize request\n\n    req.end();\n\n    return req;\n};\n\n\ninternals.redirectMethod = function (code, method, options) {\n\n    switch (code) {\n        case 301:\n        case 302:\n            return 'GET';\n\n        case 303:\n            if (options.redirect303) {\n                return 'GET';\n            }\n            break;\n\n        case 307:\n        case 308:\n            return method;\n    }\n\n    return null;\n};\n\n\n// read()\n\ninternals.Client.prototype.read = function (res, options, callback) {\n\n    options = Hoek.applyToDefaultsWithShallow(options || {}, this._defaults, internals.shallowOptions);\n\n    // Set stream timeout\n\n    const clientTimeout = options.timeout;\n    let clientTimeoutId = null;\n\n    // Finish once\n\n    const finish = (err, buffer) => {\n\n        clearTimeout(clientTimeoutId);\n        reader.removeListener('error', onReaderError);\n        reader.removeListener('finish', onReaderFinish);\n        res.removeListener('error', onResError);\n        res.removeListener('close', onResClose);\n        res.on('error', Hoek.ignore);\n\n        if (err ||\n            !options.json) {\n\n            return callback(err, buffer);\n        }\n\n        // Parse JSON\n\n        let result;\n        if (buffer.length === 0) {\n            return callback(null, null);\n        }\n\n        if (options.json === 'force') {\n            result = internals.tryParseBuffer(buffer);\n            return callback(result.err, result.json);\n        }\n\n        // mode is \"smart\" or true\n\n        const contentType = (res.headers && res.headers['content-type']) || '';\n        const mime = contentType.split(';')[0].trim().toLowerCase();\n\n        if (!internals.jsonRegex.test(mime)) {\n            return callback(null, buffer);\n        }\n\n        result = internals.tryParseBuffer(buffer);\n        return callback(result.err, result.json);\n    };\n\n    const finishOnce = Hoek.once(finish);\n\n    if (clientTimeout &&\n        clientTimeout > 0) {\n\n        clientTimeoutId = setTimeout(() => {\n\n            finishOnce(Boom.clientTimeout());\n        }, clientTimeout);\n    }\n\n    // Hander errors\n\n    const onResError = (err) => {\n\n        return finishOnce(Boom.internal('Payload stream error', err));\n    };\n\n    const onResClose = () => {\n\n        return finishOnce(Boom.internal('Payload stream closed prematurely'));\n    };\n\n    res.once('error', onResError);\n    res.once('close', onResClose);\n\n    // Read payload\n\n    const reader = new Recorder({ maxBytes: options.maxBytes });\n\n    const onReaderError = (err) => {\n\n        if (res.destroy) {                          // GZip stream has no destroy() method\n            res.destroy();\n        }\n\n        return finishOnce(err);\n    };\n\n    reader.once('error', onReaderError);\n\n    const onReaderFinish = () => {\n\n        return finishOnce(null, reader.collect());\n    };\n\n    reader.once('finish', onReaderFinish);\n\n    res.pipe(reader);\n};\n\n\n// toReadableStream()\n\ninternals.Client.prototype.toReadableStream = function (payload, encoding) {\n\n    return new Payload(payload, encoding);\n};\n\n\n// parseCacheControl()\n\ninternals.Client.prototype.parseCacheControl = function (field) {\n\n    /*\n        Cache-Control   = 1#cache-directive\n        cache-directive = token [ \"=\" ( token / quoted-string ) ]\n        token           = [^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+\n        quoted-string   = \"(?:[^\"\\\\]|\\\\.)*\"\n    */\n\n    //                             1: directive                                        =   2: token                                              3: quoted-string\n    const regex = /(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g;\n\n    const header = {};\n    const error = field.replace(regex, ($0, $1, $2, $3) => {\n\n        const value = $2 || $3;\n        header[$1] = value ? value.toLowerCase() : true;\n        return '';\n    });\n\n    if (header['max-age']) {\n        try {\n            const maxAge = parseInt(header['max-age'], 10);\n            if (isNaN(maxAge)) {\n                return null;\n            }\n\n            header['max-age'] = maxAge;\n        }\n        catch (err) { }\n    }\n\n    return (error ? null : header);\n};\n\n\n// Shortcuts\n\ninternals.Client.prototype.get = function (uri, options, callback) {\n\n    return this._shortcutWrap('GET', uri, options, callback);\n};\n\n\ninternals.Client.prototype.post = function (uri, options, callback) {\n\n    return this._shortcutWrap('POST', uri, options, callback);\n};\n\n\ninternals.Client.prototype.patch = function (uri, options, callback) {\n\n    return this._shortcutWrap('PATCH', uri, options, callback);\n};\n\n\ninternals.Client.prototype.put = function (uri, options, callback) {\n\n    return this._shortcutWrap('PUT', uri, options, callback);\n};\n\n\ninternals.Client.prototype.delete = function (uri, options, callback) {\n\n    return this._shortcutWrap('DELETE', uri, options, callback);\n};\n\n\n// Wrapper so that shortcut can be optimized with required params\n\ninternals.Client.prototype._shortcutWrap = function (method, uri /* [options], callback */) {\n\n    const options = (typeof arguments[2] === 'function' ? {} : arguments[2]);\n    const callback = (typeof arguments[2] === 'function' ? arguments[2] : arguments[3]);\n\n    return this._shortcut(method, uri, options, callback);\n};\n\n\ninternals.Client.prototype._shortcut = function (method, uri, options, callback) {\n\n    return this.request(method, uri, options, (err, res) => {\n\n        if (err) {\n            return callback(err);\n        }\n\n        this.read(res, options, (err, payload) => {\n\n            return callback(err, res, payload);\n        });\n    });\n};\n\n\ninternals.tryParseBuffer = function (buffer) {\n\n    const result = {\n        json: null,\n        err: null\n    };\n    try {\n        const json = JSON.parse(buffer.toString());\n        result.json = json;\n    }\n    catch (err) {\n        result.err = err;\n    }\n    return result;\n};\n\n\nmodule.exports = new internals.Client();\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/wreck/lib/payload.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Stream = require('stream');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nmodule.exports = internals.Payload = function (payload, encoding) {\n\n    Stream.Readable.call(this);\n\n    const data = [].concat(payload || '');\n    let size = 0;\n    for (let i = 0; i < data.length; ++i) {\n        const chunk = data[i];\n        size = size + chunk.length;\n        data[i] = Buffer.isBuffer(chunk) ? chunk : new Buffer(chunk);\n    }\n\n    this._data = Buffer.concat(data, size);\n    this._position = 0;\n    this._encoding = encoding || 'utf8';\n};\n\nHoek.inherits(internals.Payload, Stream.Readable);\n\n\ninternals.Payload.prototype._read = function (size) {\n\n    const chunk = this._data.slice(this._position, this._position + size);\n    this.push(chunk, this._encoding);\n    this._position = this._position + chunk.length;\n\n    if (this._position >= this._data.length) {\n        this.push(null);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/wreck/lib/recorder.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Stream = require('stream');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nmodule.exports = internals.Recorder = function (options) {\n\n    Stream.Writable.call(this);\n\n    this.settings = options;                // No need to clone since called internally with new object\n    this.buffers = [];\n    this.length = 0;\n};\n\nHoek.inherits(internals.Recorder, Stream.Writable);\n\n\ninternals.Recorder.prototype._write = function (chunk, encoding, next) {\n\n    if (this.settings.maxBytes &&\n        this.length + chunk.length > this.settings.maxBytes) {\n\n        return this.emit('error', Boom.badRequest('Payload content length greater than maximum allowed: ' + this.settings.maxBytes));\n    }\n\n    this.length = this.length + chunk.length;\n    this.buffers.push(chunk);\n    next();\n};\n\n\ninternals.Recorder.prototype.collect = function () {\n\n    const buffer = (this.buffers.length === 0 ? new Buffer(0) : (this.buffers.length === 1 ? this.buffers[0] : Buffer.concat(this.buffers, this.length)));\n    return buffer;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/wreck/lib/tap.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Stream = require('stream');\nconst Payload = require('./payload');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nmodule.exports = internals.Tap = function () {\n\n    Stream.Transform.call(this);\n    this.buffers = [];\n};\n\nHoek.inherits(internals.Tap, Stream.Transform);\n\n\ninternals.Tap.prototype._transform = function (chunk, encoding, next) {\n\n    this.buffers.push(chunk);\n    next(null, chunk);\n};\n\n\ninternals.Tap.prototype.collect = function () {\n\n    return new Payload(this.buffers);\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/handler.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Items = require('items');\nconst Methods = require('./methods');\nconst Response = require('./response');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.execute = function (request, next) {\n\n    const finalize = (err, result) => {\n\n        request._setResponse(err || result);\n        return next();                              // Must not include an argument\n    };\n\n    request._protect.run(finalize, (exit) => {\n\n        if (request._route._prerequisites) {\n            internals.prerequisites(request, Hoek.once(exit));\n        }\n        else {\n            internals.handler(request, exit);\n        }\n    });\n};\n\n\ninternals.prerequisites = function (request, callback) {\n\n    const each = (set, nextSet) => {\n\n        Items.parallel(set, (pre, next) => {\n\n            pre(request, (err, result) => {\n\n                if (err) {\n                    return next(err);\n                }\n\n                if (result._takeover) {\n                    return callback(null, result);\n                }\n\n                return next();\n            });\n        }, nextSet);\n    };\n\n    const domain = request.domain;      // Save a reference to the current domain\n\n    Items.serial(request._route._prerequisites, each, (err) => {\n\n        if (err) {\n            return callback(err);\n        }\n\n        const wrapped = domain ? domain.bind(internals.handler) : internals.handler;\n        return wrapped(request, callback);\n    });\n};\n\n\ninternals.handler = function (request, callback) {\n\n    const timer = new Hoek.Bench();\n    const finalize = (response) => {\n\n        if (response === null) {                            // reply.continue()\n            response = Response.wrap(null, request);\n            return response._prepare(finalize);\n        }\n\n        // Check for Error result\n\n        if (response.isBoom) {\n            request._log(['handler', 'error'], { msec: timer.elapsed(), error: response.message, data: response });\n            return callback(response);\n        }\n\n        request._log(['handler'], { msec: timer.elapsed() });\n        return callback(null, response);\n    };\n\n    // Decorate request\n\n    const reply = request.server._replier.interface(request, request.route.realm, {}, finalize);\n    const bind = request.route.settings.bind;\n\n    // Execute handler\n\n    request.route.settings.handler.call(bind, request, reply);\n};\n\n\nexports.defaults = function (method, handler, server) {\n\n    let defaults = null;\n\n    if (typeof handler === 'object') {\n        const type = Object.keys(handler)[0];\n        const serverHandler = server._handlers[type];\n\n        Hoek.assert(serverHandler, 'Unknown handler:', type);\n\n        if (serverHandler.defaults) {\n            defaults = (typeof serverHandler.defaults === 'function' ? serverHandler.defaults(method) : serverHandler.defaults);\n        }\n    }\n\n    return defaults || {};\n};\n\n\nexports.configure = function (handler, route) {\n\n    if (typeof handler === 'object') {\n        const type = Object.keys(handler)[0];\n        const serverHandler = route.server._handlers[type];\n\n        Hoek.assert(serverHandler, 'Unknown handler:', type);\n\n        return serverHandler(route.public, handler[type]);\n    }\n\n    if (typeof handler === 'string') {\n        const parsed = internals.fromString('handler', handler, route.server);\n        return parsed.method;\n    }\n\n    return handler;\n};\n\n\nexports.prerequisitesConfig = function (config, server) {\n\n    if (!config) {\n        return null;\n    }\n\n    /*\n        [\n            [\n                function (request, reply) { },\n                {\n                    method: function (request, reply) { }\n                    assign: key1\n                },\n                {\n                    method: function (request, reply) { },\n                    assign: key2\n                }\n            ],\n            'user(params.id)'\n        ]\n    */\n\n    const prerequisites = [];\n\n    for (let i = 0; i < config.length; ++i) {\n        const pres = [].concat(config[i]);\n\n        const set = [];\n        for (let j = 0; j < pres.length; ++j) {\n            let pre = pres[j];\n            if (typeof pre !== 'object') {\n                pre = { method: pre };\n            }\n\n            const item = {\n                method: pre.method,\n                assign: pre.assign,\n                failAction: pre.failAction || 'error'\n            };\n\n            if (typeof item.method === 'string') {\n                const parsed = internals.fromString('pre', item.method, server);\n                item.method = parsed.method;\n                item.assign = item.assign || parsed.name;\n            }\n\n            set.push(internals.pre(item));\n        }\n\n        prerequisites.push(set);\n    }\n\n    return prerequisites.length ? prerequisites : null;\n};\n\n\ninternals.fromString = function (type, notation, server) {\n\n    //                                  1:name            2:(        3:arguments\n    const methodParts = notation.match(/^([\\w\\.]+)(?:\\s*)(?:(\\()(?:\\s*)(\\w+(?:\\.\\w+)*(?:\\s*\\,\\s*\\w+(?:\\.\\w+)*)*)?(?:\\s*)\\))?$/);\n    Hoek.assert(methodParts, 'Invalid server method string notation:', notation);\n\n    const name = methodParts[1];\n    Hoek.assert(name.match(Methods.methodNameRx), 'Invalid server method name:', name);\n\n    const method = server._methods._normalized[name];\n    Hoek.assert(method, 'Unknown server method in string notation:', notation);\n\n    const result = { name };\n    const argsNotation = !!methodParts[2];\n    const methodArgs = (argsNotation ? (methodParts[3] || '').split(/\\s*\\,\\s*/) : null);\n\n    result.method = (request, reply) => {\n\n        if (!argsNotation) {\n            return method(request, reply);                      // Method is already bound to context\n        }\n\n        const finalize = (err, value, cached, report) => {\n\n            if (report) {\n                request._log([type, 'method', name], report);\n            }\n\n            return reply(err, value);\n        };\n\n        const args = [];\n        for (let i = 0; i < methodArgs.length; ++i) {\n            const arg = methodArgs[i];\n            if (arg) {\n                args.push(Hoek.reach(request, arg));\n            }\n        }\n\n        args.push(finalize);\n        method.apply(null, args);\n    };\n\n    return result;\n};\n\n\ninternals.pre = function (pre) {\n\n    /*\n        {\n            method: function (request, next) { }\n            assign:     'key'\n            failAction: 'error'* | 'log' | 'ignore'\n        }\n    */\n\n    return (request, next) => {\n\n        const timer = new Hoek.Bench();\n        const finalize = (response) => {\n\n            if (response === null) {                            // reply.continue()\n                response = Response.wrap(null, request);\n                return response._prepare(finalize);\n            }\n\n            if (response instanceof Error) {\n                if (pre.failAction !== 'ignore') {\n                    request._log(['pre', 'error'], { msec: timer.elapsed(), assign: pre.assign, error: response });\n                }\n\n                if (pre.failAction === 'error') {\n                    return next(response);\n                }\n            }\n            else {\n                request._log(['pre'], { msec: timer.elapsed(), assign: pre.assign });\n            }\n\n            if (pre.assign) {\n                request.pre[pre.assign] = response.source;\n                request.preResponses[pre.assign] = response;\n            }\n\n            return next(null, response);\n        };\n\n        // Setup environment\n\n        const reply = request.server._replier.interface(request, request.route.realm, {}, finalize);\n        const bind = request.route.settings.bind;\n\n        // Execute handler\n\n        pre.method.call(bind, request, reply);\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/methods.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Schema = require('./schema');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Methods = function (server) {\n\n    this.server = server;\n    this.methods = {};\n    this._normalized = {};\n};\n\n\ninternals.Methods.prototype.add = function (name, method, options, realm) {\n\n    if (typeof name !== 'object') {\n        return this._add(name, method, options, realm);\n    }\n\n    // {} or [{}, {}]\n\n    const items = [].concat(name);\n    for (let i = 0; i < items.length; ++i) {\n        const item = Schema.apply('methodObject', items[i]);\n        this._add(item.name, item.method, item.options, realm);\n    }\n};\n\n\nexports.methodNameRx = /^[_$a-zA-Z][$\\w]*(?:\\.[_$a-zA-Z][$\\w]*)*$/;\n\n\ninternals.Methods.prototype._add = function (name, method, options, realm) {\n\n    Hoek.assert(typeof method === 'function', 'method must be a function');\n    Hoek.assert(typeof name === 'string', 'name must be a string');\n    Hoek.assert(name.match(exports.methodNameRx), 'Invalid name:', name);\n    Hoek.assert(!Hoek.reach(this.methods, name, { functions: false }), 'Server method function name already exists:', name);\n\n    options = Schema.apply('method', options || {}, name);\n\n    const settings = Hoek.cloneWithShallow(options, ['bind']);\n    settings.generateKey = settings.generateKey || internals.generateKey;\n    const bind = settings.bind || realm.settings.bind || null;\n\n    const apply = function () {\n\n        return method.apply(bind, arguments);\n    };\n\n    const bound = bind ? apply : method;\n\n    // Normalize methods\n\n    let normalized = bound;\n    if (settings.callback === false) {                                          // Defaults to true\n        normalized = function (/* arg1, arg2, ..., argn, methodNext */) {\n\n            const args = [];\n            for (let i = 0; i < arguments.length - 1; ++i) {\n                args.push(arguments[i]);\n            }\n\n            const methodNext = arguments[arguments.length - 1];\n\n            let result = null;\n            let error = null;\n\n            try {\n                result = method.apply(bind, args);\n            }\n            catch (err) {\n                error = err;\n            }\n\n            if (result instanceof Error) {\n                error = result;\n                result = null;\n            }\n\n            if (error ||\n                typeof result !== 'object' ||\n                typeof result.then !== 'function') {\n\n                return methodNext(error, result);\n            }\n\n            // Promise object\n\n            const onFulfilled = (outcome) => methodNext(null, outcome);\n            const onRejected = (err) => methodNext(err);\n            result.then(onFulfilled, onRejected);\n        };\n    }\n\n    // Not cached\n\n    if (!settings.cache) {\n        return this._assign(name, bound, normalized);\n    }\n\n    // Cached\n\n    Hoek.assert(!settings.cache.generateFunc, 'Cannot set generateFunc with method caching:', name);\n    Hoek.assert(settings.cache.generateTimeout !== undefined, 'Method caching requires a timeout value in generateTimeout:', name);\n\n    settings.cache.generateFunc = (id, next) => {\n\n        id.args.push(next);                     // function (err, result, ttl)\n        normalized.apply(bind, id.args);\n    };\n\n    const cache = this.server.cache(settings.cache, '#' + name);\n\n    const func = function (/* arguments, methodNext */) {\n\n        const args = [];\n        for (let i = 0; i < arguments.length - 1; ++i) {\n            args.push(arguments[i]);\n        }\n\n        const methodNext = arguments[arguments.length - 1];\n\n        const key = settings.generateKey.apply(bind, args);\n        if (key === null ||                                 // Value can be ''\n            typeof key !== 'string') {                      // When using custom generateKey\n\n            return Hoek.nextTick(methodNext)(Boom.badImplementation('Invalid method key when invoking: ' + name, { name, args }));\n        }\n\n        cache.get({ id: key, args }, methodNext);\n    };\n\n    func.cache = {\n        drop: function (/* arguments, callback */) {\n\n            const args = [];\n            for (let i = 0; i < arguments.length - 1; ++i) {\n                args.push(arguments[i]);\n            }\n\n            const methodNext = arguments[arguments.length - 1];\n\n            const key = settings.generateKey.apply(null, args);\n            if (key === null) {                             // Value can be ''\n                return Hoek.nextTick(methodNext)(Boom.badImplementation('Invalid method key'));\n            }\n\n            return cache.drop(key, methodNext);\n        },\n        stats: cache.stats\n    };\n\n    this._assign(name, func, func);\n};\n\n\ninternals.Methods.prototype._assign = function (name, method, normalized) {\n\n    const path = name.split('.');\n    let ref = this.methods;\n    for (let i = 0; i < path.length; ++i) {\n        if (!ref[path[i]]) {\n            ref[path[i]] = (i + 1 === path.length ? method : {});\n        }\n\n        ref = ref[path[i]];\n    }\n\n    this._normalized[name] = normalized;\n};\n\n\ninternals.generateKey = function () {\n\n    let key = '';\n    for (let i = 0; i < arguments.length; ++i) {\n        const arg = arguments[i];\n        if (typeof arg !== 'string' &&\n            typeof arg !== 'number' &&\n            typeof arg !== 'boolean') {\n\n            return null;\n        }\n\n        key = key + (i ? ':' : '') + encodeURIComponent(arg.toString());\n    }\n\n    return key;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/response.js":"'use strict';\n\n// Load modules\n\nconst Stream = require('stream');\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Podium = require('podium');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Response = function (source, request, options) {\n\n    Podium.call(this, ['finish', { name: 'peek', spread: true }]);\n\n    options = options || {};\n\n    this.request = request;\n    this.statusCode = null;\n    this.headers = {};                          // Incomplete as some headers are stored in flags\n    this.variety = null;\n    this.source = null;\n    this.app = {};\n    this.plugins = {};\n    this.send = null;                           // Set by reply()\n    this.hold = null;                           // Set by reply()\n\n    this.settings = {\n        encoding: 'utf8',\n        charset: 'utf-8',                       // '-' required by IANA\n        ttl: null,\n        stringify: null,                        // JSON.stringify options\n        passThrough: true,\n        varyEtag: false,\n        message: null\n    };\n\n    this._payload = null;                       // Readable stream\n    this._takeover = false;\n    this._contentEncoding = null;               // Set during transmit\n    this._contentType = null;                   // Used if no explicit content-type is set and type is known\n    this._error = null;                         // The boom object when created from an error\n\n    this._processors = {\n        marshal: options.marshal,\n        prepare: options.prepare,\n        close: options.close\n    };\n\n    this._setSource(source, options.variety);\n};\n\nHoek.inherits(internals.Response, Podium);\n\n\ninternals.Response.wrap = function (result, request) {\n\n    return (result instanceof Error ? Boom.wrap(result)\n                                    : (result instanceof internals.Response ? result\n                                                                            : new internals.Response(result, request)));\n};\n\n\ninternals.Response.prototype._setSource = function (source, variety) {\n\n    // Method must not set any headers or other properties as source can change later\n\n    this.variety = variety || 'plain';\n\n    if (source === null ||\n        source === undefined ||\n        source === '') {\n\n        source = null;\n    }\n    else if (Buffer.isBuffer(source)) {\n        this.variety = 'buffer';\n        this._contentType = 'application/octet-stream';\n    }\n    else if (source instanceof Stream) {\n        this.variety = 'stream';\n    }\n    else if (typeof source === 'object' &&\n        typeof source.then === 'function') {                // Promise object\n\n        this.variety = 'promise';\n    }\n\n    this.source = source;\n\n    if (this.variety === 'plain' &&\n        this.source !== null) {\n\n        this._contentType = (typeof this.source === 'string' ? 'text/html' : 'application/json');\n    }\n};\n\n\ninternals.Response.prototype.code = function (statusCode) {\n\n    Hoek.assert(Hoek.isInteger(statusCode), 'Status code must be an integer');\n\n    this.statusCode = statusCode;\n    return this;\n};\n\n\ninternals.Response.prototype.message = function (httpMessage) {\n\n    this.settings.message = httpMessage;\n    return this;\n};\n\n\ninternals.Response.prototype.header = function (key, value, options) {\n\n    key = key.toLowerCase();\n    if (key === 'vary') {\n        return this.vary(value);\n    }\n\n    return this._header(key, value, options);\n};\n\n\ninternals.Response.prototype._header = function (key, value, options) {\n\n    options = options || {};\n    const append = options.append || false;\n    const separator = options.separator || ',';\n    const override = options.override !== false;\n    const duplicate = options.duplicate !== false;\n\n    if ((!append && override) ||\n        !this.headers[key]) {\n\n        this.headers[key] = value;\n    }\n    else if (override) {\n        if (key === 'set-cookie') {\n            this.headers[key] = [].concat(this.headers[key], value);\n        }\n        else {\n            const existing = this.headers[key];\n            if (!duplicate) {\n                const values = existing.split(separator);\n                for (let i = 0; i < values.length; ++i) {\n                    if (values[i] === value) {\n                        return this;\n                    }\n                }\n            }\n\n            this.headers[key] = existing + separator + value;\n        }\n    }\n\n    return this;\n};\n\n\ninternals.Response.prototype.vary = function (value) {\n\n    if (value === '*') {\n        this.headers.vary = '*';\n    }\n    else if (!this.headers.vary) {\n        this.headers.vary = value;\n    }\n    else if (this.headers.vary !== '*') {\n        this._header('vary', value, { append: true, duplicate: false });\n    }\n\n    return this;\n};\n\n\ninternals.Response.prototype.etag = function (tag, options) {\n\n    Hoek.assert(tag !== '*', 'ETag cannot be *');\n\n    options = options || {};\n    this._header('etag', (options.weak ? 'W/' : '') + '\"' + tag + '\"');\n    this.settings.varyEtag = options.vary !== false && !options.weak;       // vary defaults to true\n    return this;\n};\n\n\ninternals.Response.unmodified = function (request, options) {\n\n    if (request.method !== 'get' &&\n        request.method !== 'head') {\n\n        return false;\n    }\n\n    // Strong verifier\n\n    if (options.etag &&\n        request.headers['if-none-match']) {\n\n        const ifNoneMatch = request.headers['if-none-match'].split(/\\s*,\\s*/);\n        for (let i = 0; i < ifNoneMatch.length; ++i) {\n            const etag = ifNoneMatch[i];\n            if (etag === options.etag) {\n                return true;\n            }\n\n            if (options.vary) {\n                const etagBase = options.etag.slice(0, -1);\n                const encoders = request.connection._compression.encodings;\n                for (let j = 0; j < encoders.length; ++j) {\n                    if (etag === etagBase + `-${encoders[j]}\"`) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    // Weak verifier\n\n    const ifModifiedSinceHeader = request.headers['if-modified-since'];\n\n    if (ifModifiedSinceHeader &&\n        options.modified) {\n\n        const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);\n        const lastModified = internals.parseDate(options.modified);\n\n        if (ifModifiedSince &&\n            lastModified &&\n            ifModifiedSince >= lastModified) {\n\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\ninternals.parseDate = function (string) {\n\n    try {\n        return Date.parse(string);\n    }\n    catch (errIgnore) { }\n};\n\n\ninternals.Response.prototype.type = function (type) {\n\n    this._header('content-type', type);\n    return this;\n};\n\n\ninternals.Response.prototype.bytes = function (bytes) {\n\n    this._header('content-length', bytes);\n    return this;\n};\n\n\ninternals.Response.prototype.location = function (uri) {\n\n    this._header('location', uri);\n    return this;\n};\n\n\ninternals.Response.prototype.created = function (location) {\n\n    Hoek.assert(this.request.method === 'post' || this.request.method === 'put', 'Cannot create resource on GET');\n\n    this.statusCode = 201;\n    this.location(location);\n    return this;\n};\n\n\ninternals.Response.prototype.replacer = function (method) {\n\n    this.settings.stringify = this.settings.stringify || {};\n    this.settings.stringify.replacer = method;\n    return this;\n};\n\n\ninternals.Response.prototype.spaces = function (count) {\n\n    this.settings.stringify = this.settings.stringify || {};\n    this.settings.stringify.space = count;\n    return this;\n};\n\n\ninternals.Response.prototype.suffix = function (suffix) {\n\n    this.settings.stringify = this.settings.stringify || {};\n    this.settings.stringify.suffix = suffix;\n    return this;\n};\n\n\ninternals.Response.prototype.passThrough = function (enabled) {\n\n    this.settings.passThrough = (enabled !== false);    // Defaults to true\n    return this;\n};\n\n\ninternals.Response.prototype.redirect = function (location) {\n\n    this.statusCode = 302;\n    this.location(location);\n    this.temporary = this._temporary;\n    this.permanent = this._permanent;\n    this.rewritable = this._rewritable;\n    return this;\n};\n\n\ninternals.Response.prototype._temporary = function (isTemporary) {\n\n    this._setTemporary(isTemporary !== false);           // Defaults to true\n    return this;\n};\n\n\ninternals.Response.prototype._permanent = function (isPermanent) {\n\n    this._setTemporary(isPermanent === false);           // Defaults to true\n    return this;\n};\n\n\ninternals.Response.prototype._rewritable = function (isRewritable) {\n\n    this._setRewritable(isRewritable !== false);         // Defaults to true\n    return this;\n};\n\n\ninternals.Response.prototype._isTemporary = function () {\n\n    return this.statusCode === 302 || this.statusCode === 307;\n};\n\n\ninternals.Response.prototype._isRewritable = function () {\n\n    return this.statusCode === 301 || this.statusCode === 302;\n};\n\n\ninternals.Response.prototype._setTemporary = function (isTemporary) {\n\n    if (isTemporary) {\n        if (this._isRewritable()) {\n            this.statusCode = 302;\n        }\n        else {\n            this.statusCode = 307;\n        }\n    }\n    else {\n        if (this._isRewritable()) {\n            this.statusCode = 301;\n        }\n        else {\n            this.statusCode = 308;\n        }\n    }\n};\n\n\ninternals.Response.prototype._setRewritable = function (isRewritable) {\n\n    if (isRewritable) {\n        if (this._isTemporary()) {\n            this.statusCode = 302;\n        }\n        else {\n            this.statusCode = 301;\n        }\n    }\n    else {\n        if (this._isTemporary()) {\n            this.statusCode = 307;\n        }\n        else {\n            this.statusCode = 308;\n        }\n    }\n};\n\n\ninternals.Response.prototype.encoding = function (encoding) {\n\n    this.settings.encoding = encoding;\n    return this;\n};\n\n\ninternals.Response.prototype.charset = function (charset) {\n\n    this.settings.charset = charset || null;\n    return this;\n};\n\n\ninternals.Response.prototype.ttl = function (ttl) {\n\n    this.settings.ttl = ttl;\n    return this;\n};\n\n\ninternals.Response.prototype.state = function (name, value, options) {          // options: see Defaults.state\n\n    this.request._setState(name, value, options);\n    return this;\n};\n\n\ninternals.Response.prototype.unstate = function (name, options) {\n\n    this.request._clearState(name, options);\n    return this;\n};\n\n\ninternals.Response.prototype.takeover = function () {\n\n    this._takeover = true;\n    return this;\n};\n\n\ninternals.Response.prototype._prepare = function (next) {\n\n    this._passThrough();\n\n    if (this.variety !== 'promise') {\n        return this._processPrepare(next);\n    }\n\n    const onDone = Hoek.nextTick((source) => {\n\n        if (source instanceof Error) {\n            return next(Boom.wrap(source));\n        }\n\n        if (source instanceof internals.Response) {\n            return source._processPrepare(next);\n        }\n\n        this._setSource(source);\n        this._passThrough();\n        this._processPrepare(next);\n    });\n\n    const onError = (source) => {\n\n        if (!(source instanceof Error)) {\n            const err = new Error('Rejected promise');\n            err.data = source;\n            return next(Boom.wrap(err));\n        }\n\n        return next(Boom.wrap(source));\n    };\n\n    this.source.then(onDone, onError);\n};\n\n\ninternals.Response.prototype._passThrough = function () {\n\n    if (this.variety === 'stream' &&\n        this.settings.passThrough) {\n\n        if (this.source.statusCode &&\n            !this.statusCode) {\n\n            this.statusCode = this.source.statusCode;                        // Stream is an HTTP response\n        }\n\n        if (this.source.headers) {\n            let headerKeys = Object.keys(this.source.headers);\n\n            if (headerKeys.length) {\n                const localHeaders = this.headers;\n                this.headers = {};\n\n                for (let i = 0; i < headerKeys.length; ++i) {\n                    const key = headerKeys[i];\n                    this.header(key.toLowerCase(), Hoek.clone(this.source.headers[key]));     // Clone arrays\n                }\n\n                headerKeys = Object.keys(localHeaders);\n                for (let i = 0; i < headerKeys.length; ++i) {\n                    const key = headerKeys[i];\n                    this.header(key, localHeaders[key], { append: key === 'set-cookie' });\n                }\n            }\n        }\n    }\n\n    this.statusCode = this.statusCode || 200;\n};\n\n\ninternals.Response.prototype._processPrepare = function (next) {\n\n    if (!this._processors.prepare) {\n        return next(this);\n    }\n\n    return this._processors.prepare(this, next);\n};\n\n\ninternals.Response.prototype._marshal = function (next) {\n\n    if (!this._processors.marshal) {\n        return this._streamify(this.source, next);\n    }\n\n    this._processors.marshal(this, (err, source) => {\n\n        if (err) {\n            return next(err);\n        }\n\n        return this._streamify(source, next);\n    });\n};\n\n\ninternals.Response.prototype._streamify = function (source, next) {\n\n    if (source instanceof Stream) {\n        if (typeof source._read !== 'function' || typeof source._readableState !== 'object') {\n            return next(Boom.badImplementation('Stream must have a streams2 readable interface'));\n        }\n\n        if (source._readableState.objectMode) {\n            return next(Boom.badImplementation('Cannot reply with stream in object mode'));\n        }\n\n        this._payload = source;\n        return next();\n    }\n\n    let payload = source;\n    if (this.variety === 'plain' &&\n        source !== null &&\n        typeof source !== 'string') {\n\n        const options = this.settings.stringify || {};\n        const space = options.space || this.request.route.settings.json.space;\n        const replacer = options.replacer || this.request.route.settings.json.replacer;\n        const suffix = options.suffix || this.request.route.settings.json.suffix || '';\n        try {\n            if (replacer || space) {\n                payload = JSON.stringify(payload, replacer, space);\n            }\n            else {\n                payload = JSON.stringify(payload);\n            }\n        }\n        catch (err) {\n            return next(err);\n        }\n\n        if (suffix) {\n            payload = payload + suffix;\n        }\n    }\n    else if (this.settings.stringify) {\n        return next(Boom.badImplementation('Cannot set formatting options on non object response'));\n    }\n\n    this._payload = new internals.Payload(payload, this.settings);\n    return next();\n};\n\n\ninternals.Response.prototype._tap = function () {\n\n    return (this.hasListeners('finish') || this.hasListeners('peek') ? new internals.Peek(this) : null);\n};\n\n\ninternals.Response.prototype._close = function () {\n\n    if (this._processors.close) {\n        this._processors.close(this);\n    }\n\n    const stream = this._payload || this.source;\n    if (stream instanceof Stream) {\n        if (stream.close) {\n            stream.close();\n        }\n        else if (stream.destroy) {\n            stream.destroy();\n        }\n        else {\n            const read = () => {\n\n                stream.read();\n            };\n\n            const end = () => {\n\n                stream.removeListener('readable', read);\n                stream.removeListener('error', end);\n                stream.removeListener('end', end);\n            };\n\n            stream.on('readable', read);\n            stream.once('error', end);\n            stream.once('end', end);\n        }\n    }\n};\n\n\ninternals.Response.prototype._isPayloadSupported = function () {\n\n    return (this.request.method !== 'head' && this.statusCode !== 304 && this.statusCode !== 204);\n};\n\n\ninternals.Response.Payload = internals.Payload = function (payload, options) {\n\n    Stream.Readable.call(this);\n    this._data = payload;\n    this._prefix = null;\n    this._suffix = null;\n    this._sizeOffset = 0;\n    this._encoding = options.encoding;\n};\n\nHoek.inherits(internals.Payload, Stream.Readable);\n\n\ninternals.Payload.prototype._read = function (/* size */) {\n\n    if (this._prefix) {\n        this.push(this._prefix, this._encoding);\n    }\n\n    if (this._data) {\n        this.push(this._data, this._encoding);\n    }\n\n    if (this._suffix) {\n        this.push(this._suffix, this._encoding);\n    }\n\n    this.push(null);\n};\n\n\ninternals.Payload.prototype.size = function () {\n\n    if (!this._data) {\n        return this._sizeOffset;\n    }\n\n    return (Buffer.isBuffer(this._data) ? this._data.length : Buffer.byteLength(this._data, this._encoding)) + this._sizeOffset;\n};\n\n\ninternals.Payload.prototype.jsonp = function (variable) {\n\n    this._sizeOffset = this._sizeOffset + variable.length + 7;\n    this._prefix = '/**/' + variable + '(';                 // '/**/' prefix prevents CVE-2014-4671 security exploit\n    this._data = (this._data === null || Buffer.isBuffer(this._data)) ? this._data : this._data.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n    this._suffix = ');';\n};\n\n\ninternals.Response.Peek = internals.Peek = function (podium) {\n\n    Stream.Transform.call(this);\n    this._podium = podium;\n    this.once('finish', () => {\n\n        podium.emit('finish');\n    });\n};\n\nHoek.inherits(internals.Peek, Stream.Transform);\n\n\ninternals.Peek.prototype._transform = function (chunk, encoding, callback) {\n\n    this._podium.emit('peek', [chunk, encoding]);\n    this.push(chunk, encoding);\n    callback();\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/validation.js":"'use strict';\n\n// Load modules\n\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Joi = require('joi');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.compile = function (rule) {\n\n    // null, undefined, true - anything allowed\n    // false - nothing allowed\n    // {...} - ... allowed\n\n    return (rule === false ? Joi.object({}).allow(null)\n                           : typeof rule === 'function' ? rule\n                                                        : !rule || rule === true ? null                     // false tested earlier\n                                                                                 : Joi.compile(rule));\n};\n\n\nexports.query = function (request, next) {\n\n    return internals.input('query', request, next);\n};\n\n\nexports.payload = function (request, next) {\n\n    if (request.method === 'get' ||\n        request.method === 'head') {                // When route.method is '*'\n\n        return next();\n    }\n\n    return internals.input('payload', request, next);\n};\n\n\nexports.params = function (request, next) {\n\n    return internals.input('params', request, next);\n};\n\n\nexports.headers = function (request, next) {\n\n    return internals.input('headers', request, next);\n};\n\n\ninternals.input = function (source, request, next) {\n\n    const postValidate = (err, value) => {\n\n        request.orig[source] = request[source];\n        if (value !== undefined) {\n            request[source] = value;\n        }\n\n        if (!err) {\n            return next();\n        }\n\n        if (err.isDeveloperError) {\n            return next(err);\n        }\n\n        // failAction: 'error', 'log', 'ignore', function (source, err, next)\n\n        if (request.route.settings.validate.failAction === 'ignore') {\n            return next();\n        }\n\n        // Prepare error\n\n        const error = (err.isBoom ? err : Boom.badRequest(err.message, err));\n        error.output.payload.validation = { source, keys: [] };\n        if (err.details) {\n            for (let i = 0; i < err.details.length; ++i) {\n                error.output.payload.validation.keys.push(Hoek.escapeHtml(err.details[i].path));\n            }\n        }\n\n        if (request.route.settings.validate.errorFields) {\n            const fields = Object.keys(request.route.settings.validate.errorFields);\n            for (let i = 0; i < fields.length; ++i) {\n                const field = fields[i];\n                error.output.payload[field] = request.route.settings.validate.errorFields[field];\n            }\n        }\n\n        request._log(['validation', 'error', source], error);\n\n        // Log only\n\n        if (request.route.settings.validate.failAction === 'log') {\n            return next();\n        }\n\n        // Return error\n\n        if (typeof request.route.settings.validate.failAction !== 'function') {\n            return next(error);\n        }\n\n        // Custom handler\n\n        request._protect.run(next, (exit) => {\n\n            const reply = request.server._replier.interface(request, request.route.realm, {}, exit);\n            request.route.settings.validate.failAction(request, reply, source, error);\n        });\n    };\n\n    const localOptions = {\n        context: {\n            headers: request.headers,\n            params: request.params,\n            query: request.query,\n            payload: request.payload,\n            auth: request.auth\n        }\n    };\n\n    delete localOptions.context[source];\n    Hoek.merge(localOptions, request.route.settings.validate.options);\n\n    const schema = request.route.settings.validate[source];\n    if (typeof schema !== 'function') {\n        return Joi.validate(request[source], schema, localOptions, postValidate);\n    }\n\n    request._protect.run(postValidate, (exit) => {\n\n        const bind = request.route.settings.bind;\n        return schema.call(bind, request[source], localOptions, exit);\n    });\n};\n\n\nexports.response = function (request, next) {\n\n    if (request.route.settings.response.sample) {\n        const currentSample = Math.ceil((Math.random() * 100));\n        if (currentSample > request.route.settings.response.sample) {\n            return next();\n        }\n    }\n\n    const response = request.response;\n    const statusCode = response.isBoom ? response.output.statusCode : response.statusCode;\n\n    const statusSchema = request.route.settings.response.status[statusCode];\n    if (statusCode >= 400 &&\n        !statusSchema) {\n\n        return next();          // Do not validate errors by default\n    }\n\n    const schema = statusSchema || request.route.settings.response.schema;\n    if (schema === null) {\n        return next();          // No rules\n    }\n\n    if (!response.isBoom &&\n        request.response.variety !== 'plain') {\n\n        return next(Boom.badImplementation('Cannot validate non-object response'));\n    }\n\n    const postValidate = (err, value) => {\n\n        if (!err) {\n            if (value !== undefined &&\n                request.route.settings.response.modify) {\n\n                if (response.isBoom) {\n                    response.output.payload = value;\n                }\n                else {\n                    response.source = value;\n                }\n            }\n\n            return next();\n        }\n\n        // failAction: 'error', 'log'\n\n        if (request.route.settings.response.failAction === 'log') {\n            request._log(['validation', 'response', 'error'], err.message);\n            return next();\n        }\n\n        // Return error\n\n        if (typeof request.route.settings.response.failAction !== 'function') {\n            return next(Boom.badImplementation(err.message));\n        }\n\n        // Custom handler\n\n        request._protect.run(next, (exit) => {\n\n            const reply = request.server._replier.interface(request, request.route.realm, {}, exit);\n            request.route.settings.response.failAction(request, reply, err);\n        });\n    };\n\n    const localOptions = {\n        context: {\n            headers: request.headers,\n            params: request.params,\n            query: request.query,\n            payload: request.payload,\n            auth: {\n                isAuthenticated: request.auth.isAuthenticated,\n                credentials: request.auth.credentials\n            }\n        }\n    };\n\n    const source = response.isBoom ? response.output.payload : response.source;\n    Hoek.merge(localOptions, request.route.settings.response.options);\n\n    if (typeof schema !== 'function') {\n        return Joi.validate(source, schema, localOptions, postValidate);\n    }\n\n    request._protect.run(postValidate, (exit) => {\n\n        return schema(source, localOptions, exit);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/plugin.js":"'use strict';\n\n// Load modules\n\nconst Catbox = require('catbox');\nconst Hoek = require('hoek');\nconst Items = require('items');\nconst Podium = require('podium');\nconst Connection = require('./connection');\nconst Ext = require('./ext');\nconst Package = require('../package.json');\nconst Promises = require('./promises');\nconst Schema = require('./schema');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Plugin = function (server, connections, env, parent) {         // env can be a realm or plugin name\n\n    Podium.call(this, [connections && connections.length ? connections : Connection._events, server._events]);\n\n    this._parent = parent;\n\n    // Public interface\n\n    this.root = server;\n    this.app = this.root._app;\n    this.connections = connections;\n    this.load = this.root._heavy.load;\n    this.methods = this.root._methods.methods;\n    this.mime = this.root._mime;\n    this.plugins = this.root._plugins;\n    this.settings = this.root._settings;\n    this.version = Package.version;\n\n    this.realm = typeof env !== 'string' ? env : {\n        _extensions: {\n            onPreAuth: new Ext('onPreAuth', this.root),\n            onPostAuth: new Ext('onPostAuth', this.root),\n            onPreHandler: new Ext('onPreHandler', this.root),\n            onPostHandler: new Ext('onPostHandler', this.root),\n            onPreResponse: new Ext('onPreResponse', this.root)\n        },\n        modifiers: {\n            route: {}\n        },\n        plugin: env,\n        pluginOptions: {},\n        plugins: {},\n        settings: {\n            bind: undefined,\n            files: {\n                relativeTo: undefined\n            }\n        }\n    };\n\n    this.auth = {\n        default: (opts) => this._applyChild('auth.default', 'auth', 'default', [opts]),\n        scheme: (name, scheme) => this._applyChild('auth.scheme', 'auth', 'scheme', [name, scheme]),\n        strategy: (name, scheme, mode, opts) => this._applyChild('auth.strategy', 'auth', 'strategy', [name, scheme, mode, opts]),\n        test: (name, request, next) => request.connection.auth.test(name, request, next)\n    };\n\n    this.cache.provision = (opts, callback) => {\n\n        if (!callback) {\n            return Promises.wrap(null, this.cache.provision, [opts]);\n        }\n\n        return this.root._createCache(opts, callback);\n    };\n\n    this._single();\n\n    // Decorations\n\n    const methods = Object.keys(this.root._decorations);\n    for (let i = 0; i < methods.length; ++i) {\n        const method = methods[i];\n        this[method] = this.root._decorations[method];\n    }\n};\n\nHoek.inherits(internals.Plugin, Podium);\n\n\ninternals.Plugin.prototype._single = function () {\n\n    if (this.connections &&\n        this.connections.length === 1) {\n\n        this.info = this.connections[0].info;\n        this.listener = this.connections[0].listener;\n        this.registrations = this.connections[0].registrations;\n        this.auth.api = this.connections[0].auth.api;\n    }\n    else {\n        this.info = null;\n        this.listener = null;\n        this.registrations = null;\n        this.auth.api = null;\n    }\n};\n\n\ninternals.Plugin.prototype.select = function (/* labels */) {\n\n    let labels = [];\n    for (let i = 0; i < arguments.length; ++i) {\n        labels.push(arguments[i]);\n    }\n\n    labels = Hoek.flatten(labels);\n    return this._select(labels);\n};\n\n\ninternals.Plugin.prototype._select = function (labels, plugin) {\n\n    let connections = this.connections;\n\n    if (labels &&\n        labels.length) {            // Captures both empty arrays and empty strings\n\n        Hoek.assert(this.connections, 'Cannot select inside a connectionless plugin');\n\n        connections = [];\n        for (let i = 0; i < this.connections.length; ++i) {\n            const connection = this.connections[i];\n            if (Hoek.intersect(connection.settings.labels, labels).length) {\n                connections.push(connection);\n            }\n        }\n\n        if (!plugin &&\n            connections.length === this.connections.length) {\n\n            return this;\n        }\n    }\n\n    const env = (plugin !== undefined ? plugin : this.realm);                     // Allow empty string\n    return new internals.Plugin(this.root, connections, env, this);\n};\n\n\ninternals.Plugin.prototype._clone = function (connections, plugin) {\n\n    const env = (plugin !== undefined ? plugin : this.realm);                     // Allow empty string\n    return new internals.Plugin(this.root, connections, env, this);\n};\n\n\ninternals.Plugin.prototype.register = function (plugins /*, [options], callback */) {\n\n    let options = (typeof arguments[1] === 'object' ? arguments[1] : {});\n    const callback = (typeof arguments[1] === 'object' ? arguments[2] : arguments[1]);\n\n    if (!callback) {\n        return Promises.wrap(this, this.register, [plugins, options]);\n    }\n\n    if (this.realm.modifiers.route.prefix ||\n        this.realm.modifiers.route.vhost) {\n\n        options = Hoek.clone(options);\n        options.routes = options.routes || {};\n\n        options.routes.prefix = (this.realm.modifiers.route.prefix || '') + (options.routes.prefix || '') || undefined;\n        options.routes.vhost = this.realm.modifiers.route.vhost || options.routes.vhost;\n    }\n\n    options = Schema.apply('register', options);\n\n    /*\n        const register = function (server, options, next) { return next(); };\n        register.attributes = {\n            pkg: require('../package.json'),\n            name: 'plugin',\n            version: '1.1.1',\n            multiple: false,\n            dependencies: [],\n            connections: false,\n            once: true\n        };\n\n        const item = {\n            register: register,\n            options: options        // -optional--\n        };\n\n        - OR -\n\n        const item = function () {}\n        item.register = register;\n        item.options = options;\n\n        const plugins = register, items, [register, item]\n    */\n\n    const registrations = [];\n    plugins = [].concat(plugins);\n    for (let i = 0; i < plugins.length; ++i) {\n        let plugin = plugins[i];\n\n        if (typeof plugin === 'function') {\n            if (!plugin.register) {                                 // plugin is register() function\n                plugin = { register: plugin };\n            }\n            else {\n                plugin = Hoek.shallow(plugin);                      // Convert function to object\n            }\n        }\n\n        if (plugin.register.register) {                             // Required plugin\n            plugin.register = plugin.register.register;\n        }\n\n        plugin = Schema.apply('plugin', plugin);\n\n        const attributes = plugin.register.attributes;\n        const registration = {\n            register: plugin.register,\n            name: attributes.name || attributes.pkg.name,\n            version: attributes.version || attributes.pkg.version,\n            multiple: attributes.multiple,\n            pluginOptions: plugin.options,\n            dependencies: attributes.dependencies,\n            connections: attributes.connections,\n            options: {\n                once: attributes.once || (plugin.once !== undefined ? plugin.once : options.once),\n                routes: {\n                    prefix: plugin.routes.prefix || options.routes.prefix,\n                    vhost: plugin.routes.vhost || options.routes.vhost\n                },\n                select: plugin.select || options.select\n            }\n        };\n\n        registrations.push(registration);\n    }\n\n    this.root._registring = true;\n\n    const each = (item, next) => {\n\n        const selection = this._select(item.options.select, item.name);\n        selection.realm.modifiers.route.prefix = item.options.routes.prefix;\n        selection.realm.modifiers.route.vhost = item.options.routes.vhost;\n        selection.realm.pluginOptions = item.pluginOptions || {};\n\n        const registrationData = {\n            version: item.version,\n            name: item.name,\n            options: item.pluginOptions,\n            attributes: item.register.attributes\n        };\n\n        // Protect against multiple registrations\n\n        const connectionless = (item.connections === 'conditional' ? selection.connections.length === 0 : !item.connections);\n        if (connectionless) {\n            if (this.root._registrations[item.name]) {\n                if (item.options.once) {\n                    return next();\n                }\n\n                Hoek.assert(item.multiple, 'Plugin', item.name, 'already registered');\n            }\n            else {\n                this.root._registrations[item.name] = registrationData;\n            }\n        }\n\n        const connections = [];\n        if (selection.connections) {\n            for (let i = 0; i < selection.connections.length; ++i) {\n                const connection = selection.connections[i];\n                if (connection.registrations[item.name]) {\n                    if (item.options.once) {\n                        continue;\n                    }\n\n                    Hoek.assert(item.multiple, 'Plugin', item.name, 'already registered in:', connection.info.uri);\n                }\n                else {\n                    connection.registrations[item.name] = registrationData;\n                }\n\n                connections.push(connection);\n            }\n\n            if (item.options.once &&\n                !connectionless &&\n                !connections.length) {\n\n                return next();                                              // All the connections already registered\n            }\n        }\n\n        selection.connections = (connectionless ? null : connections);\n        selection._single();\n\n        if (item.dependencies) {\n            selection.dependency(item.dependencies);\n        }\n\n        if (connectionless) {\n            selection.connection = this.root.connection;\n        }\n\n        // Register\n\n        item.register(selection, item.pluginOptions || {}, next);\n    };\n\n    Items.serial(registrations, each, (err) => {\n\n        this.root._registring = false;\n        return Hoek.nextTick(callback)(err);\n    });\n};\n\n\ninternals.Plugin.prototype.bind = function (context) {\n\n    Hoek.assert(typeof context === 'object', 'bind must be an object');\n    this.realm.settings.bind = context;\n};\n\n\ninternals.Plugin.prototype.cache = function (options, _segment) {\n\n    options = Schema.apply('cachePolicy', options);\n\n    const segment = options.segment || _segment || (this.realm.plugin ? '!' + this.realm.plugin : '');\n    Hoek.assert(segment, 'Missing cache segment name');\n\n    const cacheName = options.cache || '_default';\n    const cache = this.root._caches[cacheName];\n    Hoek.assert(cache, 'Unknown cache', cacheName);\n    Hoek.assert(!cache.segments[segment] || cache.shared || options.shared, 'Cannot provision the same cache segment more than once');\n    cache.segments[segment] = true;\n\n    return new Catbox.Policy(options, cache.client, segment);\n};\n\n\ninternals.Plugin.prototype.decoder = function (encoding, decoder) {\n\n    this._apply('decoder', Connection.prototype.decoder, [encoding, decoder]);\n};\n\n\ninternals.Plugin.prototype.decorate = function (type, property, method, options) {\n\n    Hoek.assert(['reply', 'request', 'server'].indexOf(type) !== -1, 'Unknown decoration type:', type);\n    Hoek.assert(property, 'Missing decoration property name');\n    Hoek.assert(typeof property === 'string', 'Decoration property must be a string');\n    Hoek.assert(property[0] !== '_', 'Property name cannot begin with an underscore:', property);\n\n    // Request\n\n    if (type === 'request') {\n        return this.root._requestor.decorate(property, method, options);\n    }\n\n    Hoek.assert(!options, 'Cannot specify options for non-request decoration');\n\n    // Reply\n\n    if (type === 'reply') {\n        return this.root._replier.decorate(property, method);\n    }\n\n    // Server\n\n    Hoek.assert(!this.root._decorations[property], 'Server decoration already defined:', property);\n    Hoek.assert(this[property] === undefined && this.root[property] === undefined, 'Cannot override the built-in server interface method:', property);\n\n    this.root._decorations[property] = method;\n\n    this[property] = method;\n    let parent = this._parent;\n    while (parent) {\n        parent[property] = method;\n        parent = parent._parent;\n    }\n};\n\n\ninternals.Plugin.prototype.dependency = function (dependencies, after) {\n\n    Hoek.assert(this.realm.plugin, 'Cannot call dependency() outside of a plugin');\n    Hoek.assert(!after || typeof after === 'function', 'Invalid after method');\n\n    dependencies = [].concat(dependencies);\n    this.root._dependencies.push({ plugin: this.realm.plugin, connections: this.connections, deps: dependencies });\n\n    if (after) {\n        this.ext('onPreStart', after, { after: dependencies });\n    }\n};\n\n\ninternals.Plugin.prototype.emit = function (criteria, data, callback) {\n\n    this.root._events.emit(criteria, data, callback);\n};\n\n\ninternals.Plugin.prototype.encoder = function (encoding, encoder) {\n\n    this._apply('encoder', Connection.prototype.encoder, [encoding, encoder]);\n};\n\n\ninternals.Plugin.prototype.event = function (event) {\n\n    this.root._events.registerEvent(event);\n};\n\n\ninternals.Plugin.prototype.expose = function (key, value) {\n\n    Hoek.assert(this.realm.plugin, 'Cannot call expose() outside of a plugin');\n\n    const plugin = this.realm.plugin;\n    this.root.plugins[plugin] = this.root.plugins[plugin] || {};\n\n    if (typeof key === 'string') {\n        this.root.plugins[plugin][key] = value;\n    }\n    else {\n        Hoek.merge(this.root.plugins[plugin], key);\n    }\n};\n\n\ninternals.Plugin.prototype.ext = function (events) {        // (event, method, options) -OR- (events)\n\n    if (typeof events === 'string') {\n        events = { type: arguments[0], method: arguments[1], options: arguments[2] };\n    }\n\n    events = Schema.apply('exts', events);\n\n    for (let i = 0; i < events.length; ++i) {\n        this._ext(events[i]);\n    }\n};\n\n\ninternals.Plugin.prototype._ext = function (event) {\n\n    event = Hoek.shallow(event);\n    event.plugin = this;\n    const type = event.type;\n\n    if (!this.root._extensions[type]) {\n\n        // Realm route extensions\n\n        if (event.options.sandbox === 'plugin') {\n            Hoek.assert(this.realm._extensions[type], 'Unknown event type', type);\n            return this.realm._extensions[type].add(event);\n        }\n\n        // Connection route extensions\n\n        return this._apply('ext', Connection.prototype._ext, [event]);\n    }\n\n    // Server extensions\n\n    Hoek.assert(!event.options.sandbox, 'Cannot specify sandbox option for server extension');\n    Hoek.assert(type !== 'onPreStart' || this.root._state === 'stopped', 'Cannot add onPreStart (after) extension after the server was initialized');\n    this.root._extensions[type].add(event);\n};\n\n\ninternals.Plugin.prototype.handler = function (name, method) {\n\n    Hoek.assert(typeof name === 'string', 'Invalid handler name');\n    Hoek.assert(!this.root._handlers[name], 'Handler name already exists:', name);\n    Hoek.assert(typeof method === 'function', 'Handler must be a function:', name);\n    Hoek.assert(!method.defaults || typeof method.defaults === 'object' || typeof method.defaults === 'function', 'Handler defaults property must be an object or function');\n    this.root._handlers[name] = method;\n};\n\n\ninternals.Plugin.prototype.inject = function (options, callback) {\n\n    Hoek.assert(this.connections.length === 1, 'Method not available when the selection has more than one connection or none');\n    return this.connections[0].inject(options, callback);\n};\n\n\ninternals.Plugin.prototype.log = function (tags, data, timestamp, _internal) {\n\n    tags = [].concat(tags);\n    timestamp = (timestamp ? (timestamp instanceof Date ? timestamp.getTime() : timestamp) : Date.now());\n    const internal = !!_internal;\n\n    const update = (typeof data !== 'function' ? { timestamp, tags, data, internal } : () => {\n\n        return { timestamp, tags, data: data(), internal };\n    });\n\n    this.root._events.emit({ name: 'log', tags }, update);\n};\n\n\ninternals.Plugin.prototype._log = function (tags, data) {\n\n    return this.log(tags, data, null, true);\n};\n\n\ninternals.Plugin.prototype.lookup = function (id) {\n\n    Hoek.assert(this.connections.length === 1, 'Method not available when the selection has more than one connection or none');\n    return this.connections[0].lookup(id);\n};\n\n\ninternals.Plugin.prototype.match = function (method, path, host) {\n\n    Hoek.assert(this.connections.length === 1, 'Method not available when the selection has more than one connection or none');\n    return this.connections[0].match(method, path, host);\n};\n\n\ninternals.Plugin.prototype.method = function (name, method, options) {\n\n    return this.root._methods.add(name, method, options, this.realm);\n};\n\n\ninternals.Plugin.prototype.path = function (relativeTo) {\n\n    Hoek.assert(relativeTo && typeof relativeTo === 'string', 'relativeTo must be a non-empty string');\n    this.realm.settings.files.relativeTo = relativeTo;\n};\n\n\ninternals.Plugin.prototype.route = function (options) {\n\n    Hoek.assert(arguments.length === 1, 'Method requires a single object argument or a single array of objects');\n    Hoek.assert(typeof options === 'object', 'Invalid route options');\n    Hoek.assert(this.connections, 'Cannot add route from a connectionless plugin');\n    Hoek.assert(this.connections.length, 'Cannot add a route without any connections');\n\n    this._apply('route', Connection.prototype._route, [options, this]);\n};\n\n\ninternals.Plugin.prototype.state = function (name, options) {\n\n    this._applyChild('state', 'states', 'add', [name, options]);\n};\n\n\ninternals.Plugin.prototype.table = function (host) {\n\n    Hoek.assert(this.connections, 'Cannot request routing table from a connectionless plugin');\n\n    const table = [];\n    for (let i = 0; i < this.connections.length; ++i) {\n        const connection = this.connections[i];\n        table.push({ info: connection.info, labels: connection.settings.labels, table: connection.table(host) });\n    }\n\n    return table;\n};\n\n\ninternals.Plugin.prototype._apply = function (type, func, args) {\n\n    Hoek.assert(this.connections, 'Cannot add ' + type + ' from a connectionless plugin');\n    Hoek.assert(this.connections.length, 'Cannot add ' + type + ' without a connection');\n\n    for (let i = 0; i < this.connections.length; ++i) {\n        func.apply(this.connections[i], args);\n    }\n};\n\n\ninternals.Plugin.prototype._applyChild = function (type, child, func, args) {\n\n    Hoek.assert(this.connections, 'Cannot add ' + type + ' from a connectionless plugin');\n    Hoek.assert(this.connections.length, 'Cannot add ' + type + ' without a connection');\n\n    for (let i = 0; i < this.connections.length; ++i) {\n        const obj = this.connections[i][child];\n        obj[func].apply(obj, args);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/promises.js":"'use strict';\n\n// Load modules\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.wrap = function (bind, method, args) {\n\n    return new Promise((resolve, reject) => {\n\n        const callback = (err, result) => {\n\n            if (err) {\n                return reject(err);\n            }\n\n            return resolve(result);\n        };\n\n        method.apply(bind, args ? args.concat(callback) : [callback]);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/reply.js":"'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Response = require('./response');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Reply = function () {\n\n    this._decorations = null;\n};\n\n\ninternals.Reply.prototype.decorate = function (property, method) {\n\n    Hoek.assert(!this._decorations || !this._decorations[property], 'Reply interface decoration already defined:', property);\n    Hoek.assert(['request', 'response', 'close', 'state', 'unstate', 'redirect', 'continue'].indexOf(property) === -1, 'Cannot override built-in reply interface decoration:', property);\n\n    this._decorations = this._decorations || {};\n    this._decorations[property] = method;\n};\n\n\n/*\n    const handler = function (request, reply) {\n\n        reply(error, result, ignore);   -> error || result (continue)\n        reply(...).takeover();          -> ... (continue)\n\n        reply.continue(ignore);         -> null (continue)\n    };\n\n    const ext = function (request, reply) {\n\n        reply(error, result, ignore);   -> error || result (respond)\n        reply(...).takeover();          -> ... (respond)\n\n        reply.continue(ignore);         -> (continue)\n    };\n\n    const pre = function (request, reply) {\n\n        reply(error);                   -> error (respond)  // failAction override\n        reply(null, result, ignore);    -> result (continue)\n        reply(...).takeover();          -> ... (respond)\n\n        reply.continue(ignore);         -> null (continue)\n    };\n\n    const auth = function (request, reply) {\n\n        reply(error, result, data);     -> error || result (respond) + data\n        reply(..., data).takeover();    -> ... (respond) + data\n\n        reply.continue(data);           -> (continue) + data\n    };\n*/\n\ninternals.Reply.prototype.interface = function (request, realm, options, next) {        // next(err || response, data);\n\n    const reply = (err, response, data) => {\n\n        Hoek.assert(data === undefined || options.data, 'Reply interface does not allow a third argument');\n\n        reply._data = data;                 // Held for later\n        return reply.response(err !== null && err !== undefined ? err : response);\n    };\n\n    reply._settings = options;\n    reply._replied = false;\n    reply._next = Hoek.once(next);\n\n    reply.realm = realm;\n    reply.request = request;\n\n    reply.close = internals.close;\n    reply.continue = internals.continue;\n    reply.state = internals.state;\n    reply.unstate = internals.unstate;\n    reply.redirect = internals.redirect;\n    reply.response = internals.response;\n    reply.entity = internals.entity;\n\n    if (this._decorations) {\n        const methods = Object.keys(this._decorations);\n        for (let i = 0; i < methods.length; ++i) {\n            const method = methods[i];\n            reply[method] = this._decorations[method];\n        }\n    }\n\n    return reply;\n};\n\n\ninternals.close = function (options) {\n\n    options = options || {};\n    this._next({ closed: true, end: options.end !== false });\n};\n\n\ninternals.continue = function (data) {\n\n    if (data !== undefined) {\n        if (this._settings.data) {\n            this._data = data;\n        }\n        else if (this._settings.postHandler) {\n            const next = this._next;\n            this._next = (result) => next(null, result);            // Shift argument to signal not to stop processing other extensions\n            return this.response(data);\n        }\n        else {\n            throw new Error('reply.continue() does not allow any arguments');\n        }\n    }\n\n    this._next(null);\n    this._next = null;\n};\n\n\ninternals.state = function (name, value, options) {\n\n    this.request._setState(name, value, options);\n};\n\n\ninternals.unstate = function (name, options) {\n\n    this.request._clearState(name, options);\n};\n\n\ninternals.redirect = function (location) {\n\n    return this.response('').redirect(location);\n};\n\n\ninternals.response = function (result) {\n\n    Hoek.assert(!this._replied, 'reply interface called twice');\n    this._replied = true;\n\n    const response = Response.wrap(result, this.request);\n    if (response.isBoom) {\n        this._next(response);\n        this._next = null;\n        return response;\n    }\n\n    response.hold = internals.hold(this);\n\n    process.nextTick(() => {\n\n        response.hold = undefined;\n\n        if (!response.send &&\n            this._next) {\n\n            response._prepare(this._next);\n            this._next = null;\n        }\n    });\n\n    return response;\n};\n\n\ninternals.hold = function (reply) {\n\n    return function () {\n\n        this.hold = undefined;\n        this.send = () => {\n\n            this.send = undefined;\n            this._prepare(reply._next);\n            this._next = null;\n        };\n\n        return this;\n    };\n};\n\n\ninternals.entity = function (options) {\n\n    Hoek.assert(options, 'Entity method missing required options');\n    Hoek.assert(options.etag || options.modified, 'Entity methods missing require options key');\n\n    this.request._entity = options;\n\n    if (Response.unmodified(this.request, options)) {\n        return this.response().code(304).takeover();\n    }\n\n    return null;\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/request.js":"'use strict';\n\n// Load modules\n\nconst Url = require('url');\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Items = require('items');\nconst Podium = require('podium');\nconst Cors = require('./cors');\nconst Protect = require('./protect');\nconst Response = require('./response');\nconst Transmit = require('./transmit');\n\n\n// Declare internals\n\nconst internals = {\n    properties: ['connection', 'server', 'url', 'query', 'path', 'method', 'mime', 'setUrl', 'setMethod', 'headers', 'id', 'app', 'plugins', 'route', 'auth', 'pre', 'preResponses', 'info', 'orig', 'params', 'paramsArray', 'payload', 'state', 'jsonp', 'response', 'raw', 'tail', 'addTail', 'domain', 'log', 'getLog', 'generateResponse']\n};\n\n\nexports = module.exports = internals.Generator = function () {\n\n    this._decorations = null;\n};\n\n\ninternals.Generator.prototype.request = function (connection, req, res, options) {\n\n    const request = new internals.Request(connection, req, res, options);\n\n    // Decorate\n\n    if (this._decorations) {\n        const properties = Object.keys(this._decorations);\n        for (let i = 0; i < properties.length; ++i) {\n            const property = properties[i];\n            const assignment = this._decorations[property];\n            request[property] = (assignment.apply ? assignment.method(request) : assignment.method);\n        }\n    }\n\n    return request;\n};\n\n\ninternals.Generator.prototype.decorate = function (property, method, options) {\n\n    options = options || {};\n\n    Hoek.assert(!this._decorations || this._decorations[property] === undefined, 'Request interface decoration already defined:', property);\n    Hoek.assert(internals.properties.indexOf(property) === -1, 'Cannot override built-in request interface decoration:', property);\n\n    this._decorations = this._decorations || {};\n    this._decorations[property] = { method, apply: options.apply };\n};\n\n\ninternals.Request = function (connection, req, res, options) {\n\n    Podium.call(this, ['finish', { name: 'peek', spread: true }, 'disconnect']);\n\n    // Take measurement as soon as possible\n\n    this._bench = new Hoek.Bench();\n    const now = Date.now();\n\n    // Public members\n\n    this.connection = connection;\n    this.server = connection.server;\n\n    this.url = null;\n    this.query = null;\n    this.path = null;\n    this.method = null;\n    this.mime = null;                       // Set if payload is parsed\n\n    this.setUrl = this._setUrl;             // Decoration removed after 'onRequest'\n    this.setMethod = this._setMethod;\n\n    this._setUrl(req.url, this.connection.settings.router.stripTrailingSlash);      // Sets: this.url, this.path, this.query\n    this._setMethod(req.method);                                                    // Sets: this.method\n    this.headers = req.headers;\n\n    this.id = now + ':' + connection.info.id + ':' + connection._requestCounter.value++;\n    if (connection._requestCounter.value > connection._requestCounter.max) {\n        connection._requestCounter.value = connection._requestCounter.min;\n    }\n\n    this.app = (options.app ? Hoek.shallow(options.app) : {});              // Place for application-specific state without conflicts with hapi, should not be used by plugins\n    this.plugins = (options.plugins ? Hoek.shallow(options.plugins) : {});  // Place for plugins to store state without conflicts with hapi, should be namespaced using plugin name\n\n    this._route = this.connection._router.specials.notFound.route;    // Used prior to routing (only settings are used, not the handler)\n    this.route = this._route.public;\n\n    this.auth = {\n        isAuthenticated: false,\n        credentials: options.credentials || null,       // Special keys: 'app', 'user', 'scope'\n        artifacts: options.artifacts || null,           // Scheme-specific artifacts\n        strategy: null,\n        mode: null,\n        error: null\n    };\n\n    this.pre = {};                          // Pre raw values\n    this.preResponses = {};                 // Pre response values\n\n    // Assigned elsewhere:\n\n    this.orig = {};\n    this.params = {};\n    this.paramsArray = [];              // Array of path parameters in path order\n    this.payload = null;\n    this.state = null;\n    this.jsonp = null;\n    this.response = null;\n\n    // Semi-public members\n\n    this.raw = {\n        req,\n        res\n    };\n\n    this.tail = this.addTail = this._addTail;       // Removed once wagging\n\n    // Private members\n\n    this._states = {};\n    this._entity = {};                  // Entity information set via reply.entity()\n    this._logger = [];\n    this._allowInternals = !!options.allowInternals;\n    this._isPayloadPending = true;      // false when incoming payload fully processed\n    this._isBailed = false;             // true when lifecycle should end\n    this._isReplied = false;            // true when response processing started\n    this._isFinalized = false;          // true when request completed (may be waiting on tails to complete)\n    this._tails = {};                   // tail id -> name (tracks pending tails)\n    this._tailIds = 0;                  // Used to generate a unique tail id\n    this._protect = new Protect(this);\n    this.domain = this._protect.domain;\n\n    // Request info\n\n    this.info = {\n        received: now,\n        responded: 0,\n        remoteAddress: req.connection.remoteAddress,\n        remotePort: req.connection.remotePort || '',\n        referrer: req.headers.referrer || req.headers.referer || '',\n        host: req.headers.host ? req.headers.host.replace(/\\s/g, '') : '',\n        acceptEncoding: this.connection._compression.accept(this)\n    };\n\n    this.info.hostname = this.info.host.split(':')[0];\n\n    // Listen to request state\n\n    this._onEnd = () => {\n\n        this._isPayloadPending = false;\n    };\n\n    this.raw.req.once('end', this._onEnd);\n\n    this._onClose = () => {\n\n        this._log(['request', 'closed', 'error']);\n        this._isPayloadPending = false;\n        this._isBailed = true;\n    };\n\n    this.raw.req.once('close', this._onClose);\n\n    this._onError = (err) => {\n\n        this._log(['request', 'error'], err);\n        this._isPayloadPending = false;\n    };\n\n    this.raw.req.once('error', this._onError);\n\n    // Log request\n\n    const about = {\n        method: this.method,\n        url: this.url.href,\n        agent: this.raw.req.headers['user-agent']\n    };\n\n    this._log(['received'], about, now);     // Must be last for object to be fully constructed\n};\n\nHoek.inherits(internals.Request, Podium);\n\n\ninternals.Request.prototype._setUrl = function (url, stripTrailingSlash) {\n\n    this.url = (typeof url === 'string' ? Url.parse(url, true) : url);\n    this.query = this.url.query;\n    this.path = this.url.pathname || '';                                                            // pathname excludes query\n\n    if (stripTrailingSlash &&\n        this.path.length > 1 &&\n        this.path[this.path.length - 1] === '/') {\n\n        this.path = this.path.slice(0, -1);\n        this.url.pathname = this.path;\n    }\n\n    this.path = this.connection._router.normalize(this.path);\n};\n\n\ninternals.Request.prototype._setMethod = function (method) {\n\n    Hoek.assert(method && typeof method === 'string', 'Missing method');\n    this.method = method.toLowerCase();\n};\n\n\ninternals.Request.prototype.log = function (tags, data, timestamp, _internal) {\n\n    tags = [].concat(tags);\n    timestamp = (timestamp ? (timestamp instanceof Date ? timestamp.getTime() : timestamp) : Date.now());\n    const internal = !!_internal;\n\n    let update = (typeof data !== 'function' ? [this, { request: this.id, timestamp, tags, data, internal }] : () => {\n\n        return [this, { request: this.id, timestamp, tags, data: data(), internal }];\n    });\n\n    if (this.route.settings.log) {\n        if (typeof data === 'function') {\n            update = update();\n        }\n\n        this._logger.push(update[1]);       // Add to request array\n    }\n\n    this.connection.emit({ name: internal ? 'request-internal' : 'request', tags }, update);\n};\n\n\ninternals.Request.prototype._log = function (tags, data) {\n\n    return this.log(tags, data, null, true);\n};\n\n\ninternals.Request.prototype.getLog = function (tags, internal) {\n\n    Hoek.assert(this.route.settings.log, 'Request logging is disabled');\n\n    if (typeof tags === 'boolean') {\n        internal = tags;\n        tags = [];\n    }\n\n    tags = [].concat(tags || []);\n    if (!tags.length &&\n        internal === undefined) {\n\n        return this._logger;\n    }\n\n    const filter = tags.length ? Hoek.mapToObject(tags) : null;\n    const result = [];\n\n    for (let i = 0; i < this._logger.length; ++i) {\n        const event = this._logger[i];\n        if (internal === undefined || event.internal === internal) {\n            if (filter) {\n                for (let j = 0; j < event.tags.length; ++j) {\n                    const tag = event.tags[j];\n                    if (filter[tag]) {\n                        result.push(event);\n                        break;\n                    }\n                }\n            }\n            else {\n                result.push(event);\n            }\n        }\n    }\n\n    return result;\n};\n\n\ninternals.Request.prototype._execute = function () {\n\n    // Execute onRequest extensions (can change request method and url)\n\n    if (!this.connection._extensions.onRequest.nodes) {\n        return this._lifecycle();\n    }\n\n    this._invoke(this.connection._extensions.onRequest, (err) => {\n\n        return this._lifecycle(err);\n    });\n};\n\n\ninternals.Request.prototype._lifecycle = function (err) {\n\n    // Undecorate request\n\n    this.setUrl = undefined;\n    this.setMethod = undefined;\n\n    if (err) {\n        return this._reply(err);\n    }\n\n    if (!this.path ||\n        this.path[0] !== '/') {\n\n        return this._reply(Boom.badRequest('Invalid path'));\n    }\n\n    // Lookup route\n\n    const match = this.connection._router.route(this.method, this.path, this.info.hostname);\n    if (!match.route.settings.isInternal ||\n        this._allowInternals) {\n\n        this._route = match.route;\n        this.route = this._route.public;\n    }\n\n    this.params = match.params || {};\n    this.paramsArray = match.paramsArray || [];\n\n    if (this.route.settings.cors) {\n        this.info.cors = {\n            isOriginMatch: Cors.matchOrigin(this.headers.origin, this.route.settings.cors)\n        };\n    }\n\n    // Setup timeout\n\n    if (this.raw.req.socket &&\n        this.route.settings.timeout.socket !== undefined) {\n\n        this.raw.req.socket.setTimeout(this.route.settings.timeout.socket || 0);    // Value can be false or positive\n    }\n\n    let serverTimeout = this.route.settings.timeout.server;\n    if (serverTimeout) {\n        serverTimeout = Math.floor(serverTimeout - this._bench.elapsed());          // Calculate the timeout from when the request was constructed\n        const timeoutReply = () => {\n\n            this._log(['request', 'server', 'timeout', 'error'], { timeout: serverTimeout, elapsed: this._bench.elapsed() });\n            this._reply(Boom.serverUnavailable());\n        };\n\n        if (serverTimeout <= 0) {\n            return timeoutReply();\n        }\n\n        this._serverTimeoutId = setTimeout(timeoutReply, serverTimeout);\n    }\n\n    // Execute lifecycle steps\n\n    const each = (func, next) => {\n\n        if (this._isReplied ||\n            this._isBailed) {\n\n            return next(Boom.internal('Already closed'));                       // Error is not used\n        }\n\n        if (typeof func !== 'function') {                                       // Extension point\n            return this._invoke(func, next);                                    // next() called with response object which ends processing (treated like error)\n        }\n\n        return func(this, next);\n    };\n\n    return Items.serial(this._route._cycle, each, (err) => this._reply(err));\n};\n\n\ninternals.Request.prototype._invoke = function (event, callback) {\n\n    this._protect.run(callback, (exit) => {\n\n        const each = (ext, next) => {\n\n            const options = { postHandler: (event.type === 'onPostHandler' || event.type === 'onPreResponse') };\n            const finalize = (result, override) => {\n\n                if (override) {\n                    this._setResponse(override);\n                }\n\n                return next(result);            // next() called with response object which ends processing (treated like error)\n            };\n\n            const reply = this.server._replier.interface(this, ext.plugin.realm, options, finalize);\n            const bind = (ext.bind || ext.plugin.realm.settings.bind);\n\n            ext.func.call(bind, this, reply);\n        };\n\n        Items.serial(event.nodes, each, exit);\n    });\n};\n\n\ninternals.Request.prototype._reply = function (exit) {\n\n    if (this._isReplied) {                                  // Prevent any future responses to this request\n        return;\n    }\n\n    this._isReplied = true;\n\n    clearTimeout(this._serverTimeoutId);\n\n    if (this._isBailed) {\n        return this._finalize();\n    }\n\n    if (this.response &&                                    // Can be null if response coming from exit\n        this.response.closed) {\n\n        if (this.response.end) {\n            this.raw.res.end();                             // End the response in case it wasn't already closed\n        }\n\n        return this._finalize();\n    }\n\n    if (exit) {                                             // Can be a valid response or error (if returned from an ext, already handled because this.response is also set)\n        this._setResponse(Response.wrap(exit, this));\n    }\n\n    this._protect.reset();\n\n    const transmit = (err) => {\n\n        if (err) {                                          // Can be valid response or error\n            this._setResponse(Response.wrap(err, this));\n        }\n\n        return Transmit.send(this, () => this._finalize());\n    };\n\n    if (!this._route._extensions.onPreResponse.nodes) {\n        return transmit();\n    }\n\n    return this._invoke(this._route._extensions.onPreResponse, transmit);\n};\n\n\ninternals.Request.prototype._finalize = function () {\n\n    this.info.responded = Date.now();\n\n    if (this.response &&\n        this.response.statusCode === 500 &&\n        this.response._error) {\n\n        this.connection.emit('request-error', [this, this.response._error]);\n        this._log(this.response._error.isDeveloperError ? ['internal', 'implementation', 'error'] : ['internal', 'error'], this.response._error);\n    }\n\n    this.connection.emit('response', this);\n\n    this._isFinalized = true;\n    this.addTail = undefined;\n    this.tail = undefined;\n\n    if (Object.keys(this._tails).length === 0) {\n        this.connection.emit('tail', this);\n    }\n\n    // Cleanup\n\n    this.raw.req.removeListener('end', this._onEnd);\n    this.raw.req.removeListener('close', this._onClose);\n    this.raw.req.removeListener('error', this._onError);\n\n    if (this.response &&\n        this.response._close) {\n\n        this.response._close();\n    }\n\n    this._protect.logger = this.server;\n};\n\n\ninternals.Request.prototype._setResponse = function (response) {\n\n    if (this.response &&\n        !this.response.isBoom &&\n        this.response !== response &&\n        (response.isBoom || this.response.source !== response.source)) {\n\n        this.response._close();\n    }\n\n    if (this._isFinalized) {\n        if (response._close) {\n            response._close();\n        }\n\n        return;\n    }\n\n    this.response = response;\n};\n\n\ninternals.Request.prototype._addTail = function (name) {\n\n    name = name || 'unknown';\n    const tailId = this._tailIds++;\n    this._tails[tailId] = name;\n    this._log(['tail', 'add'], { name, id: tailId });\n\n    const drop = () => {\n\n        if (!this._tails[tailId]) {\n            this._log(['tail', 'remove', 'error'], { name, id: tailId });             // Already removed\n            return;\n        }\n\n        delete this._tails[tailId];\n\n        if (Object.keys(this._tails).length === 0 &&\n            this._isFinalized) {\n\n            this._log(['tail', 'remove', 'last'], { name, id: tailId });\n            this.connection.emit('tail', this);\n        }\n        else {\n            this._log(['tail', 'remove'], { name, id: tailId });\n        }\n    };\n\n    return drop;\n};\n\n\ninternals.Request.prototype._setState = function (name, value, options) {          // options: see Defaults.state\n\n    const state = { name, value };\n    if (options) {\n        Hoek.assert(!options.autoValue, 'Cannot set autoValue directly in a response');\n        state.options = Hoek.clone(options);\n    }\n\n    this._states[name] = state;\n};\n\n\ninternals.Request.prototype._clearState = function (name, options) {\n\n    const state = { name };\n\n    state.options = Hoek.clone(options || {});\n    state.options.ttl = 0;\n\n    this._states[name] = state;\n};\n\n\ninternals.Request.prototype._tap = function () {\n\n    return (this.hasListeners('finish') || this.hasListeners('peek') ? new Response.Peek(this) : null);\n};\n\n\ninternals.Request.prototype.generateResponse = function (source, options) {\n\n    return new Response(source, this, options);\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/protect.js":"'use strict';\n\n// Load modules\n\nlet Domain = null;                                  // Loaded as needed\nconst Boom = require('boom');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports = module.exports = internals.Protect = function (request) {\n\n    this._error = null;\n    this.logger = request;                          // Replaced with server when request completes\n\n    if (!request.server.settings.useDomains) {\n        this.domain = null;\n        return;\n    }\n\n    Domain = Domain || require('domain');\n\n    this.domain = Domain.create();\n    this.domain.on('error', this._onError.bind(this));\n};\n\n\ninternals.Protect.prototype._onError = function (err) {\n\n    const handler = this._error;\n    if (handler) {\n        this._error = null;\n        return handler(err);\n    }\n\n    this.logger._log(['internal', 'implementation', 'error'], err);\n};\n\n\ninternals.Protect.prototype.run = function (next, enter) {              // enter: function (exit)\n\n    const finish = Hoek.once((arg0, arg1, arg2) => {\n\n        this._error = null;\n        return next(arg0, arg1, arg2);\n    });\n\n    if (this.domain) {\n        this._error = (err) => {\n\n            return finish(Boom.badImplementation('Uncaught error', err));\n        };\n    }\n\n    return enter(finish);\n};\n\n\ninternals.Protect.prototype.reset = function () {\n\n    this._error = null;\n};\n\n\ninternals.Protect.prototype.enter = function (func) {\n\n    if (!this.domain) {\n        return func();\n    }\n\n    this.domain.run(func);\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/lib/transmit.js":"'use strict';\n\n// Load modules\n\nconst Http = require('http');\nconst Stream = require('stream');\nconst Ammo = require('ammo');\nconst Boom = require('boom');\nconst Hoek = require('hoek');\nconst Items = require('items');\nconst Shot = require('shot');\nconst Auth = require('./auth');\nconst Cors = require('./cors');\nconst Response = require('./response');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.send = function (request, callback) {\n\n    const response = request.response;\n    if (response.isBoom) {\n        return internals.fail(request, response, callback);\n    }\n\n    internals.marshal(request, (err) => {\n\n        if (err) {\n            request._setResponse(err);\n            return internals.fail(request, err, callback);\n        }\n\n        return internals.transmit(response, (err) => {\n\n            if (err) {\n                request._setResponse(err);\n                return internals.fail(request, err, callback);\n            }\n\n            return callback();\n        });\n    });\n};\n\n\ninternals.marshal = function (request, next) {\n\n    const response = request.response;\n\n    Cors.headers(response);\n    internals.content(response, false);\n    internals.security(response);\n    internals.unmodified(response);\n\n    internals.state(response, (err) => {\n\n        if (err) {\n            request._log(['state', 'response', 'error'], err);\n            request._states = {};                                           // Clear broken state\n            return next(err);\n        }\n\n        internals.cache(response);\n\n        if (!response._isPayloadSupported() &&\n            request.method !== 'head') {\n\n            // Set empty stream\n\n            response._close();                                  // Close unused file streams\n            response._payload = new internals.Empty();\n            delete response.headers['content-length'];\n            return Auth.response(request, next);                // Must be last in case requires access to headers\n        }\n\n        response._marshal((err) => {\n\n            if (err) {\n                return next(Boom.wrap(err));\n            }\n\n            if (request.jsonp &&\n                response._payload.jsonp) {\n\n                response._header('content-type', 'text/javascript' + (response.settings.charset ? '; charset=' + response.settings.charset : ''));\n                response._header('x-content-type-options', 'nosniff');\n                response._payload.jsonp(request.jsonp);\n            }\n\n            if (response._payload.size &&\n                typeof response._payload.size === 'function') {\n\n                response._header('content-length', response._payload.size(), { override: false });\n            }\n\n            if (!response._isPayloadSupported()) {\n                response._close();                              // Close unused file streams\n                response._payload = new internals.Empty();      // Set empty stream\n            }\n\n            internals.content(response, true);\n            return Auth.response(request, next);               // Must be last in case requires access to headers\n        });\n    });\n};\n\n\ninternals.fail = function (request, boom, callback) {\n\n    const error = boom.output;\n    const response = new Response(error.payload, request);\n    response._error = boom;\n    response.code(error.statusCode);\n    response.headers = Hoek.clone(error.headers);           // Prevent source from being modified\n    request.response = response;                            // Not using request._setResponse() to avoid double log\n\n    internals.marshal(request, (err) => {\n\n        if (err) {\n\n            // Failed to marshal an error - replace with minimal representation of original error\n\n            const minimal = {\n                statusCode: error.statusCode,\n                error: Http.STATUS_CODES[error.statusCode],\n                message: boom.message\n            };\n\n            response._payload = new Response.Payload(JSON.stringify(minimal), {});\n        }\n\n        return internals.transmit(response, callback);\n    });\n};\n\n\ninternals.transmit = function (response, callback) {\n\n    // Setup source\n\n    const request = response.request;\n    const source = response._payload;\n    const length = parseInt(response.headers['content-length'], 10);      // In case value is a string\n\n    // Empty response\n\n    if (length === 0 &&\n        response.statusCode === 200 &&\n        request.route.settings.response.emptyStatusCode === 204) {\n\n        response.code(204);\n        delete response.headers['content-length'];\n    }\n\n    // Compression\n\n    const encoding = request.connection._compression.encoding(response);\n\n    // Range\n\n    let ranger = null;\n    if (request.route.settings.response.ranges &&\n        request.method === 'get' &&\n        response.statusCode === 200 &&\n        length > 0 &&\n        !encoding) {\n\n        if (request.headers.range) {\n\n            // Check If-Range\n\n            if (!request.headers['if-range'] ||\n                request.headers['if-range'] === response.headers.etag) {            // Ignoring last-modified date (weak)\n\n                // Parse header\n\n                const ranges = Ammo.header(request.headers.range, length);\n                if (!ranges) {\n                    const error = Boom.rangeNotSatisfiable();\n                    error.output.headers['content-range'] = 'bytes */' + length;\n                    return internals.fail(request, error, callback);\n                }\n\n                // Prepare transform\n\n                if (ranges.length === 1) {                                          // Ignore requests for multiple ranges\n                    const range = ranges[0];\n                    ranger = new Ammo.Stream(range);\n                    response.code(206);\n                    response.bytes(range.to - range.from + 1);\n                    response._header('content-range', 'bytes ' + range.from + '-' + range.to + '/' + length);\n                }\n            }\n        }\n\n        response._header('accept-ranges', 'bytes');\n    }\n\n    // Content-Encoding\n\n    let compressor = null;\n    if (encoding &&\n        length !== 0 &&\n        response.statusCode !== 206 &&\n        response._isPayloadSupported()) {\n\n        delete response.headers['content-length'];\n        response._header('content-encoding', encoding);\n\n        compressor = request.connection._compression.encoder(request, encoding);\n    }\n\n    if ((response.headers['content-encoding'] || encoding) &&\n        response.headers.etag &&\n        response.settings.varyEtag) {\n\n        response.headers.etag = response.headers.etag.slice(0, -1) + '-' + (response.headers['content-encoding'] || encoding) + '\"';\n    }\n\n    // Connection: close\n\n    const isInjection = Shot.isInjection(request.raw.req);\n    if (!isInjection && !request.connection._started) {\n        response._header('connection', 'close');\n    }\n\n    // Write headers\n\n    const error = internals.writeHead(response);\n    if (error) {\n        return Hoek.nextTick(callback)(error);\n    }\n\n    // Write payload\n\n    let hasEnded = false;\n    const end = (err, event) => {\n\n        if (hasEnded) {\n            return;\n        }\n\n        hasEnded = true;\n\n        if (!request.raw.res.finished &&\n            event !== 'aborted') {\n\n            request.raw.res.end();\n        }\n\n        source.removeListener('error', end);\n\n        request.raw.req.removeListener('aborted', onAborted);\n        request.raw.req.removeListener('close', onClose);\n\n        request.raw.res.removeListener('close', onClose);\n        request.raw.res.removeListener('error', end);\n        request.raw.res.removeListener('finish', end);\n\n        const tags = (err ? ['response', 'error']\n                        : (event ? ['response', 'error', event]\n                                 : ['response']));\n\n        if (event || err) {\n            request.emit('disconnect');\n        }\n\n        request._log(tags, err);\n        return callback();\n    };\n\n    source.once('error', end);\n\n    const onAborted = () => {\n\n        return end(null, 'aborted');\n    };\n\n    const onClose = () => {\n\n        return end(null, 'close');\n    };\n\n    request.raw.req.once('aborted', onAborted);\n    request.raw.req.once('close', onClose);\n\n    request.raw.res.once('close', onClose);\n    request.raw.res.once('error', end);\n    request.raw.res.once('finish', end);\n\n    const tap = response._tap();\n    const preview = (tap ? source.pipe(tap) : source);\n    const compressed = (compressor ? preview.pipe(compressor) : preview);\n    const ranged = (ranger ? compressed.pipe(ranger) : compressed);\n    ranged.pipe(request.raw.res);\n\n    // Injection\n\n    if (isInjection) {\n        request.raw.res._hapi = { request };\n\n        if (response.variety === 'plain') {\n            request.raw.res._hapi.result = response._isPayloadSupported() ? response.source : null;\n        }\n    }\n};\n\n\ninternals.writeHead = function (response) {\n\n    const res = response.request.raw.res;\n    const headers = Object.keys(response.headers);\n    let i = 0;\n\n    try {\n        for (; i < headers.length; ++i) {\n            const header = headers[i];\n            const value = response.headers[header];\n            if (value !== undefined) {\n                res.setHeader(header, value);\n            }\n        }\n    }\n    catch (err) {\n\n        for (--i; i >= 0; --i) {\n            res.setHeader(headers[i], null);        // Undo headers\n        }\n\n        return Boom.wrap(err);\n    }\n\n    try {\n        res.writeHead(response.statusCode);\n    }\n    catch (err) {\n        return Boom.wrap(err);\n    }\n\n    if (response.settings.message) {\n        res.statusMessage = response.settings.message;\n    }\n\n    return null;\n};\n\n\ninternals.Empty = function () {\n\n    Stream.Readable.call(this);\n};\n\nHoek.inherits(internals.Empty, Stream.Readable);\n\n\ninternals.Empty.prototype._read = function (/* size */) {\n\n    this.push(null);\n};\n\n\ninternals.cache = function (response) {\n\n    const request = response.request;\n\n    if (response.headers['cache-control']) {\n        return;\n    }\n\n    const policy = request.route.settings.cache &&\n                   request._route._cache &&\n                   (request.route.settings.cache._statuses[response.statusCode] || (response.statusCode === 304 && request.route.settings.cache._statuses['200']));\n\n    if (policy ||\n        response.settings.ttl) {\n\n        const ttl = (response.settings.ttl !== null ? response.settings.ttl : request._route._cache.ttl());\n        const privacy = (request.auth.isAuthenticated || response.headers['set-cookie'] ? 'private' : request.route.settings.cache.privacy || 'default');\n        response._header('cache-control', 'max-age=' + Math.floor(ttl / 1000) + ', must-revalidate' + (privacy !== 'default' ? ', ' + privacy : ''));\n    }\n    else if (request.route.settings.cache) {\n        response._header('cache-control', request.route.settings.cache.otherwise);\n    }\n};\n\n\ninternals.security = function (response) {\n\n    const request = response.request;\n\n    const security = request.route.settings.security;\n    if (security) {\n        if (security._hsts) {\n            response._header('strict-transport-security', security._hsts, { override: false });\n        }\n\n        if (security._xframe) {\n            response._header('x-frame-options', security._xframe, { override: false });\n        }\n\n        if (security.xss) {\n            response._header('x-xss-protection', '1; mode=block', { override: false });\n        }\n\n        if (security.noOpen) {\n            response._header('x-download-options', 'noopen', { override: false });\n        }\n\n        if (security.noSniff) {\n            response._header('x-content-type-options', 'nosniff', { override: false });\n        }\n    }\n};\n\n\ninternals.content = function (response, postMarshal) {\n\n    let type = response.headers['content-type'];\n    if (!type) {\n        if (response._contentType) {\n            const charset = (response.settings.charset && response._contentType !== 'application/octet-stream' ? '; charset=' + response.settings.charset : '');\n            response.type(response._contentType + charset);\n        }\n    }\n    else {\n        type = type.trim();\n        if ((!response._contentType || !postMarshal) &&\n        response.settings.charset &&\n        type.match(/^(?:text\\/)|(?:application\\/(?:json)|(?:javascript))/)) {\n\n            if (!type.match(/; *charset=/)) {\n                const semi = (type[type.length - 1] === ';');\n                response.type(type + (semi ? ' ' : '; ') + 'charset=' + (response.settings.charset));\n            }\n        }\n    }\n};\n\n\ninternals.state = function (response, next) {\n\n    const request = response.request;\n\n    const names = {};\n    const states = [];\n\n    const requestStates = Object.keys(request._states);\n    for (let i = 0; i < requestStates.length; ++i) {\n        const stateName = requestStates[i];\n        names[stateName] = true;\n        states.push(request._states[stateName]);\n    }\n\n    const each = (name, nextKey) => {\n\n        const autoValue = request.connection.states.cookies[name].autoValue;\n        if (!autoValue || names[name]) {\n            return nextKey();\n        }\n\n        names[name] = true;\n\n        if (typeof autoValue !== 'function') {\n            states.push({ name, value: autoValue });\n            return nextKey();\n        }\n\n        autoValue(request, (err, value) => {\n\n            if (err) {\n                return nextKey(err);\n            }\n\n            states.push({ name, value });\n            return nextKey();\n        });\n    };\n\n    const keys = Object.keys(request.connection.states.cookies);\n    Items.parallel(keys, each, (err) => {\n\n        if (err) {\n            return next(Boom.wrap(err));\n        }\n\n        if (!states.length) {\n            return next();\n        }\n\n        request.connection.states.format(states, (err, header) => {\n\n            if (err) {\n                return next(Boom.wrap(err));\n            }\n\n            const existing = response.headers['set-cookie'];\n            if (existing) {\n                header = (Array.isArray(existing) ? existing : [existing]).concat(header);\n            }\n\n            response._header('set-cookie', header);\n            return next();\n        });\n    });\n};\n\n\ninternals.unmodified = function (response) {\n\n    const request = response.request;\n\n    // Set headers from reply.entity()\n\n    if (request._entity.etag &&\n        !response.headers.etag) {\n\n        response.etag(request._entity.etag, { vary: request._entity.vary });\n    }\n\n    if (request._entity.modified &&\n        !response.headers['last-modified']) {\n\n        response.header('last-modified', request._entity.modified);\n    }\n\n    if (response.statusCode === 304) {\n        return;\n    }\n\n    const entity = {\n        etag: response.headers.etag,\n        vary: response.settings.varyEtag,\n        modified: response.headers['last-modified']\n    };\n\n    if (Response.unmodified(request, entity)) {\n        response.code(304);\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-hapi/node_modules/hapi/node_modules/ammo/lib/index.js":"'use strict';\n\n// Load modules\n\nconst Stream = require('stream');\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nexports.header = function (header, length) {\n\n    // Parse header\n\n    const parts = header.split('=');\n    if (parts.length !== 2 ||\n        parts[0] !== 'bytes') {\n\n        return null;\n    }\n\n    const lastPos = length - 1;\n\n    const result = [];\n    const ranges = parts[1].match(/\\d*\\-\\d*/g);\n\n    // Handle headers with multiple ranges\n\n    for (let i = 0; i < ranges.length; ++i) {\n        let range = ranges[i];\n        if (range.length === 1) {               // '-'\n            return null;\n        }\n\n        const set = {};\n        range = range.split('-');\n        if (range[0]) {\n            set.from = parseInt(range[0], 10);\n        }\n\n        if (range[1]) {\n            set.to = parseInt(range[1], 10);\n            if (set.from !== undefined) {      // Can be 0\n                // From-To\n                if (set.to > lastPos) {\n                    set.to = lastPos;\n                }\n            }\n            else {\n                // -To\n                set.from = length - set.to;\n                set.to = lastPos;\n            }\n        }\n        else {\n            // From-\n            set.to = lastPos;\n        }\n\n        if (set.from > set.to) {\n            return null;\n        }\n\n        result.push(set);\n    }\n\n    if (result.length === 1) {\n        return result;\n    }\n\n    // Sort and consolidate ranges\n\n    result.sort((a, b) => a.from - b.from);\n\n    const consolidated = [];\n    for (let i = result.length - 1; i > 0; --i) {\n        const current = result[i];\n        const before = result[i - 1];\n        if (current.from <= before.to + 1) {\n            before.to = current.to;\n        }\n        else {\n            consolidated.unshift(current);\n        }\n    }\n\n    consolidated.unshift(result[0]);\n\n    return consolidated;\n};\n\n\nexports.Stream = internals.Stream = function (range) {\n\n    Stream.Transform.call(this);\n\n    this._range = range;\n    this._next = 0;\n};\n\nHoek.inherits(internals.Stream, Stream.Transform);\n\n\ninternals.Stream.prototype._transform = function (chunk, encoding, done) {\n\n    // Read desired range from a stream\n\n    const pos = this._next;\n    this._next = this._next + chunk.length;\n\n    if (this._next <= this._range.from ||       // Before range\n        pos > this._range.to) {                 // After range\n\n        return done();\n    }\n\n    // Calc bounds of chunk to read\n\n    const from = Math.max(0, this._range.from - pos);\n    const to = Math.min(chunk.length, this._range.to - pos + 1);\n\n    this.push(chunk.slice(from, to));\n    return done();\n};\n"}